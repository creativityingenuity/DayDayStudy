###泛型有什么优点？
1. 保证类型安全性
	1. list<integer> arraylist 一个只能存放int,一个啥都可以存，编译的时候不会报错
2. 避免了强制转换，提高了性能
3. 代码观看清晰条理

###垃圾回收机制与jvm结构，老年代算法，方法区有啥，GCRoot都有啥
https://juejin.im/post/6844903905457864718

>jvm内存结构

图

* 其中线程私有数据区域的生命周期和线程相同，每个线程与操作系统的本地线程直接映射，这部分的内存区域跟着本地线程创建销毁。
* 线程共享区域随虚拟机的启动而创建，关闭而销毁。
* 除pc之外，别的区域都有可能造成OOM

1. 方法区(包含常量池)
	1. 用于存储被jvm加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。**使用java堆的永久代实现方法区，GC收集的永久代区域。**永久代的内存回收主要目标是针对常量池的回收和类型的卸载。运行时常量池是方法区的一部分，class文件除了有类的版本，字段，方法，接口等描述信息外，还有一项是常量池，主要存放编译期间生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。

2. 堆
	1. 创建的对象与数组都保存在java堆内存中，因为是线程共享，所以与方法区两个是垃圾收集的区域，java堆中从GC的角度细分为：新生区与老年区。
3. 程序计数器 :指向当前线程所执行的字节码的行号
4. 虚拟机栈：
	1. 主要描述方法执行，每个方法在执行的时候创建一个栈帧，其中栈帧中存储了局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行结束，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
5. 本地方法区：
	1. 虚拟机栈执行java方法；本地方法栈执行native方法。比如java中调用C或C++中的方法，在这里执行。有的虚拟机会将虚拟机栈与本地方法栈合二为一。


   

###Handler机制了解吗？一个线程有几个Looper？为什么？
###Handler内存泄漏的GCRoot是什么？
###Handler休眠是怎样的？epoll的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？
###Handler通信，Binder通信
###简单描述下Handler,Handler是怎么切换线程的,Handler同步屏障
1个
###代理模式与装饰模式的区别，手写一个静态代理，一个动态代理,动态代理有什么用
>代理模式:

Java动态代理的优势是实现无侵入式的代码扩展，也就是方法的增强；让你可以在不用修改源码的情况下，增强一些方法；在方法的前后你可以做你任何想做的事情


1. 静态代理

想要生成代理类，需要让代理类和被代理类实现同一个接口，并且在代理类中添加被代理类的引用，代理类方法实现中添加代理逻辑，并决定是否调用被代理类方法，这种通过硬编码的方式指定代理类与被代理类的方式，叫静态代理。可以明显看出，**静态代理类与被代理类是耦合的，如果要代理100个类，你就得写100个代理类**

代码：

    public class RealTest{
		public void doSomthing(){
			system.out.print("原生方法");
		}
	}

	public interface Test{
		public void doSomthing();
	}

	public class TestProxy implements Test {
	  Test t = new RealTest();
	  public void doSomething() {
	     t.doSomething();
	  }
	}
刚开始我会觉得TestProxy定义出来纯属多余，直接实例化实现类完成操作不就结了吗？后来随着业务庞大，你就会知道，实现proxy类对真实类的封装对于粒度的控制有着重要的意义。但是静态代理这个模式本身有个大问题，如果类方法数量越来越多的时候，代理类的代码量是十分庞大的。所以引入动态代理来解决此类问题

3.动态代理

其实动态代理与静态代理的本质一样，最终程序运行时都需要生成一个代理对象实例，通过它来完成相关增强以及业务逻辑，只不过静态代理需要硬编码的方式指定，而动态代理则是以动态方式生成代理(编译时操作字节码以及运行时通过反射方式)。动态生成的好处很明显，代理逻辑与业务逻辑是互相独立的，没有耦合，代理1个类100个类没有任何区别

代码：

	public interface Subject   
	{   
	  public void doSomething();   
	}
	
	public class RealSubject implements Subject   
	{   
	  public void doSomething()   
	  {   
	    System.out.println( "call doSomething()" );   
	  }   
	}  
	
	public class ProxyHandler implements InvocationHandler
	{
	    private Object tar;
	
	    //绑定委托对象，并返回代理类
	    public Object bind(Object tar)
	    {
	        this.tar = tar;
	        //绑定该类实现的所有接口，取得代理类 
	        return Proxy.newProxyInstance(tar.getClass().getClassLoader(),
	                                      tar.getClass().getInterfaces(),
	                                      this);
	    }    
		@Override
	    public Object invoke(Object proxy , Method method , Object[] args)throws Throwable
	    {
	        Object result = null;
	        //这里就可以进行所谓的AOP编程了
	        //在调用具体函数方法前，执行功能处理
	        result = method.invoke(tar,args);
	        //在调用具体函数方法后，执行功能处理
	        return result;
	    }
	}
	public class TestProxy
	{
	    public static void main(String args[])
	    {
	           ProxyHandler proxy = new ProxyHandler();
	           //绑定该类实现的所有接口
	           Subject sub = (Subject) proxy.bind(new RealSubject());
	           sub.doSomething();
	    }
	}

Proxy类的代码量被固定下来，不会因为业务的逐渐庞大而庞大；可以实现AOP编程，实际上静态代理也可以实现，总的来说，AOP可以算作是代理模式的一个典型应用；解耦，通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。

>代理模式与装饰模式的区别

**装饰器模式应当为所装饰的对象提供增强功能，而代理模式对所代理对象的使用施加控制，并不提供对象本身的增强功能**。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

###AOP TODO待补充
传统面向对象思想中，如果想要实现功能复用，要么继承、要么引用，无论哪种方式，对代码都有一定的侵入性，耦合无可避免，侵入性啥意思？简单来说：如果你想要用它增强你程序的功能，你必须改动你的程序代码，那它就具有侵入性。如果只有一点两点需要增强还好说，如果大量的功能点需要被增强，工作量就会很大，代码也不太优雅。想象一下，如果你对外公开了一系列的接口，现在领导说了，接口要加权限控制。在哪加？最笨的当然就是写个程序验证的逻辑，然后每个接口都拿来调用一遍。这也正是面向对象思想的短板，在要为程序新增一些通用功能时，只能通过耦合的方式才能进行。AOP正是为此而生，AOP旨在通过一种无耦合的方式来为程序带来增强。而动态代理，就是AOP实现方式中的一种

