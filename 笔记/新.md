https://github.com/JsonChao/Awesome-Android-Interview/blob/master/Java%E7%9B%B8%E5%85%B3/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.md

算法：https://zhuanlan.zhihu.com/p/84230862

面试题： https://mp.weixin.qq.com/s/CiO_T95JWA-ijKghrnCQzw?comefrom=https://blogread.cn/news/

https://mp.weixin.qq.com/s/njD4f50zPEydrRcv5BZiEw 

# Java ok

## equals和hashcode，他们为何必须一起重写？hashcode方法重写规则

Object中的equals是判断两个对象的地址值，hashcode是内存地址换算出来的一个哈希值。

创建两个地址值不同，字面量相同的字符串对象，如果重写了equals，这时候hashCode返回的是内存地址值。就会变成两个不等的对象。

规则：hashCode方法的重写原则就是保证equals方法认定为相同的两个对象拥有相同的哈希值

hashcode和equals的约定关系如下：

​	如果两个对象相等，那么他们一定有相同的哈希值（hashcode）

​	如果两个对象的哈希值相等，那么这两个对象有可能相等也有可能不相等

在集合中，判断两个对象是否相等先判断hashcode再判断equals

> string,equals,==有什么区别

==比较的是两个对象的内存地址相不相同，相同则返回true。equals默认情况下是调用==，所以也是比较内存地址

string类重写的equals方法，先判断地址是否相等，然后再在长度相同的前提下比对每个字符是否相等。

##自动装箱发生在什么时候？编译期还是运行期

是在编译时自动完成替换的，装箱阶段自动替换为了 valueOf 方法，拆箱阶段自动替换为了 xxxValue 方法。

##java和字节码有什么区别

Java文件通过javac编译成虚拟机识别的字节码文件.class

## 为何匿名内部类的参数引用要用 final 修饰

这里所说的匿名内部类主要是指在其外部类的成员方法内定义的同时完成实例化的类，若其访问该成员方法中的局部变量，局部变量必须要被final修饰。原因是编译器实现上的困难：**内部类对象的生命周期很有可能会超过局部变量的生命周期**。

1. 局部变量的生命周期：当该方法被调用时，该方法中的局部变量在栈中被创建，当方法调用结束时，退栈，这些局部变量全部死亡。而内部类对象生命周期与其它类对象一样：自创建一个匿名内部类对象，系统为该对象分配内存，直到没有引用变量指向分配给该对象的内存，它才有可能会死亡（被JVM垃圾回收）。所以完全可能出现的一种情况是：成员方法已调用结束，局部变量已死亡，但匿名内部类的对象仍然活着。

  2. 如果匿名内部类的对象访问了同一个方法中的局部变量，就要求只要匿名内部类对象还活着，那么栈中的那些它要所访问的局部变量就不能“死亡”。

3. 解决方法：匿名内部类对象可以访问同一个方法中被定义为final类型的局部变量。**定义为final后，编译器会把匿名内部类对象要访问的所有final类型局部变量，都拷贝一份作为该对象的成员变量。这样，即使栈中局部变量已经死亡，匿名内部类对象照样可以拿到该局部变量的值，因为它自己拷贝了一份，且与原局部变量的值始终保持一致**（final类型不可变）

# 线程 ok

## 自定义线程池以及线程池的工作原理

> 1.通过ThreadPoolExecutor构造线程池

ThreadPoolExecutor 线程池用于管理多个线程，减少线程创建销毁消耗，提高代码执行效率

构造函数

- corePoolSize： 线程池核心线程数量。（默认情况下，核心线程一直存在）核心线程一旦创建会一直执行任务或等待任务到来，而非核心线程只在任务队列塞满任务时去执行多出的任务，并且非核心线程在等待一段时间后将会被回收，这个时间是keepAliveTime参数。
- maximumPoolSize：线程池最大线程数量。最大线程数=核心线程+非核心线程。执行完任务后非核心线程会被销毁。
- keepAliveTime： 非核心线程的超时时长。当等待时间超过这个时间时，非核心线程就会被回收。当任务很多，每个任务执行时间很短的情况下调大该值有助于提高线程利用率。注意：当allowCoreThreadTimeOut属性设为true时，该属性也可用于核心线程。
- unit： 线程池维护线程所允许的空闲时间的单位
- workQueue： 线程池所使用的任务队列
- threadFactory：线程池用于创建线程
- handler： 线程池对拒绝任务的处理策略

规则：

当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务；

如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行；

如果任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务；

如果线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，调用RejectedtionHandler来执行拒绝策略。

> 2.通过Executors构造线程池

* newCachedThreadPool：一个数量无限多的线程池，它所有的线程都是非核心线程，当有新任务来时如果没有空闲的线程则直接创建新的线程不会去排队而直接执行，并且超时时间都是60s，所以此线程池适合执行大量耗时小的任务。由于设置了超时时间为60s，所以当线程空闲一定时间时就会被系统回收，所以理论上该线程池不会有占用系统资源的无用线程。**适用：执行大量短期异步任务**
  * corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)；
* newFixedThreadPool：线程数量固定的线程池，该线程池的线程全部为核心线程，它们没有超时机制且排队任务队列无限制，因为全都是核心线程，所以响应较快，且不用担心线程会被回收。**适用：执行长期的任务，性能好很多**
  * 参数是nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue<Runnable>() 
* newScheduledThreadPool:数量固定的核心线程，且有数量无限多的非核心线程，但是它的非核心线程超时时间是0s，所以非核心线程一旦空闲立马就会被回收。这类线程池适合用于执行定时任务和固定周期的重复任务。**适用：周期性执行任务的场景**
  * corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列；
* newSingleThreadExecutor:内部只有一个核心线程，线程的存活时间是无限的。当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)，它确保所有任务进来都要排队按顺序执行。**适用：一个任务一个任务执行的场景**
  * corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列

阿里不建议用：

​	newCachedThreadPool和newScheduledThreadPool：创建线程数量是Integer.MAX_VALU，可能会创建大量线程，导致oom

​	newFixedThreadPool和newSingleThreadExecutor：队列长度时Integer.MAX_VALUE,可能会堆积大量请求，导致oom

```
eg:ExecutorService executorService = Executors.newCachedThreadPool();
线程池一般用法：                        
 shutDown()，关闭线程池，需要执行完已提交的任务；
 shutDownNow()，关闭线程池，并尝试结束已提交的任务；
 allowCoreThreadTimeOut(boolen)，允许核心线程闲置超时回收；
 execute()，提交任务无返回值；
 submit()，提交任务有返回值；
```

> 线程池核心数量确定

1. 先看下机器的CPU核数，然后在设定具体参数：

   CPU核数 = Runtime.getRuntime().availableProcessors()

2. 分析下线程池处理的程序是CPU密集型，还是IO密集型

   CPU密集型：核心线程数 = CPU核数 + 1

   ​	尽量使用较小的线程池，因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销

   IO密集型：核心线程数 = CPU核数 * 2

   ​	可以使用稍大的线程池，IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间


##如何让两个线程循环交替打印，线程间同步的方法

>三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC....”的字符串。

思路：使用一个取模的判断逻辑 **C%M ==N**，题为 3 个线程，所以可以按取模结果编号：0、1、2，他们与 3 取模结果仍为本身，则执行打印逻辑。

```
public class TestPrint {
    ReentrantLock lock = new ReentrantLock();

    private  int count = 10;

    public void start() {
        Condition conditionA = lock.newCondition();
        Condition conditionB = lock.newCondition();
        Condition conditionC = lock.newCondition();
        new Thread(new TestRun(conditionA,conditionB,"A"),"线程1 ：").start();
        new Thread(new TestRun(conditionB,conditionC,"B"),"线程2 ：").start();
        new Thread(new TestRun(conditionC,conditionA,"C"),"线程3 ：").start();
    }

    class TestRun implements Runnable{

        private  Condition next ;
        // 当前Condition
        private  Condition now ;
        // 打印的字符
        private String str;

        public TestRun(Condition now, Condition next, String str) {
            this.now = now;
            this.next = next;
            this.str = str;
        }

        @Override
        public void run() {
            try {
                lock.lock();
                for (int i = 0;i<count;i++){
                    next   .signal();
                    Log.e("---",str);

                    now.await();
                }
            }catch (Exception e){

            }finally {
                lock.unlock();
            }

        }
    }
}
```

> 两个线程交替打印 0~100 的奇偶数

```
public class OddEvenPrinter {

    private Object monitor = new Object();

    public void start() {
        PrintThread printThread = new PrintThread();
        new Thread(printThread, "线程1").start();
        new Thread(printThread, "线程2").start();
    }

    class PrintThread implements Runnable {

        volatile int count = 1;

        @Override
        public void run() {
            synchronized (monitor) {
                while (count < 100) {
                    try {
                        System.out.println(Thread.currentThread().getName() + " : " + (count++));
                        monitor.notify();
                        monitor.wait();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行， 只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放），调用wait方法的一个或多个线程就会解除wait状态，重新参与竞争对象锁，程序如果可以再次得到锁，就可以继续向下运行。
```

##怎么中止一个线程，Thread.Interupt一定有效吗？

1. 使用volatile boolean变量退出标志，使线程正常退出，也就是当run方法完成后线程终止。
2. 使用interrupt()方法中断线程，但是线程不一定会终止。

interupt:

- 如果线程未在阻塞状态，这个方法仅仅是设置了interrupt状态
- 如果线程在阻塞状态，这个方法会清除interrupt状态并抛异常

判断当前线程是否已经中断

​	Thread.interrupted()是静态方法，获取中断状态，并清空

​	thread.isInterrupted()是非静态方法，获取不清除状态

```
// Case 1 无阻塞的情况 通过加标记来退出循环
public static void main(String[] args) throws Exception {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                int i = 0;
                while(!Thread.interrupted()) {
                    System.out.println(i++);
                }
            }
        });
        thread.start();
        Thread.sleep(50);
        thread.interrupt();
    }
    
// Case 2 有阻塞的情况 产生异常退出循环
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                int i = 0;
                try {
                    while(!Thread.interrupted()) {
                        System.out.println(i++);
                        Thread.sleep(1);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    // 抛出 InterruptedException 后中断标志被清除，标准做法是再次调用 interrupt 恢复中断
                    Thread.currentThread().interrupt();
                }
            }
        });
        thread.start();
        Thread.sleep(50);
        thread.interrupt();
    }
```

#锁和并发 OK

##为什么多线程同时访问（读写）同个变量，会有并发问题？

Java 内存模型规定了所有的变量都存储在主内存中，每条线程有自己的工作内存。
线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。
线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。
不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步。

##乐观锁与悲观锁

悲观锁：总是假设最坏的情况，每次去拿数据的时候都会认为别人会修改，所以每次拿数据的时候都会上锁，线程一旦得到锁，其他线程就挂起等待，适用于写入操作频繁的场景；synchronized 就是悲观锁 
乐观锁：总是假设最好的情况，每次拿数据时都认为别人不会修改，不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。适用于读取操作频繁的场景

##ReentranLock跟synchronized有什么区别？synchronized与ReentranLock发生异常的场景？

> 相同

都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待

> 不同

1. API层面

   * synchronized是关键字，是原生语法层面的互斥，需JVM实现。ReentranLock是1.5之后API提供的

   * synchronized可以修饰方法和代码块,Reentranlock只能在方法内使用

2. 等待可中断

   * 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，去处理别的事情
   * 假如业务代码中有两个线程，Thread1 Thread2。假设 Thread1 获取了对象object的锁，Thread2将等待Thread1释放object的锁。
     - 使用synchronized。如果Thread1不释放，Thread2将一直阻塞等待，不能被中断。
     - 使用ReentrantLock。如果Thread1不释放，Thread2等待了很长时间以后，可以中断等待，转而去做别的事情。

3. 公平锁

   * 公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序获取锁，而非公平锁则是任何一个等待的线程都可以获取锁
   * synchronized是非公平锁，ReentranLock默认是非公平锁，但可以通过构造函数设置True使用公平锁

```
private ReentrantLock lock = new ReentrantLock();
public void run() {
    lock.lock();
    try{
        for(int i=0;i<5;i++){
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }finally{
        lock.unlock();
    }
}
```

> synchronized与ReentranLock发生异常的场景

发生异常的场景我查了半天没查到，应该就是线程抛出异常吧

在发生异常时，synchronized会自动释放锁，ReentranLock则需要与try{}finally{}搭配手动释放锁

##synchronized是公平锁还是非公平锁,ReentranLock是公平锁吗？是怎么实现的 

公平锁是指多个线程在等待同一个锁时，必须按照申请的顺序获取锁，而非公平锁则是任何一个等待的线程都可以获取锁

公平锁：

* 优点：所有的线程都能得到资源，不会饿死在队列中。
* 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞

非公平锁：

* 优点：减少唤起线程的开销，整体的吞吐效率高,因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程
* 缺点：处于等待队列中的线程可能会饿死

synchronized是非公平锁，ReentranLock默认是非公平锁，但可以通过构造函数设置True使用公平锁

>ReentranLock是怎么实现的

文章： https://juejin.cn/post/6844903805683761165 （继续背1）

ReentranLock是基于 AQS来实现的。 是一个重入锁：一个线程获得了锁之后仍然可以反复的加锁，不会出现自己阻塞自己的情况。

AQS内部实现了两个队列，分别是同步队列和条件队列。其中同步队列是一个双向链表，里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而条件队列是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，AQS所做的就是管理这两个队列里面线程之间的等待状态-唤醒的工作。

NonFairSync（非公平锁）

1.先获取state值，若为0，意味着此时没有线程获取到资源，CAS将其设置为1，设置成功则代表获取到排他锁了；

2.若state大于0，肯定有线程已经抢占到资源了，此时再去判断是否就是自己抢占的，是的话，state累加，返回true，重入成功，state的值即是线程重入的次数；

3.其他情况，则获取锁失败。

FairSync（公平锁）

可以看到，公平锁的大致逻辑与非公平锁是一致的，不同的地方在于有了!hasQueuedPredecessors()这个判断逻辑，即便state为0，也不能贸然直接去获取，要先去看有没有还在排队的线程，若没有，才能尝试去获取，做后面的处理。反之，返回false，获取失败。

##synchronized底层原理是什么 

文章：https://juejin.cn/post/6844903670933356551#comment （继续背2）

Monitor：

每个Java对象都带了一把Monitor锁，Monitor可以理解为一个同步工具。

每个对象都存在着一个monitor与之关联，monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机中，monitor是由ObjectMonitor实现的。

ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装成ObjectWaiter对象)，owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入EntryList 集合，当线程获取到对象的monitor 后进入Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)


![monitor原理.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/monitor%E5%8E%9F%E7%90%86.png?raw=true)


原理：

同步代码块

Synchronized经过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。当执行monitorenter指令时，当前线程将试图获取对象锁所对应的 monitor 的持有权，若对象锁的Monitor的计数器是0，那线程可以成功取得monitor，并将计数器值设置为1，取锁成功。如果当前线程已经拥有对象锁的 monitor 的持有权，那它可以重入这个 monitor，重入时计数器的值也会加 1。倘若其他线程已经拥有对象锁的 monitor的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。

> 静态方法与普通方法加synchronized有什么区别 

普通方法是对调用该方法的对象加锁，锁是对象的this实例，静态方法是对该方法所在的类加锁,锁是对象的class实例

> synchronized能不能继承？

父类方法中有synchronized关键字修饰，子类继承该父类的方法也有Synchronizde关键字的效果，但是如果重写该方法时不显式加上synchronized关键字时则不会有效果

> 非静态方法A和B在同一个类中，方法A用synchronized修饰，当A方法因为多线程请求有线程阻塞在对象锁上的时候，B方法的访问受不受影响？

B方法若是普通方法，不受影响，若是synchronized修饰，也是获取对象锁的话，则会同样阻塞，等待A执行完才能执行，B若是用的类锁，也不影响

> 锁的释放和获取的内存语义

- 当线程释放锁时，JVM会把线程对应的本地内存中的共享变量刷新到主内存中。
- 当线程获取锁时，JVM会把该线程对应的本地内存置为无效。从而可以使得被监视器保护的临界区代码必须从主内存中读取共享变量。

##volatile字段有什么用途？

> 作用

1. 保证内存可见性
2. 禁止指令重排
   指令重排序是JVM为了优化指令、提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。指令重排序包括编译器重排序和运行时重排序。
   在JDK1.5之后，可以使用volatile变量禁止指令重排序。针对volatile修饰的变量，在读写操作指令前后会插入内存屏障

> synchronized和volatile的区别

volatile保证修饰的变量在多个线程中数据一致的效果，需从主存中读取；synchronized则是通过加锁的方式，只有当前线程可以访问该变量，其它线程被阻塞住。
区别

1. volatile 仅能使用在变量级别；synchronized则可以使用在方法和代码块。

2. volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性。

3. volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。

4. volatile 标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。

> volatitle原理

被volatile修饰的共享变量进行写操作时候会多出Lock前缀的指令，该指令在多核处理器下会引发两件事情。
1.将当前处理器缓存行的数据写回到系统内存
2.这个写回主内存的操作会使其他CPU缓存的该共享变量内存地址的数据无效。

这样就保证了多个处理器的缓存是一致的，对应的处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器缓存行设置无效状态，当处理器对这个数据进行修改操作的时候会重新从主内存中把数据读取到缓存里。

> 由于volatile修饰的变量在各个线程里都是一致的，所以基于volatile变量的运算在多线程并发的情况下是安全的?

这句话的前半部分是对的，后半部分却错了，因为它忘记考虑变量的操作是否具有原子性这一问题（指一个操作是不可中断的，要么全部执行成功要么全部执行失败）

在不符合以下场景下我们依然需要通过加锁来保证原子性：

- 运算结果并不依赖变量当前的值，或者只有单一线程修改变量的值。（要么结果不依赖当前值，要么操作是原子性的，要么只要一个线程修改变量的值）
- 变量不需要与其他状态变量共同参与不变约束 比方说我们会在线程里加个boolean变量，来判断线程是否停止，这种情况就非常适合使用volatile。

> 并发三大特性

- 原子性

一个操作或者多个操作，要么全部执行成功，要么全部执行失败。满足原子性的操作，中途不可被中断。

- 可见性

多个线程共同访问共享变量时，某个线程修改了此变量，其他线程能立即看到修改后的值。

- 有序性

程序执行的顺序按照代码的先后顺序执行。

# 多进程 OK

## Android多进程导致的问题

1. 采用多进程方式，Application onCreate 方法会执行多次。
   1. 判断当前进程是主进程才执行初始化代码
2. 进程间通信

> SP使用多进程的问题

SharedPreferences不支持多个进程同时写，会有一定的几率丢失数据

> 为什么使用多进程

1. 分担主进程的内存压力，并且获取更大的内存空间
2. 防止进程被杀死

#HashMap的原理 ok 

hashmap内部结构是由在数组+链表实现的，其中数组是Node[]数组，存放的是key-value键值对的节点，默认初始长度是16，当链表大于8并且数组长度大于 64 时，链表结构会转换成红黑树结构。之所以添加红黑树是因为一旦链表过长，会严重影响 HashMap 的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题，hashmap key,value均可为null(TreeMap不支持null键，但是支持null值)

为啥有个64：为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表而导致不必要的转化

然后再说一下hashmap的方法实现

* put：先判断数组是否为空，为空的话扩容，不为空根据(n - 1) & key.hash的哈希值计算出要插入的数组索引 i，如果 table[i] 等于 null，则直接插入，不为空判断key和hash是否相等，相等就覆盖，不相等就查看table[i]是否是红黑树节点，如果是的话就用红黑树直接插入，如果不是就遍历链表，遇到重复元素就覆盖，否则直接插入，如果链表长度大于8，转为红黑树结构，执行完成后看元素个数是否大于阈值threshold，大于就扩容，否则直接结束
* get：首先判断数组是否为null，不为空，计算出数组索引i，判断table[i] key和hash是否相等，是返回，不是则看下一个节点，如果是树结构，则使用 getTreeNode 直接获取相应的数据，非树结构，循环节点判断，hash 相等并且 key 相同，则返回此节点

> 为什么不直接使用红黑树，而是要先使用链表实在不行再转红黑树呢

因为树节点所占的空间是链表节点的两倍，尽管转为树使得查找的速度更快（红黑树的查找效率为o(logN)，要优于链表的o(N)），但是在节点数比较少的时候，此时对于**红黑树来说内存上的劣势会超过查找等操作的优势**，自然使用链表更加好，但是在节点数比较多的时候，综合考虑，红黑树比链表要好。

> 扩容机制

什么时候发生扩容？

1. 当put时hash表为空，会发生一次。
2. 添加元素时，当元素个数>表长度*加载因子时也会扩容
3. 在链表长度>8，数组长度<64时也会发生扩容

扩容过程中是数据是整体复制么？

​	不是

hashmap的扩容中主要进行两步：

1. 把数组长度变为原来的两倍  
2. 新数组赋值时，元素的链表只有一个，则直接进行赋值，元素是红黑树，则split直接插入，元素是链表时。插入时不用重新计算hash，通过高位运算看高一位是0还是1，如果是1这个元素在新数组中的位置，是原下标+原数组长度，如果是零位置不发生变化，还是原下标。

> 是怎么解决Hash冲突的

当hash值相同，需要放到同一个位置就会发生冲突。

hashmap采用链表法来解决hash冲突：链表法就是将相同下标的对象组织成一个链表放在对应的位置

> 加载因子

加载因子用来判断什么时候进行扩容的，假如加载因子是 0.5，HashMap的初始化容量是 16，那么当 HashMap 中有 16*0.5=8个元素时，HashMap 就会进行扩容

那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？

这其实是出于容量和性能之间平衡的结果：

1.当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此底层红黑树就会变得异常复杂，这样对元素的操作时间就会增加

2.当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，但是空间就会变大

为了提升扩容效率，HashMap的容量有一个固定的要求，那就是一定是2的幂，所以，如果负载因子是3/4的话，那么和capacity的乘积结果就可以是一个整数

所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子

> hash方法细节

 key.hashCode() ^ (h >>> 16)

> 链表转红黑树的阈值为何是8,红黑树转链表的限制为何是6

在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为8的时候，概率仅为0.00000006。这是一个小于千万分之一的概率，作者应该是根据概率统计而选择了8作为阀值。通常情况下，并不会发生从链表向红黑树的转换。
链表长度超过 8 就转为红黑树的设计，更多的是为了防止用户自己实现了不好的哈希算法时导致链表过长，从而导致查询效率低，而此时转为红黑树更多的是一种保底策略，用来保证极端情况下查询的效率。
通常如果 hash 算法正常的话，那么链表的长度也不会很长，那么红黑树也不会带来明显的查询时间上的优势，反而会增加空间负担。所以通常情况下，并没有必要转为红黑树，所以就选择了概率非常小，小于千万分之一概率，也就是长度为 8 的概率，把长度 8 作为转化的默认阈值。

> hashmap大小为什么是2的幂次方

HashMap的长度为2的幂次方的原因是为了减少Hash碰撞，尽量使Hash算法的结果均匀分布。

> 为什么不直接使用 key 而要使用 key 的 hash 值？

答：考虑到效率问题如果直接使用 key，那么在查找的时候需要调用 key 的 equals() 方法去逐个比较，时间复杂度从原本的 O(1) 变成了 O(n) ，且 equals() 比较的效率也很低，而通过 hash 值可以直接定位到桶。

> 那为什么又不直接用 hash 值作为数组上的索引？

答：为了防止数组下标越界，因为 hash 值不确定性，很容易越界。

> 索引为什么用的是 (n - 1) & hash，而不是 hash % n 呐？

答：其实早期版本就是用 hash % n，但是为了追求效率，后来就改成了位运算 (n - 1) & hash， 当 n 为 2 的指数，(n - 1) & hash 与 hash % n是等价的

> HashMap为啥线程不安全

当有多个线程共同操作hashMap的put方法时，这个时候hashMap容量不够了，两个线程都去扩容执行resize方法，在这个时候cpu切换资源的话，会造成链表成环问题，死循环问题。

http://www.louisvv.com/archives/2487.html 

https://juejin.cn/post/6844903744711163911#comment

##HashMap ArrayMap SparseArray的区别

ArrayMap内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找也会使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作，如果在数据量比较大的情况下，那么它的性能将退化至少50%。

SparseArray 存储整型类型的 key，它比HashMap 更省内存,某些条件下 性能更好,主要是因为它避免了对key的自动装箱。ArrayMap 与 SparseArray最大的一点不同就是 ArrayMap的key可以为任意的类型。而SparseAraay的key只能是整型。

> 区别

1. 内部数据结构不一样，，一个是数组+链表，一个是两个数组
2. 占用内存不一样，arrayMap占用内存更低
3. 扩容机制不一样：
   1. 首先数组的容量会扩充到BASE_SIZE，如果BASE_SIZE无法容纳，则扩大到2 * BASE_SIZE，如果2 * BASE_SIZE仍然无法容纳，则每次扩容为当前容量的1.5倍

> HashMap 与 SparseArray比较

当数据量 少于500时,使用SparseArray ，要优于HashMap。

> SparseArray 与 ArrayMap使用场景：

- 当 key为整型时,推荐使用SparseArray
- 当 key为其它类型时,推荐使用ArrayMap

## Android里面的LRUCache是如何实现的

近期最少使用算法，它的核心思想就是会优先淘汰那些近期最少使用的缓存对象

LruCache使用了LinkedHashMap 双向链表来实现，总缓存的大小一般是可用内存的 1/8，当超过总缓存大小会删除最少使用的元素，也就是内部 LinkedHashMap 的头部元素。当使用get()访问元素后，会将该元素移动到 LinkedHashMap 的尾部

> 怎么自己实现一个

缓存策略分为添加、获取和删除

#泛型 Ok

##有什么优点？

1. 在编码期保证类型安全性
   1. list<integer> arraylist 一个只能存放int,一个啥都可以存，编译的时候不会报错
2. 避免了手动强制转换
3. 代码观看清晰条理

##泛型擦除，为何会有擦除？擦除的时机。通配符

泛型信息在编译后，进入JVM之前擦除

在类型擦除的时候，如果泛型类里的类型参数没有指定上限，则会被转成Object类型，如果指定了上限，则会被传转换成对应的类型上限。最后又通过强制转化来进行一个转变

https://juejin.cn/post/6844904083199918093#comment

> 为什么会有泛型擦除？

当运行时jvm不识别泛型，所以有了擦除机制

> 带来的问题

1. 强制类型转换
2. 因为转成了object,所以可以通过反射，在一个List<Integer>中在不知情的情况下插入了一个String类型的数值

> 通配符

通配符的出现是为了指定泛型中的类型范围
通配符有 3 种形式：

```
<?>被称作无限定的通配符。
<? extends T>被称作有上限的通配符。
<? super T>被称作有下限的通配符。
```

> Kotlin 泛型

协变：如果A是B的子类型，那么Generic<A>也是Generic<B>的子类，这就是协变。out = <? extends T> 

​	被其修饰的泛型只能作为生产者输出，而不能作为消费者输入。所以'out'修饰的泛型常常作为方法的返回而使用

逆变：如果A是B的子类型，反过来Generic<B>是Generic<A>的子类型，我们称这种关系为逆变。in = <? super T>

​	in修饰的泛型只能作为输入类型，而不能作为返回类型

## 反射可以反射final修饰的字段吗

可以。被final修饰的变量，只是说栈存储的地址不能再改变，但是却没有说地址指向的内容不能改变，所以反射可以破final，因为它修改该了以前地址的具体内容，但是没有改地址的信息。

然后被static修饰的变量也能修改，同样道理，只不过第一个参数为null，但是同时被final和static变量修饰的就不能被修改了，会抛出异常。这种可以通过反射去掉final来修改

# JVM类加载机制&垃圾回收 Ok

## JVM类加载机制了解吗，类什么时候会被加载？类加载的过程具体生命周期是怎样的？

> 类加载机制

JVM把Class文件中的类数据加载到内存，并对数据进行校验解析初始化，最终形成可以被JVM直接使用的过程就是类加载机制

object o =new object() 主要包括三个阶段：

1. 通过类加载器加载，
2. 当类被加载之后，进行验证，包括：文件格式验证，元数据验证，字节码验证，符号引用验证；
3. 为类的静态变量分配内存；

> 什么时候被加载

Java虚拟机没有明确规定一个类在什么时候会被加载，但是它严格规定了只有以下情况必须对类进行初始化操作，在初始化操作之前必定会触发类的加载和连接

1. 遇到`new`、`getstatic`、`putstatic`、`invokestatic`这四条字节码指令时
   1. 使用`new`关键字实例化对象时；对应`new`字节码指令
   2. 读取或设置一个类的静态字段（被`final`修饰的、在编译期把结果放入常量池的静态变量除外）时；对应`getstatic`和`putstatic`字节码指令
   3. 调用一个类的静态方法时；对应`invokestatic`字节码指令
2. 使用`java.lang.reflect`包的方法第一次对类进行反射调用时会触发类的初始化

> 生命周期

Java类从加载到内存到移除，它的整个生命周期分为： https://blog.csdn.net/zhangliangzi/article/details/51319033

1. 加载：通过全路径名加载Class文件到内存
2. 验证：验证被加载后的类是否有正确的结构
3. 准备：为类的静态变量在方法区分配内存，并初始赋值（对于一般的成员变量是在类实例化时候，随对象一起分配在堆内存中。）
4. 解析：将类的二进制数据中的符号引用换成直接引用
5. 初始化：为静态变量赋程序设定的初值
6. 使用：对象实例化
7. 卸载：GC

> DexClassLoader与PathClassLoader的区别

1. DexClassLoader可以加载任意目录下dex/jar/apk/zip文件，一般用于热修复
2. PathClassLoader只能加载系统中已经安装过的apk(data/app目录),是Android默认使用的类加载器。

源码：https://www.jianshu.com/p/7e30ba5cb9ea

> 热修复原理

类加载器在加载一个类时会先从自身DexPathList对象中的Element数组中获取到对应的类，再加载。采用的是数组遍历的方式，不过注意，遍历出来的是一个个的dex文件。在for循环中，首先遍历出来的是dex文件，然后再是从dex文件中获取class，所以，我们只要让修复好的class打包成一个dex文件，放于Element数组的第一个元素，这样就能保证获取到的class是最新修复好的class了（当然，有bug的class也是存在的，不过是放在了Element数组的最后一个元素中，所以没有机会被拿到而已

将补丁dex文件放到dexElements数组靠前位置，这样在加载class时，优先找到补丁包中的dex文件，加载到class之后就不再寻找，从而原来的 apk 文件中同名的类就不会再使用，从而达到修复的目的

##垃圾回收机制与jvm结构，老年代算法，方法区有啥，GCRoot都有啥 

    这篇文章写得挺好挺全的  https://juejin.im/post/6844903905457864718

>jvm内存结构

![Jvm内存结构.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/Jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png?raw=true)

* PC、虚拟机栈，本地方法栈是线程私有区域，其生命周期和线程相同；方法区和堆是线程共享区域，生命周期跟虚拟机相同，
* 除pc之外，别的区域都有可能造成OOM

1. 程序计数器 :指向当前线程所执行的字节码的行号
2. 虚拟机栈：主要描述方法执行，每个方法在执行的时候创建一个栈帧，其中栈帧中存储了函数中定义的基本数据类型变量以及对象的引用变量(局部变量表，操作数栈，动态链接，方法出口等信息)。每一个方法从调用到执行结束，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
3. 本地方法栈：虚拟机栈执行java方法；本地方法栈执行native方法。比如java中调用C或C++中的方法，在这里执行。
4. 堆：创建的对象与数组都保存在java堆内存中，因为是线程共享，所以与方法区两个是垃圾收集的区域，java堆中从GC的角度细分为：新生区与老年区。
5. 方法区：**用于存储被jvm加载的类信息、常量、静态变量、编译器编译后的代码等数据**
   1. 实现类似堆的永久代实现，GC算法也一样，GC主要用于常量池和无用的类的回收
   2. Class文件包括 1.类信息包括类的版本，字段，方法，接口等描述信息 2.常量池

> 如何判断一个对象需要被回收

不再使用的对象需要进行回收，不使用的类也有可能回收。

通过两个方法来判断对象不再被使用：

1. 引用计数法: 给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减一；任何时刻计数器为0的对象就是不会被使用的对象。

2. GC root: 以GC Root的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GC Roots没有任何引用链相连的时候，就证明此对象是不可用的

>可以作为GC root对象包括：

* 虚拟机栈（栈帧中的本地变量表）中的引用对象。
* 方法区中的静态属性或常量（final）引用的对象。
* 本地方法栈中Native方法引用的对象。

>垃圾回收机制

垃圾回收机制采用的是分代收集。根据根据对象存活的不同年龄划分不同的域。新生代：老年代=1：2

* 新生代：复制算法
  * 新生代分为Eden和两块Survivor,比例为8：1：1，每次使用Eden和其中一块Survivor空间，当进行回收时，将两块空间中还存活的对象复制到另一块Survivor空间中。如果存活的某对象的空间>Survivor空间，则将对象移到老年代
  * GC触发条件：当要申请的空间>Eden和其中一块Survivor剩余的空间时，会发生GC
  * 当对象在Survivor躲过一次GC，其年龄会+1，默认情况下当年龄到达15时，会被移到老年代
  * 因为新生代对象的特点是生命周期短，存活率低，所以采用复制算法。一般的复制算法每次只能使用一半的空间，这个是全部空间
* 老年代：标记整理算法和标记清除算法
  * GC触发条件：
    * 显式调用System.gc()方法
    * 老年代空间不足
    * 从新生代进入老年代的空间大于老年代空闲空间

垃圾回收算法：

1. 标记-清除算法：首先标记出存活的对象，在标记完成后会对未标记的对象进行回收   
   1. 缺点：碎片多；虚拟机在给内存较大对象分配空间时，有可能找不到足够大的连续空间存放，从而引发垃圾回收动作。实际上有大量空闲空间，只是不连续；
2. 复制算法：将内存分为两块大小一样的区域，每次是使用其中的一块。当这块内存块用完了，就将这块内存中还存活的对象复制到另一块内存中，然后清空这块内存。
   1. 可用内存小
3. 标记-整理算法：标记过程与标记-清除算法一样，接下来让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
   1. 仍需要进行局部对象移动，一定程度上降低了效率

# 内存泄漏 Ok

> 什么时候会发生内存泄漏

- 单例/静态变量造成的内存泄漏
- 匿名内部类/非静态内部类
- 资源未关闭造成的内存泄漏

> 如何分析解决

https://juejin.cn/post/6844903876043210759#heading-8

使用库，比较出名的就是`LeakCanary`，导入库，然后运行后，就可以发现app内的内存泄漏情况。 文件名称：.hprof

1.5.4 不监测 Fragment 的泄露的。而 2.0版本提供了对Android O以及androidx版本中的 Fragment 的内存泄露检测，并且2.0用了kotlin重写，新版本不用手动初始化。

原理： 被GC回收的对象引用，会保存在队列 `queue` 中 

在一个Activity执行完onDestroy()之后，将它放入WeakReference中，然后将这个WeakReference类型的Activity对象与ReferenceQueque关联。这时再从ReferenceQueque中查看是否有该对象，如果没有，执行gc，再次查看，还是没有的话则判断发生内存泄露了。最后用HAHA这个开源库去分析dump之后的heap内存。

为啥还要进行一次gc:

可能存在被观察的引用将要变得弱可达，但是还未入队引用队列的情况。这时候应该主动调用一次 GC，可能可以避免一次额外的 heap dump

#编译期注解处理的是字节码还是java文件 Ok

应该是处理的Java文件，然后生成字节码

APT即为Annotation Processing Tool，它是javac的一个工具，中文意思为编译时注解处理器。APT可以用来在编译时扫描和处理注解。通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来自动的生成一些代码，省去了手动编写。注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。APT的核心是AbstractProcessor类。

ButterKnife，eventbus都使用了APT技术

#设计模式 Ok

##你在项目中有用到什么设计模式吗

> 单例

工具类封装、GlideEnger

```
懒汉：
public class Singleton {
    private volatile static Singleton instance = null;

    private Singleton() {
    }
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
饿汉：
public class Singleton2 {

    private static final Singleton2 instance = new Singleton2();

    private Singleton2() {
    }

    public static Singleton2 getInstance() {
        return instance;
    }
}

静态内部类 延迟加载，线程安全
public class Singleton {  
    private static class SingletonHolder {  
    	private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    	return SingletonHolder.INSTANCE;  
    }  
}
原理：采用的类装载的机制保证初始化实例只有一个线程。
	静态内部类在外部类被装载时并不会立即实例化，而是在需要实例化时，才会实例化。
    类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证线程的安全性，在类进行初始化时，别的线程是无法进入的。
静态内部类的缺点
	静态内部类也有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如Context这种参数，所以，我们创建单例时，可以在静态内部类与DCL模式（双重锁懒汉模式(Double Check Lock)） 里自己斟酌
```

单例模式有什么缺点？

优点： 
  1.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例 
  2.由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。 
缺点： 
  1.不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 
  2.由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 

> 模版方法模式：定义一套固定步骤，方便直接执行

BaseActivity

> build建造者模式

##android中用到的观察者模式有哪些地方

定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新

eg:ListView/RecyclerView的Adapter的notifyDataSetChanged方法、广播

在setAdapter的时候，生成一个`AdapterDataSetObserver`，紧接着就是订阅上该观察者，该观察者`onChange`方法里面有`requestLayout`方法，该方法是触发UI发生变化的方法。在`BaseAdapter`里面可以看到`notifyDataSetChanged`实际上触发的是`DataSetObservable`被观察者的`notifyChanged`方法，`notifyChanged`会触发`AdapterDataSetObserver`的`onChange`方法。所以最终会走listView的`requestLayout`，最后刷新了UI。

## 动画里面用到了什么设计模式

策略模式：将一系列的算法封装起来，方便替换，实例：动画的插值器

##代理模式与装饰模式的区别，手写一个静态代理，一个动态代理,动态代理有什么用

>代理模式:

静态代理在编译时就已生成，动态代理是在运行时动态生成的


1. 静态代理

这种代理方式需要代理对象和目标对象实现一样的接口。

优点：可以在不修改目标对象的前提下扩展目标对象的功能：

缺点：1.会产生过多的代理类 2.一旦接口增加方法，目标对象和代理对象都要修改

代码：

    //目标对象
    class RealTest implements ITest {
        @Override
        public void doSomthing() {
            System.out.print("原生方法");
        }
    }
    
    interface ITest {
        public void doSomthing();
    }
    //代理对象
    class TestProxy implements ITest {
        private ITest iTest;
    
        public TestProxy(ITest iTest) {
            this.iTest = iTest;
        }
    
        @Override
        public void doSomthing() {
            System.out.println("额外操作");
            iTest.doSomthing();
        }
    }

2.动态代理

动态代理对象不需要实现接口，但是目标对象必须实现接口。其实动态代理与静态代理的本质一样，最终程序运行时都需要生成一个代理对象实例，通过它来完成相关增强以及业务逻辑，只不过静态代理需要硬编码的方式指定，而动态代理则是以动态方式生成代理(编译时操作字节码以及运行时通过反射方式)。动态生成的好处很明显，代理逻辑与业务逻辑是互相独立的，没有耦合，代理1个类100个类没有任何区别

代码：

	//目标对象
	class RealSubject implements ISubject {
	    public void doSomething() {
	        System.out.println("call doSomething()");
	    }
	}
	
	class ProxyFactory{
	    private Object target;
	
	    public ProxyFactory(Object object) {
	        this.target = object;
	    }
	
	    //为目标对象生成代理对象
	    public Object getProxyInstance(){
	        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {
	            @Override
	            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
	                System.out.println("开启事务");
	                Object invoke = method.invoke(target, args);
	                System.out.println("关闭");
	                return invoke;
	            }
	        });
	    }
	}
	
	class TestProxy {
	    public static void main(String args[]) {
	        ISubject target = new RealSubject();
	        ISubject proxyInstance = (ISubject) new ProxyFactory(target).getProxyInstance();
	        proxyInstance.doSomething();
	    }
	}

3.CGLib代理

使用动态代理必须实现接口，使用CGLib代理对象则无需实现接口

>代理模式与装饰模式的区别

装饰模式和静态代理代码基本是一样的。

代理模式，侧重于不能直接访问一个对象，只能通过代理来间接访问。装饰器模式是因为没法在编译就确定一个对象的功能，需要运行时动态的给对象添加职责，所以只能把对象的功能拆成一一个个的小部分，动态组装。因为这些功能是由使用者动态配置的。但是代理模式在编译器其实就已经确定了和代理对象的关系。   

这个两个设计模式是为了解决不同的问题而抽象总结出来的。是可以混用的。可以在代理的基础上在加一个装饰，也可以在装饰器的基础上在加一个代理。

# 软引用、弱引用、强引用、虚引用的区别 Ok

* 强引用:直接new出来的对象;强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象

  ```
  String str = new String(“yc”);
  ```

* 软引用 ：如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。

  ```
  MyObject aRef = new  MyObject();
  SoftReference aSoftRef = new SoftReference(aRef);
  MyObject anotherRef = (MyObject)aSoftRef.get();
  ```

  可用来处理图片这种占用内存大的情况

* 弱引用：在垃圾回收器扫描的过程中，一旦发现了弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。场景？  

  * 防止内存泄漏
  * 使用频率高的用软引用，使用频率低的用弱引用

* 虚引用：虚引用随时都可能被垃圾回收器回收。

---

#activity ok

##Activity与AppCompactActivity区别，Activity会打包到包里面去吗？

1. 主界面带有toolbar的标题栏 
2. theme主题只能用android:theme=@style/AppTheme （appTheme主题或者其子类），而不能用android:style。 否则会提示错误

会

## Activity生命周期

- A启动B的，然后按back键，执行了哪些方法？按home键呢？

> 从ActivityA 启动 ActivityB的生命周期： A.onCreate —> A.onStart —> A.onResume —>A.onPause —>B.onCreate —> B.onStart —> B.onResume—> A.onStop
>
> 按下Back键: B.onPause —>A.onRestart—>A.onStart —> A.onResume -->B.onStop -- >B.onDestroy
>
> 按下Home键: B.onPause -->B.onStop —> OnSaveInstanceState 

- onSaveInstance方法调用时机

> 1、当用户按下HOME键时。 
>
> 2、按任务栏键，选择运行其他的程序时。 
>
> 3、按下电源按键时。 
>
> 4、从activity A中启动一个新的activity时。 
>
> 5、屏幕方向切换时，例如从竖屏切换到横屏时。

##Fragment hide show生命周期变化、replace生命周期变化

Fragment调用show和hide时不会调用Fragment相应生命周期方法，而会调用onHiddenChanged，true隐藏，false显示

replace会重新创建：

```
Fragment2 onAttach
Fragment2 onCreate
Fragment1 onPause
Fragment1 onStop
Fragment1 onDestoryView
Fragment1 onDestory
Fragment2 onCreateView
Fragment2 onActivityCreated
Fragment2 onStart
Fragment2 onResume
```

##启动模式 

> Activity一共有以下四种launchMode：

1. standard 标准启动模式

   * 默认的启动模式，每次启动activity都会创建新的实例。
2. singletop 栈顶复用模式  适合接收通知启动的内容显示页面
   * 当栈顶有将要开启的Activity时，会复用这个Activity，同时这个activity的onNewIntent方法会被回调。这个activity的onCreate方法不会被调用，因为它没有发生改变。若是栈顶没有，那么就会重新创建
   * 应用场景：适用于接收到消息后显示的界面。例如：QQ接收到消息后会弹出activity，但如果一次来10条消息，总不能一次弹出10个activity。  

3. singetask栈内复用模式，在当前任务栈里面只能有一个实例存在 适合作为程序入口点

   * 当一个启动模式为singleTask的activityA请求启动后，系统会先寻找是否存在A想要的任务栈（在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在），如果不存在，就重新创建一个任务栈，然后创建A的实例并将A放到栈中。如果存在A所需的任务栈，这时要看栈中有是否有要开启的activityA，如果有则直接复用并删除A上面的activity，将A移动到栈顶，同singletop一样，也会回调这个activity的onNewIntent方法。如果没有实例，则创建A实例并压入栈中

   * 现在有两个任务栈，前台任务栈中有BA，后台任务栈中有DC，假设DC启动启动模式都为singleTask。现在请求启动D，那么整个后台任务栈都会被切到前台，这时候前台任务栈为DCBA，当按back键时，前台栈中activity会一一出栈；如果请求启动C，那么情况就不一样了，会把D删除,C切换到前台。（具体看图——singleTask启动模式特例.pptx）
   * 所以这种启动模式通常可以用来退出整个应用程序。将主activity设为singleTask,然后在要退出的activity中转到主Activity，从而将主Activity上的其他activity全部清除，然后在主Activity中的onNewIntent()中加上finish(),将最后一个activity结束。

4. singleInstance 单实例模式

   * activity会开启一个新的任务栈，并且这个任务栈里面只有一个实例存在。
   * 这种启动模式和浏览器的工作原理类似。当多个程序访问浏览器时，如果浏览器没有打开，则打开浏览器，否则会在当前打开的浏览器中访问。举个例子来说，当应用A的任务栈创建了ActivityA实例，并且其启动模式为sinleInstance，如果应用B也要激活ActivityA，则不需要创建，两个应用共享即可。  
   * 如果你要保证一个activity在整个手机操作系统里面只有一个实例存在，使用singleInstance
   * 关于singleInstance这种启动模式还有一点需要特殊说明:如果在一个singleInstance的activityA中通过startActivityForResult()去启动另一个activityB，那么在A中拿不到数据。因为android不允许task间互相传递数据。
   * 以singleInstance模式启动的Activity在整个系统中是单例的，如果再启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。
   * singleInstance模式的Activity开启的其他activity，新Activity会存放到已有的任务栈中(如果没设置新的任务栈的话)。不跟这个在一个

> onNewIntent()

通过这个方法可以取出当前请求的信息
第一次创建Activity A时，执行的逻辑顺序是：
    onCreate() ­­­>onStart()­­­>onResume()
而如果使用singleTask模式第二次启动Activity A，且A处于任务栈的顶端，则执行的逻辑顺序是：
    onNewIntent() ­­­>onRestart> onStart>onResume()。 
注意，getIntent()仍返回原来的意图。你可以使用setIntent来设置新的意图。

> FLAG

* FLAG_ACTIVITY_SINGLE_TOP：与launchMode = "singleTop"行为一致

* FLAG_ACTIVITY_NEW_TASK：如果设置taskAffinity，系统会查找有没有相应的栈存在，如果存在将Activity压入栈中，如果不存在，将Activity压入默认栈中

* FLAG_ACTIVITY_CLEAR_TOP：如果目标存在，直接复用，并清除目标以上的活动，否则重建。
* FLAG_ACTIVITY_NEW_TASK和FLAG_ACITIVTY_CLEAR_TASK = singleTask

# onCreate,onResume,onStart里面，什么地方可以获得宽高 

如果在`onCreate、onStart、onResume`中直接调用View的`getWidth/getHeight`方法，是无法得到View宽高的正确信息，因为view的measure过程与Activity的生命周期是不同步的，

onCreate创建 DecorView ，onResume添加 DecorView 到 WindowManager，这时候都没有调用View的measure流程，所以视图宽高是获取不到的

有以下三个方法来获取view的宽高：

- view.post()方法

- onWindowFocusChanged() 

  - ```
    当 Activity 获取和失去焦点的时候
    override fun onWindowFocusChanged(hasFocus: Boolean) {  
        super.onWindowFocusChanged(hasFocus)
        if (hasFocus){
            ...
        }
    }
    ```

- OnGlobalLayoutListener

  - ```
    当 View 树发生状态变化时
    view.viewTreeObserver.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener{
        override fun onGlobalLayout() {
            binding.dialog.viewTreeObserver.removeOnGlobalLayoutListener(this)
            ...
        }
    })
    ```

> 为什么获取不到

在onResume时 view 才会被添加在window内并且执行view的测量布局绘制 这就是为什么在onCreate()时获取到view宽高会是0的原因，因为那时view都没有添加进window呢

> View 在什么时间点被测量

WindowManager添加decorView的时候回调ViewRootImpl.setView()，在setView方法中调用requestLayout()发起绘制流程

> 为什么view.post可以获得宽高

根据ViewRootImpl是否已经创建，View.post()会执行不同的逻辑。如果 ViewRootImpl 已经创建，即 mAttachInfo 已经初始化，直接通过 Handler 发送消息来执行任务。如果 ViewRootImpl 未创建，即 View 尚未开始绘制，会将任务保存为 HandlerAction，暂存在队列 HandlerActionQueue 中，等到 View 开始绘制，执行 performTraversal() 方法时，在 dispatchAttachedToWindow() 方法中通过 Handler 分发 HandlerActionQueue 中暂存的任务。

1:View内部的mAttachInfo 会在View的dispatchAttachedToWindow()方法内赋值,mAttachInfo是在ViewRootImpl的构造器内创建的,所以我们就可以知道当view的attchInfo不为空时 这个view是已经被添加进窗口内的,如果为null就说明view没有在window内。
2: 当ViewRootImpl在Activity的onResume()中被创建时，其实主线程的Handler是在执行处理一个Message的流程中，虽然我们从上面ViewRootImpl内的performTraversals()源码中看到 view缓存的runnable会在performMeasure(), performLayout(),performDraw()这些方法前先被post出去并且添加到MessageQueue链表中，但是这些runnable是属于下一个Message的，而performMeasure(), performLayout(),performDraw()这三个方法是属于本次Message的逻辑,只有本次消息处理完成Handler内部的Looper才会进行下一次消息的处理，最终保证了 View.post()能够正确的拿到View的宽高。

文章：https://juejin.cn/post/6895735092438630407#heading-2

# 启动流程 （继续背3）

##说说App的启动过程,在ActivityThread的main方法里面做了什么事，什么时候启动第一个Activity？

https://juejin.cn/post/6844904116561379341#comment

https://juejin.cn/post/6844903954266996744#heading-0

> APP启动流程

1. Launcher进程通过binder机制请求AMS启动Activity
2. 配置Activity的信息
   1. AMS接收到请求后通过ActivityStarter解析Intent和Flag，在通过ActivityStack为Activity配置栈信息。并判断是否需要创建应用进程。
3. 然后AMS通过socket调用到`Zygote`，fork新的app进程
4. 创建应用进程
   1. ZygoteServer接收到AMS的Socket请求，通过ZygoteConnection fork应用进程。fork进程后会返回一个pid，通过判断pid进入到应用进程
5. 应用进程初始化
   1. 通过ActivityThread创建主线程，创建H类，开始Loop循环。并通过Binder向AMS发送绑定Application的请求。
6. 绑定Application
   1. AMS接收到ActivityThread发送的请求后，把Application和进程绑定。最后通过Binder机制请求启动Activity
7. 启动Activity：
   1. ApplicationThread接收到请求后调用ActivityThread#performLaunchActivity来间接调用Activity的onCreate方法

> ActivityThread的Main方法做了什么事情

* 创建主线程 Looper
* 创建主线程H类
* 主线程进入轮询状态

> ActivityThread和ApplicationThread有什么区别 

ApplicationThread是ActivityThread的内部类，ActivityThread与启动Activity有关，那么 ApplicationThread就与启动Application有关   ？ 还有很多

##APP打包经过了哪几个流程

- 打包资源文件，通过AAPT(Android Asset Packaging Tool)打包成R.java类(资源索引表)以及.arsc资源文件。
- 处理AIDL文件，检查app中是否有aidl文件，如果有会通过aidl工具(源码位于system/tools/aidl）打包成java接口类
- 编译R.java源码部分以及aidl.java通过javac生成对应的.class文件。
- 将上面生成的.class文件和第三方jar或者library通过dx工具打包生成dex文件。
- 生成未签名的apk，包括apkbuilder工具将所有没有编译的资源、.arsc资源、.dex文件打包到一个完成apk文件中
- 生成签名的apk，包括jarsigner工具对未签名的apk验证签名。得到一个签名后的apk（signed.apk）
- zipAlign工具对齐上面签名的apk文件。

# Service Ok

> 概念

##intentService

intentService可以异步运行一个任务并在结束时自行终止。需要在一个单独的线程中执行的代码可以放在onHandleIntent()中，如从服务器下载数据，当代码执行完毕，线程被终止，服务自行停止。

是通过HandlerThread来实现耗时操作的

> HandlerThread

`HandlerThread`继承Thread，内置了Handler和Looper，在run方法中创建了looper对象，这也是为什么在IntentService中能在HandlerThread中直接用handler的原因。

# ANR怎么产生?怎么捕捉？

一般来说产生ANR的情况有以下三种：

- Activity的UI在5秒内没有响应输入事件（例如，按键按下，屏幕触摸）–主要类型
- BroadcastReceiver在10秒内没有执行完毕
- Service在特定时间内（20秒内）无法处理完成–小概率类型

通过避免在主线程做太多耗时的操作来优化

> 怎么捕获

当产生ANR的时候系统会生成一个日志文件，日志存放在/data/anr/文件夹下面，一般名称为traces.txt。导出即可查看

# 广播与RxBus的区别，全局广播与局部广播区别 Ok

本地广播：广播事件的发送和接收都在本应用，不能跨进程(APP内部进程也不能跨)，只能动态注册，不能静态注册--使用Handler通信机制

全局广播：广播事件的发送和接收都在本应用可以跨应用，全局广播既可以动态注册，也可以静态注册--采用的binder方式实现跨进程间的通信

广播是四大组件之一，可以直接获取上下文，比较消耗资源，Rxbus不能跨进程，耦合性低，比广播更轻量，书写简便。可实现粘性事件

#attachToWindow什么时候调用？ Ok

attachToWindow在onResume之后调用，onDetachFromWindow() 在onDestory之后被调用

```
MainActivity打开
MainActivity: onCreate
MainActivity: onStart
MainActivity: onResume
MainActivity: onAttachedToWindow
MainActivity: onViewAttachedToWindow(界面View设置的监听)
点击home键
MainActivity: onPause
MainActivity: onStop
恢复展示
MainActivity: onRestart
MainActivity: onStart
MainActivity: onResume
关闭
MainActivity: onPause
MainActivity: onStop
MainActivity: onDestroy
MainActivity: onViewDetachedFromWindow
MainActivity: onDetachedFromWindow
```

#事件分发机制 ok

![事件分发机制.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6.png?raw=true)

View事件分发是对MotionEvent进行分发，最终传递给一个View的过程。view的分发事件是从`父View的dispatchTouchEvent`到`父View的onInterceptTouchEvent`再到`View#dispatchTouchEvent`，然后到view的`onTouchEvent`，最后又回到了`Viewgroup(Parent)#onTouchEvent`

方法解释：

* dispatchTouchEvent：方法返回值为true表示事件被当前视图消费掉；返回为super.dispatchTouchEvent表示继续分发该事件，返回为false表示交给父类的onTouchEvent处理。

* onInterceptTouchEvent：方法返回值为true表示拦截这个事件并交由自身的onTouchEvent方法进行消费；返回false表示不拦截，需要继续传递给子视图的dispatchTouchEvent。如果return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: 　
  * 1.如果该View存在子View且点击到了该子View, 则不拦截, 继续分发给子View 处理, 此时相当于return false。
  * 2.如果该View没有子View或者有子View但是没有点击中子View(此时ViewGroup 相当于普通View), 则交由该View的onTouchEvent响应，此时相当于return true。 

* onTouchEvent：方法返回值为true表示当前视图可以处理对应的事件；返回值为false表示当前视图不处理这个事件，它会被传递给父视图的onTouchEvent方法进行处理。如果return super.onTouchEvent(ev)，事件处理分为两种情况：
  * 1.如果该View是clickable或者longclickable的,则会返回true, 表示消费了该事件, 与返回true一样;
  * 2.如果该View不是clickable或者longclickable的,则会返回false, 表示不消费该事件,将会向上传递,与返回false一样。

注意：在Android系统中，拥有事件传递处理能力的类有以下三种：

- Activity/View：拥有分发和消费两个方法。
- ViewGroup：拥有分发、拦截和消费三个方法。

一些重要的结论：

1、事件传递优先级：onTouchListener.onTouch > onTouchEvent > onClickListener.onClick。

2、正常情况下，一个事件序列只能被一个View拦截且消耗。因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不会再调用这个View的拦截方法去询问它是否要拦截了，而是把剩余的ACTION_MOVE、ACTION_DOWN等事件直接交给它来处理）。

4、ViewGroup默认不拦截任何事件（返回false）。

5、View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable默认为false。

6、View的enable属性不影响onTouchEvent的默认返回值。

7、通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。

> 高深:

TouchTarget是对消耗事件的View以链表方式保存，且记录各个View对应的触控点列表，以实现后续的事件派分处理。TouchTarget是一个链表结构，来解决多点触控问题

```
最开始 mFirstouchTarget =null
当手指1按下时候 创建 target1    target1.next=null    mFirstouchTarget = target1
当手指2按下时候，创建 target2    target2.next= target1    mFirstouchTarget = target2
当手指3按下时候，创建 target3    target3.next= target2    mFirstouchTarget = target3
当手指4按下时候，因为没点到任何子view 所以不会创建 target   mFirstouchTarget = target3
mFirstouchTarget =  target3 →target2→target1→null  
```

1. 非多点触控：`mFirstTouchTarget`链表退化成单个`TouchTarget`对象。

2. 多点触控，目标相同：同样为单个`TouchTarget`对象，只是`pointerIdBits`保存了多个`pointerId`信息。

3. 多点触控，目标不同：`mFirstTouchTarget`成为链表。

android事件分发核心是在`viewgroup`的`dispatchTouchEvent`分发`action_down`过程中找到`mFirstTouchTarget`是否为空，如果`mFirstTouchTarget`不为空，那么`action_move`和`action_up`才会往下传递，如果在`action_move`和`action_up`过程中有viewgroup拦截了事件，则此时先向子view的`dispatchTouchEvent`传递一个`action_cancel`，并且将`mFirstTouchTarget`至为null，所以此时`action_move`和`action_up`只会走`viewgroup`的`dispatchTouchEvent`和`onTouchEvent`；如果`mFirstTouchTarget`在`action_down`过程中就已经null的话，则从`action_down`一直向上层view传递，不会有后续的`action_move`和`action_up`了。

> ViewGroup在Action_Move时onIntercept返回true，事件怎么传递?

先向子view的`dispatchTouchEvent`传递一个`action_cancel`，并且将`mFirstTouchTarget`至为null，所以此时`action_move`和`action_up`只会走`viewgroup`的`dispatchTouchEvent`和`onTouchEvent`

> 手势操作ActionCancel后怎么取消 

- 一般ACTION_CANCEL和ACTION_UP都作为View一段事件处理的结束。如果在父View中拦截ACTION_UP或ACTION_MOVE，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到ACTION_CANCEL事件。
- 如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现action_cancel。

> 点击事件被拦截，但是想传到下面的View，如何操作？

重写子类的requestDisallowInterceptTouchEvent()方法返回true就不会执行父类的onInterceptTouchEvent()，即可将点击事件传到下面的View。

> 如何解决View的事件冲突？举个开发中遇到的例子？

常见开发中事件冲突的有ScrollView与RecyclerView的滑动冲突、RecyclerView内嵌同时滑动同一方向。

滑动冲突的处理规则：

- 对于由于外部滑动和内部滑动方向不一致导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件。
- 对于由于外部滑动方向和内部滑动方向一致导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件，何时由内部View拦截事件。
- 对于上面两种情况的嵌套，相对复杂，可同样根据需求在业务上找到突破点。

滑动冲突的解决方法：

- 外部拦截法：指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。具体方法：需要重写父容器的onInterceptTouchEvent方法，在内部做出相应的拦截。
- 内部拦截法：指父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法：需要配合requestDisallowInterceptTouchEvent方法。

> 实现一个不能滑动的ViewPager

onInterceptTouchEvent()方法和onTouchEvent()方法，只需要将返回值改为false，那么ViewPager就不会消耗掉手指滑动的事件了

##setOnTouchListener,onClickeListener和onTouchEvent的关系 

setOnTouchListener-onTouch
onClickeListener-onClick

onTouch在dispatchTouchEvent()方法中调用

    public boolean dispatchTouchEvent(MotionEvent event) {      
    	if (onFilterTouchEventForSecurity(event)) {        
    		if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
                		result = true;        
    		}        
    		if (!result && onTouchEvent(event)) {
    	            result = true;        
    		}   
    	}     
    	return result;
    }

当设置了setOnTouchListener(),li和mOnTouchListener会被初始化，不为null，前两个条件成立，所以当onTouch()方法返回值为true，就不会执行onTouchEvent(event)方法，返回false会执行。

接下来看onTouchEvent的源码

	public boolean onTouchEvent(MotionEvent event) {
	     if (((viewFlags & CLICKABLE)  ==  CLICKABLE  ||(viewFlags & LONG_CLICKABLE)  ==  LONG_CLICKABLE) 
	        || (viewFlags & CONTEXT_CLICKABLE)  ==  CONTEXT_CLICKABLE) {
	           switch (action) {
	               case MotionEvent.ACTION_UP:                           
	                //如果执行了该方法，其返回值就是onTouchEvent()的返回值                
	                performClick();                             
	                break;        
	            }        
	        return true;    
	    }    
	    return false;
	}

在performClick方法中调用了mOnClickListener.onClick(this)方法。只要我们在代码中通过 setOnClickListener() 方法设置了对单击事件的监听，则对应 View 的 onTouchEvent() 方法返回 true，当然事件就此消费，反之返回 false

>总结：

onTouch()方法的返回值决定了onTouchEvent()方法要不要执行，如果onTouch()返回 true，则onTouchEvent()不会再执行，返回false,则 onTouchEvent() 继续执行，而 onClick() 的回调是在 onTouchEvent() 方法中调用，onTouchEvent() 不执行则 onClick() 不执行。

#View绘制流程 ok

View的绘制流程主要是指measure、layout、draw这三大流程，其中measure确定View的测量宽/高，layout确定View的最终位置，而draw则将View绘制到屏幕上

1. View 的绘制始于 ViewRootImpl 的 performTraversal() 开始遍历，会先从根视图开始测量。**当Activity创建之后，会将DecorView添加到Window中，同时创建ViewRootImpl,并将ViewRoot和DecorView建立关联**
2. 根视图（DecorView）的宽高一般是屏幕宽高，而ViewGroup的宽高会循环调用它所有子视图的测量 measure()，来决定自己的大小
3. onMeasure：方法主要有两个重要的参数，分别是宽度测量规格和高度测量规格，MeasureSpec 测量规格有三种模式，分别是 AT_MOST、EXACTLY、UNSPECIFIED，主要是**代表父布局对子布局的期望**。我们可以重写onMeasure()，循环测量子View，根据子 View 确定父 View，最后调用 setMeasuredDimension() 就行
4. onLayout：代表如何布局子 View 的位置，只有 ViewGroup 需要重写，会传入四个参数。其中布局也是自上而下，不同的是  ViewGroup 先在 layout() 中确定自己的布局，然后在 onLayout() 方法中再调用子 View 的 layout()  方法，让子 View 布局。在 Measure 过程中，ViewGroup 一般是先测量子 View 的大小，然后再确定自身的大小。
5. onDraw：传入一个 Canvas，用于绘制View

> MeasureSpec

MeasureSpec表示的是一个32位的整形值，它的高2位表示测量模式，低30位表示某种测量模式下的规格大小。MeasureSpec是View类的一个静态内部类，用来说明应该如何测量这个View。它由三种测量模式，如下：

- EXACTLY：精确测量模式，view宽高指定为match_parent或具体数值时生效，表示父视图已经决定了子视图的精确大小，这种模式下View的测量值就是SpecSize的值。
- AT_MOST：最大值测量模式，当view的宽高指定为wrap_content时生效，此时子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸。
- UNSPECIFIED：不指定测量模式, 父view没有限制子视图的大小，子视图可以是想要的任何尺寸，通常用于系统内部，应用开发中很少用到。

对于DecorView而言，它的MeasureSpec由窗口尺寸和其自身的LayoutParams共同决定；对于普通的View，它的MeasureSpec由父视图的MeasureSpec和其自身的LayoutParams共同决定。

MeasureSpec和LayoutParams的对应关系：

* 子设置的具体数值，父不管设置啥模式子都是Exactly, 
* 子设置的MatchParant,子跟随父设置的模式

* 子设置的Wrap_content,子模式是AT_MOST，AT_MOST，UNSPECIFIED

**View默认的onMeasure只支持EXACTLY模式，所以如果在自定义控件的时候不重写这个方法的话，也就只能使用EXACTLY模式了，控件可以响应你制定的具体的宽高值或者match_parent属性，如果我们自定义View要让他支持	wrap_content，那就必须重写onMeasure指定wrap_content时的大小**

> 子View大小

ViewGroup-wrap_content然后包裹view-wrap_content,view是全屏大小，ViewGroup若是100dp,子view也是100dp

> 如何求当前Activity View的深度

```
private int getParents(ViewParents view){
    if(view.getParents() == null) 
        return 0;
    } else {
    	return (1 + getParents(view.getParents));
   }
}
```

> 自定义LinearLayout，怎么测量子View宽高

```kotlin
measureChildren(widthMeasureSpec, heightMeasureSpec)
或者for循环 measureChild(child, widthMeasureSpec, heightMeasureSpec)
```

> 如何发起一个View树的测量/布局/绘制流程

* 通过调用**requestLayout/requestFocus**都将发起一个View树的测量。测量完毕后会进行布局，布局完毕后就会绘制。
* **如果View的大小没有发生改变，布局也没有变化，只是显示的内容发生了变化，则可以通过invalidate来请求绘制，此时将不会测量和布局，直接从绘制开始**。
* View 和 ViewGroup绘制区别
  * 继承ViewGroup  
    * 只需要覆盖，onMeasure和onLayout 
  * 继承View    
    * 只需要覆盖，onMeasure和onDraw  

getWidth()方法只能控件调用了layout方法后才能获取 getMeasuredWidth()方法只能调用了控件的measure方法后才能获取

> 自定义实现一个FlexLayout

- onMeasure 在onMeasure里实现对子view的测量，并且根据子view的测量结果决定FlowLayout的大小。
- onLayout 在这里对子view进行布局，决定自view的位置。

思路：当前行剩余空间大于子View占用的大小时，子View往后排布；当前行剩余空间不能够容纳子View时，子View换行。依照该规则进行测量和布局。 

```java
public class FlowLayout extends ViewGroup {

    public FlowLayout(Context context) {
        super(context);
    }

    public FlowLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public FlowLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int width = 0;//测量后FlowLayout的宽度
        int height = 0;//测量后FlowLayout的高度
        int lineWidth = 0;//行当前宽度
        int lineHeight = 0;
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);//宽度的mode
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);//宽度的大小
        int heightSize = MeasureSpec.getSize(heightMeasureSpec);

        int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            //拿到childView
            View child = getChildAt(i);
            //测量childView
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
            //拿到childView的LayoutParams，只支持Margin
            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();
            //childView占用的宽度
            int childWidth = lp.leftMargin + lp.rightMargin + child.getMeasuredWidth();
            int childHeight = lp.topMargin + lp.bottomMargin + child.getMeasuredHeight();
            //换行逻辑，不换行累加宽度，最大行宽为FlowLayout的宽度
            //换行累加高度
            if (childWidth + lineWidth <= widthSize) {
                lineWidth += childWidth;
                lineHeight = Math.max(childHeight, lineHeight);
                width = Math.max(lineWidth,width);
            } else {
                //满足换行条件，重置lineWidth为换行之后的这一个View的宽度，累加高度
                height += lineHeight;
                lineHeight = childHeight;
                lineWidth = childWidth;
                width = Math.max(width, childWidth);
            }
            //处理最后一个view，累加高度
            if (i == childCount - 1) {
                height += lineHeight;
            }
        }
        //设置FlowLayout的大小,主要考虑AS_MOST（wrap_content）模式的大小
        setMeasuredDimension(widthMode == MeasureSpec.EXACTLY ? widthSize : width,
                heightMode == MeasureSpec.EXACTLY ? heightSize : height);
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        int childCount = getChildCount();
        int width = getWidth();
        int lineWidth = 0;
        int lineHeight = 0;
        int height = 0;
        for (int i = 0;i<childCount;i++){
            View child = getChildAt(i);
            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();
            int childWitch = lp.leftMargin+lp.rightMargin+child.getMeasuredWidth();
            int childHeght = lp.topMargin+lp.bottomMargin+child.getMeasuredHeight();
            int mL = lp.leftMargin;
            int mT = lp.topMargin;
            int mR = lp.leftMargin+child.getMeasuredWidth();
            int mB = lp.topMargin+child.getMeasuredHeight();
            if (lineWidth+childWitch<=width){
                //不换行，view往后边排布
                child.layout(mL+lineWidth,mT+height,mR+lineWidth,mB+height);
                //累加lineWidth
                lineWidth+=childWitch;
                //lineHeight为该行view最大高度
                lineHeight = Math.max(lineHeight,childHeght);
            }else {
                //换行，重置lineWidth，累加lineHeight
                lineWidth = 0;
                height+=lineHeight;
                //layout这个view
                child.layout(mL+lineWidth,mT+height,mR+lineWidth,mB+height);
                //换行，行宽为当前view占用的宽度
                lineWidth=childWitch;
            }
        }
    }

    /**
     * 根据XML文件的设置的属性,返回一个支持Margin的LayoutParams
     * @param attrs
     * @return
     */
    @Override
    public LayoutParams generateLayoutParams(AttributeSet attrs) {
        return new MarginLayoutParams(getContext(), attrs);
    }
}
```

##自定义圆角图片

>BitmapShader实现

	public class RoundImageViewByBitmapShader extends ImageView {
	
	  private Shader mShader;
	  private Paint mPaint;
	
	  public RoundImageViewByBitmapShader(Context context) {
	    super(context);
	  }
	
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs) {
	    super(context, attrs);
	  }
	
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
	    super(context, attrs, defStyleAttr);
	  }
	
	  @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
	    super(context, attrs, defStyleAttr, defStyleRes);
	  }
	
	  @Override
	  protected void onDraw(Canvas canvas) {
	    BitmapDrawable drawable = (BitmapDrawable) getDrawable();
	    if (mShader == null) {
	      mShader = new BitmapShader(drawable.getBitmap(), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
	      mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
	    }
	    mPaint.setShader(mShader);
	    canvas.drawRoundRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), 100, 100, mPaint);
	  }
	}

#Handler机制  ok

文章：https://juejin.cn/post/6844903810989555726

##简单描述下Handler机制？一个线程有几个Looper？为什么？

Handler机制由MessageQueue，Message，Looper，Handler组成。Handler的主要作用是发送和处理消息；MessageQueue称作消息队列，采用单链表的数据结构存储Message；Looper是一个循环，会在一个无限循环中不断从MessageQueue中获取Message，如果有Message，就交给对应的Handler去处理；Message是传递的消息，它的target参数持有是发送它的Handler对象。Handler通过sendMessage()发送消息Message到消息队列MessageQueue。Looper通过loop()不断提取触发条件的Message，并将Message交给对应target的handler来处理。handler调用自身的handleMessage()方法来处理Message。

- 1、Handler通过sendMessage()发送消息Message到消息队列MessageQueue。（发送消息的最终方法是sendMessageAtTime）
- 2、Looper通过loop()不断提取触发条件的Message，并将Message交给对应的target handler来处理。
- 3、target handler调用自身的handleMessage()方法来处理Message。

一个线程只有1个Looper，是通过ThreadLocal来保证的

> ThreadLocal

ThreadLocal用于保存线程全局变量，当前线程独有，不与其他线程共享

Thread持有ThreadLocalMap，而且ThreadLocalMap里对ThreadLocal的引用还是弱引用，所以只要Thread对象可以被回收，那么ThreadLocalMap就能被回收

> 为什么不推荐使用线程池

如果在线程池中使用ThreadLocal可能会导致内存泄漏，原因是线程池中线程的存活时间太长，往往和程序都是同生共死的，这就意味着Thread持有的ThreadLocalMap一直都不会被回收，再加上ThreadLocalMap中的Entry对ThreadLocal是弱引用，所以只要ThreadLocal结束了自己的生命周期是可以被回收掉的。但是Entry中的Value却是被Entry强引用的，所以即便Value的生命周期结束了，Value也是无法被回收的，从而导致内存泄漏

##Handler发送消息的 Delay 可靠吗？

答案是不靠谱的，引起不靠谱的原因有如下

* 发送的消息太多,Looper负载越高，任务越容易积压，进而导致卡顿
* 消息队列有一些消息处理非常耗时，导致后面的消息延时处理

> 如何优化保证可靠性

消息精简，从数量上处理

* 重复消息过滤
* 互斥消息取消
* 复用消息

##Handler内存泄漏的GCRoot是什么？

ThreadLocal静态变量作为gcRoot，导致activity无法被回收

handler的内存泄漏原因：

1. 当直接在activity中声明handler时，由于后面的匿名内部类，使handler持有了activity的引用。
2. 当任务未执行完，即message未被执行完时，message持有了messageQueue的引用。
3. messageQueue持有了mLooper的引用。
4. mLooper持有sThreadLocal 的引用。
5. sThreadLocal 是一个静态变量，无法被回收，最终导致了activity无法被回收，造成了内存泄漏。

##Handler休眠是怎样的？epoll的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？

Handler消息机制，在Java层的MessageQueue中，调用了native方法实现消息循环的休眠和唤醒（也就是线程的休眠和唤醒）。native方法nativePollOnce实现了消息循环的休眠，而方法nativeWake实现了消息循环的唤醒。

在native层，消息循环的休眠和唤醒使用了Linux内核的epoll机制和pipe

* epoll机制是linux内核实现IO多路复用的一个实现。在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源读写就绪对程序进行读写操作。
  * epoll 相关方法： 
    * epoll_create() ：创建一个epoll对象，并返回一个文件描述符，这个描述符就是epoll实例的句柄
    * epoll_ctl()：向epoll句柄添加或者删除要监听的文件句柄
    * epoll_wait()：阻塞等待注册的事件发生

* pipe是Linux中最基本的一种IPC机制，可以用来实现进程、线程间通信。pipe其本质是一个伪文件，它有两个文件描述符引用，一个表示读端，一个表示写端，规定数据从管道的写端流入管道，从读端流出。

在MessageQueue的构造里调用nativeInit()方法初始化epoll，这个方法内部调用epoll_create()，epoll_ctl()。当遇到延时消息时，会调用nativePollOnce休眠一段时间，时间到了自动唤醒，当新消息来时，会调用nativeWeak()唤醒线程处理消息，然后重新计算休眠消息的时间msg.when - now。

epoll机制在Handler中的应用，在主线程的 MessageQueue 没有消息时，便阻塞在 loop 的 queue.next() 中的 nativePollOnce() 方法里，最终调用到epoll_wait()进行阻塞等待。此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。这里采用的 epoll 机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。

https://www.jianshu.com/p/66fa1a8396ad

> 如何实现延时消息，如果移除一个延时消息会解除休眠吗？

发送延时消息，不是延时发送而是延时处理，发送消息后MessageQueue按照Message.when的先后顺序排列，队头的消息是最早触发的消息。处理消息时会调用nativePollOnce(ptr, nextPollTimeoutMillis timeoutMillis = -1表示一直阻塞。如果有delay的消息，则 timeoutMillis表示delay的时间)，这个方法会调用epoll_wait睡眠一段时间，休眠结束后在去处理这个消息。

在Meesage入队的时候，也就是执行`MessageQueue.enqueueMessage()`方法时，`enqueueMessage()`有一个`nativeWeak()`

会

>为什么我们能在主线程直接使用 Handler，而不需要创建 Looper

通常我们认为 ActivityThread 就是主线程。事实上它并不是一个线程，而是主线程操作的管理者。在  ActivityThread.main() 方法中调用了 Looper.prepareMainLooper() 方法创建了 主线程的  Looper ,并且调用了 loop() 方法，所以我们就可以直接使用 Handler 了。

> 主线程的死循环一直运行是不是特别消耗CPU资源呢？

在主线程的MessageQueue没有消息时，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质是同步I/O，即读写是阻塞的。所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。

UI线程进入Looper的无限循环之后，为什么没有ANR，是因为底层使用了Linux的epoll机制和pipe实现了线程在空闲时的休眠，并且不会占用系统CPU资源。

> Message是根据什么排序的

是根据when字段排序的，when=系统开机时间+delayMillis

插入消息时，根据当前`msg.when`决定插入的位置

> Handler构造中callBack是做啥的

可以起到拦截消息的作用，返回值为 `true` 表示不继续向下分发, 返回 `false` 还会向下分发, 会调用 `Handler.handleMessage()` 方法

>主线程的Looper何时退出

在App退出时，ActivityThread中的mH（Handler）收到消息后，执行退出

##如何处理Handler使用不当造成的内存泄漏？

* 有延时消息，在界面关闭后及时移除Message/Runnable，调用handler.removeCallbacksAndMessages(null)

* 内部类导致的内存泄漏改为静态内部类，并对上下文或者Activity/Fragment使用弱引用。

##Handler是怎么切换线程的,Handler同步屏障

> 同步屏障

![同步屏障.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C.png?raw=true)

如上图所示，在消息队列中有同步消息和异步消息（黄色部分）以及一道墙----同步屏障（红色部分）。有了同步屏障的存在，msg_2 和 msg_M 这两个异步消息可以被优先处理，而后面的 msg_3 等同步消息则不会被处理。那么这些同步消息什么时候可以被处理呢？那就需要先移除这个同步屏障，即调用`removeSyncBarrier()`。

Handler中的Message可以分为两类：同步消息，异步消息，一般我们直接发送的消息都是同步消息，只有在msg.setAsynchronous(true)时，发送的消息都会变成异步消息。

一般来说这两种消息没有什么区别，只有在设置了同步屏障时才会出现差异。

可通过mHandler.getLooper().getQueue().postSyncBarrier()设置同步屏障。本质上是发送一个 target 字段为空的 Message到消息队列，设置同步屏障后，loop循环会遍历找到异步消息去处理

Handler设置同步屏障之后，Looper只会获取和处理异步消息，如果没有异步消息会进入阻塞状态。

同步屏障的设置可以方便地处理那些优先级较高的异步消息。当我们调用`Handler.getLooper().getQueue().postSyncBarrier()` 并设置消息的`setAsynchronous(true)`时，target 即为 null ，也就开启了同步屏障。当在消息轮询器 Looper 在`loop()`中循环处理消息时，如若开启了同步屏障，会优先处理其中的异步消息，而阻碍同步消息。

>Handler线程切换

在A线程正常创建handlerA，然后在B线程中利用handlerA发送消息，此时消息就发送给与handlerA关联的Looper了，而这个Looper唯一关联的线程就是A，这样我们的消息就会在A线程中执行了

> IdleHandler调用时机 IdleHandler应用场景

当handler空闲的时候会调用IdleHandler

```kotlin
//可以用来获取View的宽高
Looper.myQueue().addIdleHandler {
            Loger.e("--Idle--${mView.width}，${mView.height}----")
            false//返回false的话会从mIdleHandlers集合中删除，反之保留。
 }
```

# Binder机制 ok

Android Binder通信步骤：1.注册服务。2.请求服务。3.传输数据。

Linux系统将一个进程分为用户空间和内核空间。对于进程之间来说，用户空间的数据不可共享，内核空间的数据可共享，为了保证安全性和独立性，一个进程不能直接操作或者访问另一个进程，即Android的进程是相互独立、隔离的，这就需要跨进程之间的数据通信方式。普通的跨进程通信方式一般需要2次内存拷贝，如下图所示：

![普通进程通信.jpg](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E6%99%AE%E9%80%9A%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.jpg?raw=true)

> 一次完整的 Binder IPC 通信过程通常是这样：

首先 Binder 驱动在内核空间创建一个数据接收缓存区； 接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系； 发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。 如下图：

![Binder通信流程.jpg](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/Binder%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.jpg?raw=true)

> Binder框架中ServiceManager的作用？

Binder框架 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder驱动，其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。如下图所示：

![Binder框架中个组件.jpg](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/Binder%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%B8%AA%E7%BB%84%E4%BB%B6.jpg?raw=true)

Server通过Binder驱动在ServiceManager中注册服务 ,Client通过Bindr驱动查询ServiceManager中注册的服务 ,ServiceManager通过Binder驱动返回Server的代理对象 ,Client拿到Server端的代理对象就可以进行进程间通讯了,Client和Server是开发者自己来实现，Binder驱动和ServiceManager是系统提供的。

在Android中client不是直接去和binder打交道，client直接和Manager交互，而manager和managerProxy交互，也就是说client是通过managerProxy去和binder进行交互的。同时service也不是直接和binder交互，而是通过stub去和binder交互。

##binder是cs架构，Server端的binder都是运行在同一个线程里面么

不是



# Kotlin ok

##Kotlin对比Java

1. 空安全处理
2. 属性访问,代替Get/Set方法
3. 默认构造函数
4. 自动绑定xml文件中控件ID
5. 使用字符串模版简化字符串拼接
6. 扩展功能：为了增强Java中当前类的功能，需要创建一个新类并派生父类；而kotlin只需要使用扩展函数
7. 多了协程
8. 没有三目操作符

## 顶层函数

Kotlin 顶层函数相当于 Java 中的静态函数，往往我们在 Java 中会用到类似 Utils 的类来放置不属于任何类的公共静态函数。

创建一个kt文件，在里面写的函数就是顶层函数，在里面写的属性就是顶层属性

## 函数式编程含义

从函数式编程的角度来说，只关心输入数据和输出数据的关系

在实际使用中，函数式编程最具代表性的就是lambda表达式的使用。lambda本质上就是可以传递给其他函数的一段代码，也就是说，在函数式编程中，函数本身可以作为参数和返回值。

## 函数字面量

函数字面值：一个函数可以当作参数来传递

```
var x : ((Int) ->Boolean)? = null

fun method(a: ((Int) -> Boolean)?) {
    val b = a?.invoke(3)
    println(b)
}

fun method1(requestMethod: suspend () -> Unit,
            errorMethod: (errorCode: String) -> Unit = {}){
    requestMethod
}
```

## let和with的区别

```
1.返回值
	lambda表达式结果-> let\run\with
  	上下文对象->apply\also
2.作用域中对象引用方式
  	it->let\also
  	this->with\run\apply
let->统一判null
run->对象配置并计算结果
with->对象的一组操作
apply->对象配置
also->并且对象还做什么事情
```

##lateinit和by lazy的区别

1. lazy只能用在val类型, lateinit 只能用在var类型
2. lateinit可以初始化多次。而lazy在第一次被调用时就被初始化

##kotlin的扩展方法是怎么实现的，inline关键字的作用

扩展函数并没有修改原有的类，而是生成了一个静态的方法,当我们在Kotlin中调用扩展函数时,编译器将会调用自动生成的函数传入对象实例和参数

被inline修饰的函数(内联函数)，可以在编译时被复制到调用处

## kt的伴生对象是饿汉模式还是懒汉模式

```
//懒汉
class Student private constructor() {
    companion object { //伴生对象
        val instance: Student by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) {
            Student()
        }
    }
}

//饿汉式单例模式实现 对象声明
object Student {
    fun study() {}
}
```

##kotlin与Java互相调用有什么问题？

java里面调用Kotlin，如果kotlin参数是非空类型，在Kotlin的代码中假设想要给这个方法传入可空类型，在编译阶段就会报错，在Java代码中去调用kotlin方法如果传入空指针，那么编译阶段并不能发现问题，运行时Java这边就会抛出NullPointerException。

@JvmStatic，kotlin静态方法声明这个时，java可直接调用，否则要加instance调用。
@JvmOverloads主要是Kotlin定义默认参数生成重载方法

@file:JvmName指定Kotlin文件编译之后生成的类名。
java想直接调用kotlin的成员变量@JvmField

##kotlinc与javac编译字节码有什么区别？

kotlinc编译出的class文件变大，Constant pool常量池变大

##kotlin空安全的原理是什么？

参数：非空类型的属性编译器添加**@NotNull**注解，可空类型添加**@Nullable**注解；非空类型直接对参数进行判空，如果为空直接抛出异常；

方法调用：不空才执行后续代码，否则返回null；如果是!!，空的话直接抛出异常。

##你对协程的理解，协程有什么作用？可以完全取代rxjava吗？协程怎么取消？

协程是轻量级的线程。kotlin中的协程可以看成是一套基于线程而实现的API，它依赖线程，但是在挂起时不会阻塞线程，一个线程可以创建任意个线程

​	优点是

​		可以将异步变同步写法。 

​		协程挂起时不需要阻塞线程  

​		比线程更轻量，性能好，切换时状态保存

​	缺点是本质是个单线程，不能利用到单个CPU的多个核

不可以替代，1.操作符没有rxjava丰富2.在java代码中还是得用这个3.无法利用多核

>协程怎么取消

```kotlin
val startTime = System.currentTimeMillis()
val job = launch(Dispatchers.Default) {
    var nextPrintTime = startTime
    var i = 0
    while (isActive) { // 可以被取消的计算循环
        // 每秒打印消息两次
        if (System.currentTimeMillis() >= nextPrintTime) {
            println("job: I'm sleeping ${i++} ...")
            nextPrintTime += 500L
        }
    }
}
delay(1300L) // 等待一段时间
println("main: I'm tired of waiting!")
job.cancelAndJoin() // 取消该作业并等待它结束
println("main: Now I can quit.")
```

在执行计算任务时需要通过isActive检测取消状态，这样才可以取消

> 使用协程时有遇到什么问题吗

## 协程和线程对比



##协程的scope与context

scope是协程的作用域，他的作用是可以统一管理协程，并可以一次性取消所有协程

协程上下文理解起来跟activity上下文概念差不多，协程上下文伴随着协程的生命周期

> +

有时我们需要在协程上下文中定义多个元素。我们可以使用 `+` 操作符来实现。 比如说，我们可以显式指定一个调度器来启动协程并且同时显式指定一个命名：

```
launch(Dispatchers.Default + CoroutineName("test")) {
    println("I'm working in thread ${Thread.currentThread().name}")
}
```

## 调度器 CoroutineDispatcher

```
launch(Dispatchers.Main) { // 在主线程中
launch(Dispatchers.Unconfined) { // 在主线程中
launch(Dispatchers.Default) { // 使用默认调度器
launch(newSingleThreadContext("MyOwnThread")) { // 开新的线程
```



# 性能优化 ok

需要完善

> 原理

https://juejin.cn/post/6916531888576266254#comment

* UI线程卡顿检测原理：
  对 UI 线程的 Looper 里面处理 Message 的过程进行监控。
  具体做法是，在 Looper 开始处理 Message 前，在异步线程开启一个延时任务，用于后续收集信息。如果这个 Message 在指定的时间段内完成了处理，那么在这个 Message 被处理完后，就取消之前的延时任务，说明 UI 线程没有 block 。如果在指定的时间段内没有完成任务，说明 UI 线程有 block 。此时，异步线程可以执行刚才的延时任务。如果我们在这个延时任务里面打印 UI 线程的方法调用栈，就可以知道 UI 线程在做什么了。这个就是 UI  线程 block 检测的基本原理。

* FPS 检测的原理：
  利用了 Android 的屏幕绘制原理
  系统每隔 16 ms 就会发送一个 VSync 信号。 如果应用注册了这个 VSync 信号，就会在 VSync  信号到来的时候，收到回调，从而开始准备绘制。如果准备顺利，也就是 CPU 准备数据、GPU 栅格化等，如果这些任务在 16 ms 之内完成，那么下一个 VSync 信号到来前就可以绘制这一帧界面了。就没有掉帧，界面很流畅。如果在 16 ms 内没准备好，可能就需要更多的时间这个画面才能显示出来，在这种情况下就发生了丢帧，如果丢帧很多就卡顿了。
  检测 FPS 的原理其实挺简单的，就是通过一段时间内，比如 1s，统计绘制了多少个画面，就可以计算出 FPS 了。那如何知道应用 1s 内绘制了多少个界面呢？这个就要靠 VSync 信号监听了。 

## 启动优化

Application中的三方SDK进行异步初始化(协程/线程池)，有些SDK优先级并不是那么高，可以结合idealHandler进行延迟初始化做了一个更优的延迟初始化的方案，利用它可以在主线程的空闲时间进行初始化，以减少启动耗时导致的卡顿现象(环信、视频延迟初始。广告ID，facebook事件记录采用线程空闲初始化)

1. 延迟初始化是在页面界面显示之后才去进行加载，但是如果此时界面需要进行滑动等与用户交互的一系列操作，就会有很严重的卡顿现象，所以使用idealHandler在线程空闲的时候进行初始化
2. 给闪屏页设置主题背景，防止启动白屏

## 包大小优化

APK组成：lib \ res \assets \ META-INF(签名摘要等信息) \ dex \ resources.arsc(编译后的二进制资源文件) \ AndroiManifest.xml

lib,dex,res占用了超90%的空间，这三个是优化的重点

1. 资源优化
   1. 将多套分辨率图片删除，只留一套-xxhdpi，然后对剩余的图片使用tingpng压缩，压缩完成后还是比较大的转成webp，这个操作会优化很大空间
   2. 打包前使用Android Lint命令-unuse resource 筛选出无用资源进行删除和扫描图片的MD5值，删除重复资源
   3. 资源混淆优化使用AndResGuard，对资源路径做名字混淆达到减少包体积的效果
   4. 禁用AAPT自动优化png图片，因为这个有可能会使已经优化过的图片变大
   5. 视频资源没有找到好的压缩方法，最后使用微信压缩，10M左右转成几百k
2. dex优化
   1. 使用ProGuard来对代码进行混淆、优化、压缩等工作
   2. 去除重复或者不用的代码，慎用第三方库，选用体积小的第三方SDK
3. lib:只留armv7和armv8，剩下的删除(v7兼armeabi)
4. 将帧动画转为lottie动画，因为帧动画贼占资源
5. 通过分离应用中比较独立的模块，然后以插件的形式进行加载
6. 随着资源的增加R.class也会变大，代码中访问资源是通过R.xx.xx，而R.xx.xx对应的是.arsc中一个常量值。因此可以通过使用ID替换R.xx.xx，这样R.class文件就没有作用了，然后可以删除。工具（https://github.com/meili/ThinRPlugin）

## 内存优化

> 内存抖动是由于短时间内有大量对象进出新生区导致的，它伴随着频繁的GC，gc会大量占用ui线程和cpu资源，会导致app整体卡顿。

避免发生内存抖动的几点建议：

- 尽量避免在循环体内创建对象，应该把对象创建移到循环体外。
- 注意自定义View的onDraw()方法会被频繁调用，所以在这里面不应该频繁的创建对象。
- 当需要大量使用Bitmap的时候，试着把它们缓存在数组或容器中实现复用。
- 对于能够复用的对象，同理可以使用对象池将它们缓存起来。

> 内存泄露

使用LeakCanrary

##卡顿优化

1.使用严格模式 StrictMode

解决问题记录：

1. 实例对象重复问题
2. UI线程有耗时操作检测
3. 异步操作一定要使用弱引用，防止内存泄漏
4. List对象和handler对象在当前活动activity最好结束时最好销毁

2.Android Studio Profiler https://www.jianshu.com/p/a3d91986b4c7

# 图片相关 ok

## Bitmap内存大小，注意事项，如何优化

```
ALPHA_8   每个像素占用1byte内存        
ARGB_4444 每个像素占用2byte内存       
ARGB_8888 每个像素占用4byte内存（默认）      
RGB_565 每个像素占用2byte内存
```

内存大小 = 宽度像素 x 高度像素 x 单个像素内存大小

> 注意事项：

1、要选择合适的图片规格（bitmap类型）：

3、使用弱引用(内存不够的时候才会回收掉)

4、使用recycle()方法及时回收内存。

5、压缩图片

6、当我们需要获取图片的宽高等属性时且不对数据进行操作，那么我们不应该把图片的数据加载到内存中，这时我们可以设置inJustDecodeBounds属性为true.

> 大图加载：

使用采样压缩：通过设置BitmapFactory.Options中inSampleSize

```
BitmapFactory.Options bmOptions = new BitmapFactory.Options();
// 值设为true那么将不返回实际的bitmap，也不给其分配内存空间这样就避免内存溢出了。但是允许我们查询图片的信息这其中就包括图片大小信息
bmOptions.inJustDecodeBounds = true;
BitmapFactory.decodeFile(filePath, bmOptions);
int photoW = bmOptions.outWidth;
int photoH = bmOptions.outHeight;
// 调用上面定义的方法计算inSampleSize值
options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);
// 使用获取到的inSampleSize值再次解析图片
options.inJustDecodeBounds = false;
Bitmap b = BitmapFactory.decodeFile(fileName, options);
```

inSampleSize比率：计算出实际宽高和目标宽高的比率，选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高

>Bitmap内存复用

利用inBitmap，使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。

使用inBitmap需要注意几个限制条件：

(1).在SDK 11 -> 18之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小

(2).新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了。 我们可以创建一个包含多种典型可重用bitmap的对象池，这样后续的bitmap创建都能够找到合适的模板去进行重用。

> Bitmap优化

1. 当我们需要获取图片的宽高等属性时且不对数据进行操作，那么我们不应该把图片的数据加载到内存中，这时我们可以设置inJustDecodeBounds属性为true.

2. ###### 减小Bitmap对象的内存占用

   1. inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。
   2. decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异

3. ###### LRU管理Bitmap：使用Lru来管理Bitmap,设置最大内存，可以防止出现内存溢出

4. ###### Bitmap对象及时回收：bitmap.recycle()

5. ###### Bitmap对象的复用：inBitmap

> xhdpi的图片放到xxhdp的手机上，内存会如何变化

内存占用会变小

MDPI：HDPI:XHDPI:XXHDPI:XXXHDPI = 1:1.5:2:3:4

当图片放在与手机屏幕 ppi对应drawable 目录下，图片就能以自己实际的宽高加载进内存。否则就要按比例进行缩放宽高加载进内存。

与手机屏幕dpi一致的文件夹称之为目标文件夹，此时会以图片的原尺寸加载进内存，当把xxdpi图片放到hdpi时，还要展示在手机上，就需要将图片缩放3/1.5(xxdpi:hdpi = 3:1.5)

当图片放置的文件夹<目标文件夹时，图片占用内存大，当图片放置的文件夹>目标文件夹时，图片占用内存越小。

#屏幕适配做过什么工作 OK

> 基本概念

- 像素（px）：像素就是手机屏幕的最小构成单元，px = 1像素点 一般情况下UI设计师的设计图会以px作为统一的计量单位。
- 分辨率：手机在横向、纵向上的像素点数总和 一般描述成 宽*高 ，即横向像素点个数 * 纵向像素点个数（如1080 x 1920），单位：px。
- 屏幕尺寸：手机对角线的物理尺寸。单位 英寸（inch），一英寸大约2.54cm 常见的尺寸有4.7寸、5寸、5.5寸、6寸。
- 屏幕像素密度（dpi）：每英寸的像素点数，例如每英寸内有160个像素点，则其像素密度为160dpi，单位：dpi（dots per inch）。
- 标准屏幕像素密度（mdpi）： 每英寸长度上还有160个像素点（160dpi），即称为标准屏幕像素密度（mdpi）。
- 密度无关像素（dp）：与终端上的实际物理像素点无关，可以保证在不同屏幕像素密度的设备上显示相同的效果，是安卓特有的长度单位，dp与px的转换：1dp = （dpi / 160 ） * 1px。
- 独立比例像素（sp）：字体大小专用单位 Android开发时用此单位设置文字大小，推荐使用12sp、14sp、18sp、22sp作为字体大小。

> 适配方案

1. 宽高限定适配：简单说，就是穷举市面上所有的Android手机的宽高像素值：设定一个基准的分辨率，其他分辨率都根据这个基准分辨率来计算，在不同的尺寸文件夹内部，根据该尺寸编写对应的dimens文件，这个时候，如果我们的UI设计界面使用的就是基准分辨率，那么我们就可以按照设计稿上的尺寸填写相对应的dimens引用了,而当APP运行在不同分辨率的手机中时，这些系统会根据这些dimens引用去该分辨率的文件夹下面寻找对应的值。

   1. 有些分辨率没有被覆盖到就会只用默认的尺寸，而使用默认的尺寸的话，UI就很可能变形，简单说，就是容错机制很差。

   2. res文件增大

   3. 比如以480x320为基准分辨率

      * 宽度为320，将任何分辨率的宽度整分为320份，取值为x1-x320

      - 高度为480，将任何分辨率的高度整分为480份，取值为y1-y480

      * 那么对于800*480的分辨率的dimens文件来说，

      * x1=(480/320)*1=1.5px

      * x2=(480/320)*2=3px

2. 最小宽度限定符适配方案：Android会识别屏幕可用高度和宽度的最小尺寸的dp值（其实就是手机的宽度值），然后根据识别到的结果去资源文件中寻找对应限定符的文件夹下的资源文件。

   1. 最小宽度是宽高限定的升级版，最小宽度只是把dimens.xml文件中的值从px换成了dp，原理和使用方式都是没变的。开发者先根据设计图最小宽度生成一系列dimens文件夹，当把项目运行到设备上时，系统会根据当前设备屏幕的最小宽度去匹配对应的dimen文件夹。

   2. 举个例子，小米5的dpi是480,横向像素是1080px，根据px=dp(dpi/160)，横向的dp值是1080/(480/160),也就是360dp,系统就会去寻找是否存在value-sw360dp的文件夹以及对应的资源文件。

   3. smallestWidth限定符适配和宽高限定符适配最大的区别在于，前者有很好的容错机制，如果没有value-sw360dp文件夹，系统会向下寻找，比如离360dp最近的只有value-sw350dp，那么Android就会选择value-sw350dp文件夹下面的资源文件。

   4. 优点：稳定，对app没有性能损耗，适配范围可控，不会影响其他三方库

      缺点：dimens维护成本较高；方案侵入性大。适配方案切换起来非常麻烦；导致app体积增大

3. 今日头条方案：修改density值，强行把所有不同尺寸分辨率的手机的宽度dp值改成一个统一的值，这样就解决了所有的适配问题。

   1. 比如，设计稿宽度是360px，那么开发这边就会把目标dp值设为360dp，在不同的设备中，动态修改density值，从而保证(手机像素宽度)px/density这个值始终是360dp,这样的话，就能保证UI在不同的设备上表现一致了。

#说说MVP和MVVM的特点 ok

MVC:

- 视图层(View) 对应于xml布局文件和java代码动态view部分
- 控制层(Controller) 业务逻辑。
- 模型层(Model) 存取管理数据，它主要负责网络请求，数据库处理，I/O的操作。

MVC 的问题点 如下：

​	MVC中Android的控制层是由Activity来承担的，Activity本来主要是作为初始化页面，展示数据的操作，但是因为XML视图功能太弱，所以Activity既要负责视图的显示又要加入控制逻辑，承担的功能过多。

​	Activity/Fragment 责任不明，同时负责View、Controller，就会导致其中代码量大，不满足单一职责

MVP:

- Model，模型层，即数据模型，用于获取和存储数据。
- View，视图层，即Activity/Fragment
- Presenter，控制层，负责业务逻辑。

MVP框架由3部分组成：View负责显示，Presenter中间层负责逻辑处理，Model提供数据。分离了M层和V层的代码，通过P层来建立他们的关联，实现M层和V层的解耦。缺点就是每增加一个功能，需要增加相应的接口回调。MVP的核心就是通过接口实现隔离，将相关的业务层交给了P层。

MVP解决了MVC的问题：1.View责任明确，逻辑不再写在Activity中，而是在Presenter中；2.Model不再持有View。

MVP的实现思路：

- UI逻辑抽象成IView接口，由具体的Activity实现类来完成。且调用Presenter进行逻辑操作。
- 业务逻辑抽象成IPresenter接口，由具体的Presenter实现类来完成。逻辑操作完成后调用IView接口方法刷新UI。

MVP 本质是面向接口编程。MVP解决了View层责任不明的问题，但并没有解决代码耦合的问题，View和Presenter之间相互持有。

所以MVP有问题点如下：

1. 会引入大量的IView、IPresenter接口，增加实现的复杂度。
2. View和Presenter相互持有，形成耦合。

MVVM:

MVP中我们说过随着业务逻辑的增加，UI的改变多的情况下，会有非常多的跟UI相关的接口，这样就会造成View的接口会很庞大。而MVVM就解决了这个问题，通过双向绑定的机制，实现数据和UI内容，只要想改其中一方，另一方都能够及时更新的一种设计理念，这样就省去了很多在View层中写很多case的情况，只需要改变数据就行。

Mvvm加强了对生命周期的处理，不用像mvp一样在ondestory的时候手动处理内存泄漏

MVVM解决的问题：

​	接口；内存泄露(生命周期)

## MVP怎么处理内存泄漏

在Activity或者Fragment关闭的时候将Presenter对View的引用释放

```java
public void detachView() {//解除关联
    if (mViewRef != null) {
        mViewRef.clear();
        mViewRef = null;
    }
}
```

# JetPack组件

## 用过的组件有哪些

Data Binding\Lifecycles\LiveData\Navigation\Room\ViewModel

> ViewModel 用来管理数据，它同样具有感知生命周期的能力，在宿主没有被销毁之前，数据不会丢失，且ViewModel不会重新创建，比如旋转屏幕等。

ViewModel 以注重生命周期的方式存储和管理界面相关的数据。(作用)

ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。(特点)

> LiveData：是一种可观察的数据存储器类。LiveData 具有生命周期感知能力，如 Activity、Fragment 的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。LiveData 分为可变值的MutableLiveData和不可变值的LiveData

- **确保界面符合数据状态**，当生命周期状态变化时，LiveData通知Observer，可以在observer中更新界面。观察者可以在生命周期状态更改时刷新界面，而不是在每次数据变化时刷新界面。
- **不会发生内存泄漏**，observer会在LifecycleOwner状态变为DESTROYED后自动remove。
- **不会因 Activity 停止而导致崩溃**，如果LifecycleOwner生命周期处于非活跃状态，则它不会接收任何 LiveData事件。
- **不需要手动解除观察**，开发者不需要在onPause或onDestroy方法中解除对LiveData的观察，因为LiveData能感知生命周期状态变化，所以会自动管理所有这些操作。

> Lifecycle ：管理（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。

> DataBinding https://juejin.cn/post/6844904191656214536
>

优点

* 不用再 findViewById 了(当然kotlin也可以不用喽)
* 减少了 Avtivity和Fragment的逻辑处理，使Activity 和Fragment逻辑更加清晰，容易维护
* 双向绑定，当View改变的时候会通知Model，当Model改变的时候会通知View

缺点

* 很难定位bug，当有个界面展示不对的时候，你不知道是View的问题，还是Model的问题，还是编写逻辑的问题，
* xml中 不能Debug
* 双向绑定技术，不利于View的复用，因为一个xml 里面绑定的一个Model，有可能另一个界面Model就不一样了，所以无法复用了。除非你再手动转一下这个Model

##lifeCycle的原理是什么？如果在onStart里面订阅，会回调onCreate吗？（继续背5）

会

http://liuwangshu.cn/application/jetpack/3-lifecycle-theory.html

创建一个不可见的ReportFragment添加到Activity，然后分发生命周期到订阅的对象。实现LifecycleObserver接口的类中，注解修饰的方法和事件会被保存起来，然后在生命周期发生改变的时候再找到对应 Event 的方法，通过反射对事件的对应方法进行调用，。

##ViewModel（继续背4）

原理：通过注入一个retainInstance 为 true 的 HolderFragment ，利用 Fragment 的特性来保证在 Activity 配置改变后依然能够存活一下，并且保证了 HolderFragment 内部的 ViewModelStore 的存活，最终保证了 ViewModelStore 内部储存的 ViewModel 缓存存活，从而实现了 ViewModel 的生命周期这个特点功能

https://juejin.cn/post/6844904079265644551#comment

> ViewModel为什么在旋转屏幕后不会丢失状态



> ViewModel在Activity初始化与在Fragment中初始化，有什么区别？



> viewModel是怎么实现双向数据绑定的

通过DataBinding

> viewModel怎么实现自动处理生命周期



## LiveData数据倒灌

现象：多个Fragment共享一个ViewModel中设置了一个LiveData，FragmentA observe到这个LiveData的一次通知，关闭 FragmentA 后，再进入 FragmentA，由于 该 ViewModel 是共享的，其中的 LiveData 并没有随着 FragmentA 的退出而清除，那么再次进入后，会自动走一遍 observe 回调，倒灌旧数据。

为啥会造成数据倒灌的问题？

对于LiveData，其初始的version是-1，当我们调用了其setValue或者postValue后，其version会+1；对于每一个新注册的观察者（ObserverWrapper），其mLastVersion为-1；当LiveData设置这个ObserverWrapper的时候，如果LiveData的version大于ObserverWrapper的mLastVersion，LiveData就会强制把当前value推送给Observer。

当fragment生命周期变化时，会触发数据分发函数，在分发中会判断mLastVersion是否小于mVersion，若是小于则会分发，而每个新的订阅者其version都是-1，LiveData一旦设置过其version是大于-1的（每次LiveData设置值都会使其version加1），这样就会导致LiveData每注册一个新的订阅者，这个订阅者就会立刻收到一个回调，即使这个设置的动作发生在订阅之前

设计理由：为了处理生命周期从 unActive 到 active 转变时，跟进“最新” 的状态

解决：通过反射修改livedata源码observer.mLastVersion的值，使得if (observer.mLastVersion >= mVersion)成立，就不会导致没有注册观察者，还能接收到消息。

# RecyclerView ok

> ListView缓存

ListView的缓存有两级，在ListView里面有一个内部类 RecycleBin，RecycleBin有两个对象Active View和Scrap View来管理缓存，Active View是第一级，Scrap View是第二级。

* Active View：是缓存在屏幕内的ItemView，当列表数据发生变化时，屏幕内的数据可以直接拿来复用，无须进行数据绑定。
* Scrap view：缓存屏幕外的ItemView，屏幕外的所有数据在进入屏幕的时候都要走一遍getView（）方法。

**Listview缓存的是ItemView，Recyclerview缓存的是ViewHolder**

> Recyclerview缓存

https://www.jianshu.com/p/3e9aa4bdaefd

Recycleview有四级缓存，分别是`mAttachedScrap(屏幕内)，mCacheViews(屏幕外)，mViewCacheExtension(自定义缓存)，mRecyclerPool(缓存池)`

- Scrap(屏幕内)：用于屏幕内ViewHolder快速重用
  - 数据结构是ArrayList，在LayoutManager#onLayoutChildren方法中，对views进行布局时，会将RecyclerView上的Views全部缓存到该集合中，以备后续使用，该缓存中的ViewHolder的特性是，如果和RV上的position或者itemId匹配上了，那么认为是干净的ViewHolder，是可以直接拿出来使用的，无需调用onBindViewHolder方法。该ArrayList的大小是没有限制的，屏幕上有多少个View，就会创建多大的集合。触发该层级缓存的场景一般是调用notifyItemXXX方法。调用notifyDataSetChanged方法，只有当Adapter hasStableIds返回true，会触发该层级的缓存使用
  - mChangedScrap：mChangedScrap和mAttachedScrap是同一级的缓存，他们是平等的。但是mChangedScrap的调用场景是notifyItemChanged和notifyItemRangeChanged，只有发生变化的ViewHolder才会放入到mChangedScrap中。mChangedScrap缓存中的ViewHolder是需要调用onBindViewHolder方法重新绑定数据的。
- Cache(屏幕外)：刚移出屏幕的缓存数据，默认大小是2个，当其容量被充满同时又有新的数据添加的时候，会根据FIFO原则，把优先进入的缓存数据移出并放到缓存池中，然后再把新的数据添加进来。Cache里面的数据是干净的，也就是携带了原来的ViewHolder的所有数据信息，数据可以直接来拿来复用。需要注意的是，cache是根据position来寻找数据的，这个postion是根据第一个或者最后一个可见的item的position以及用户操作行为（上拉还是下拉）。
  - 举个栗子：当前屏幕内第一个可见的item的position是1，用户进行了一个下拉操作，那么当前预测的position就相当于（1-1=0），也就是position=0的那个item要被拉回到屏幕，此时RecyclerView就从Cache里面找position=0的数据，如果找到了就直接拿来复用。
  - 是ArrayList，通过setItemViewCacheSize设置缓存大小
  - 该层级缓存触发的一个常见的场景是滑动RV。当然notifyXXX也会触发该缓存。该缓存和mAttachedScrap一样特别高效
- 自定义缓存：开发者自定义缓存
- 缓存池：刚才说了Cache默认的缓存数量是2个，当Cache缓存满了以后会根据FIFO（先进先出）的规则把Cache先缓存进去的ViewHolder移出并缓存到RecycledViewPool中，RecycledViewPool默认的缓存数量是5个。RecycledViewPool与Cache相比不同的是，从Cache里面移出的ViewHolder再存入RecycledViewPool之前ViewHolder的数据会被全部重置，相当于一个新的ViewHolder，而且Cache是根据position来获取ViewHolder，而RecycledViewPool是根据itemType获取的，如果没有重写getItemType（）方法，itemType就是默认的。因为RecycledViewPool缓存的ViewHolder是全新的，所以取出来的时候需要走onBindViewHolder（）方法

四级缓存按照顺序需要依次读取。所以完整缓存流程是：

1. 保存缓存流程：
   1. 插入或是删除`itemView`时，先把屏幕内的ViewHolder保存至`AttachedScrap`中
   2. 滑动屏幕的时候，先消失的itemview会保存到`CacheView`，CacheView大小默认是2，超过数量的话按照先入先出原则，移出头部的itemview保存到`RecyclerPool缓存池`（如果有自定义缓存就会保存到自定义缓存里），RecyclerPool缓存池会按照itemview的`itemtype`进行保存，每个itemTyep缓存个数为5个，超过就会被回收。

2. 获取缓存流程：
   1. AttachedScrap中获取，通过pos匹配holder——>获取失败，从`CacheView`中获取，也是通过pos获取holder缓存——>获取失败，从`自定义缓存`中获取缓存——>获取失败，从`mRecyclerPool`中获取 ——>获取失败，重新创建`viewholder`——createViewHolder并bindview。
   2. 需要注意的是，如果从缓存池找到缓存，还需要重新bindview。

> 有了cache为啥还要有scrap，这两个不可以合成一个吗

因为屏幕是每16ms绘制一次，屏幕中的view里面的内容每次都是要更新的，所以mAttachScrap非常有必要

> RecyclerView性能优化

- 请求下来的数据如果需要处理，可异步处理后进行显示
- 分页拉取远端数据，对拉取下来的远端数据进行缓存，提升二次加载速度；对于新增或者删除数据通过 `DiffUtil` 来进行局部刷新数据，而不是一味地全局刷新数据。
- 对于`itemVIew`进行布局优化，
  - 合理设置层级
  - 通过new View()设置View，因为xml inflte是耗时IO操作
  - 复杂View或者共用部分可使用自定义View优化
- 加大`RecyclerView缓存`，比如cacheview大小默认为2，可以设置大点，用空间来换取时间，提高流畅度
- 如果不需要动画，可设置关闭动画
- 如果Item高度固定，可以设置`setHasFixedSize(true)`来避免requestLayout浪费资源，否则每次更新数据都会重新测量高度。

- 设置`RecyclerView.addOnScrollListener();`来在滑动过程中停止加载的操作。
- 减少对象的创建，比如设置监听事件，可以全局创建一个，所有view公用一个listener，并且放到`CreateView`里面去创建监听，因为CreateView调用要少于bindview。这样就减少了对象创建所造成的消耗
- 如果多个` RecycledView` 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 `RecyclerView.setRecycledViewPool(pool); `来共用一个 `RecycledViewPool`。这样就减少了创建VIewholder的开销。
- 在RecyclerView的元素比较高，一屏只能显示一个元素的时候，第一次滑动到第二个元素会卡顿。这种情况就可以通过设置额外的缓存空间，重写`getExtraLayoutSpace`方法即可。
- 用`notifyDataSetChange`时，适配器不知道整个数据集中的那些内容以及存在，再重新匹配`ViewHolder`时会花生闪烁。设置adapter.setHasStableIds(true)，并重写`getItemId()`来给每个Item一个唯一的ID，也就是唯一标识，就使itemview的焦点固定，解决了闪烁问题。

## ListView、RecyclerView区别

一、使用方面：

- 两个继承的adapter不同，一个是BaseAdapter一个是RecyclerView.Adapter
- ListView的 ViewHolder需要自己实现， RecyclerView已经弄好了，只需要继承ViewHolder
- RecyclerView 复用 Item 的工作 Google 全帮你搞定，不再需要像 ListView 那样自己调用 setTag
- RecyclerView 需要多出一步 LayoutManager 的设置工作

二、布局方面：

* RecyclerView 支持 线性布局、网格布局、瀑布流布局 三种，而且同时还能够控制横向还是纵向滚动。

三、API提供方面：

* ListView 提供了 setEmptyView ，addFooterView 、 addHeaderView.

* RecyclerView 供了 notifyItemChanged 用于更新单个 Item View 的刷新，我们可以省去自己写局部更新的工作。

四、监听 Item 的事件：

​	ListView 提供了单击、长按、选中某个 Item 的监听设置。

#RxJava 

`RxJava` 是一个 **基于事件流、实现异步操作**的库

> Rxjava是怎么实现线程切换的 https://mthli.xyz/rxjava-scheduler/

subscribeOn() 指定的就是被观察者创建的线程，只能指定一次，如果指定多次则以第一次为准

observerOn 指定的就是事件传递和观察者接收事件的线程。可指定多次，每次指定完都在下一步生效。

```
Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定
   .subscribeOn(Schedulers.io())
   .observeOn(Schedulers.newThread())
   .map(mapOperator) // 新线程，由 observeOn() 指定 
   .observeOn(Schedulers.io()) 
   .map(mapOperator2) // IO 线程，由 observeOn() 指定 
   .observeOn(AndroidSchedulers.mainThread) 
   .subscribe(subscriber); // Android 主线程，由 observeOn() 指定
```

> map关键字的作用是什么

返回结果不同: map返回的是结果集，flatmap返回的是包含结果集的Observable

转换能力：map转换时用于一对一，flatmap多用于多对多，一对多，再被转化为多个时，一般利用from/just进行一一分发，被订阅时将所有数据传递完毕汇总到一个Observable

#Eventbus源码 

https://www.jianshu.com/p/6da03454f75a

EventBus 发布/订阅事件的总线框架，基于观察者模式，将事件的接收者和发送者分开，基本包括了如下几个步骤:

​	注册事件的订阅方法:该步骤主要是找到订阅者下面有哪些方法需要被订阅

​	订阅操作:将需要被订阅的方法放到类似HashMap的数据结构中存储起来，方便后面发送事件和取消注册等资源的释放的时候使用

​	发送事件:该步骤首先遍历事件队列，然后从队列中取出事件，并且将事件从队列中移除，拿到事件后，判断事件处于的什么线程，如果是非UI线程，则需要Handler去处理，如果是的话，则直接通过反射调用被观察的方法。

​	反注册:该步骤就没什么好说的，主要是上面存储到HashMap中的被订阅的方法的移除，释放在内存中的资源。

EventBus最核心的逻辑就是利用了 subscriptionsByEventType 这个重要的列表，将订阅对象，即接收事件的方法存储在这个列表，发布事件的时候在列表中查询出相对应的方法并执行。

> 每次我们在register之后，都必须进行一次unregister，这是为什么呢？

因为register是强引用，它会让对象无法得到内存回收，导致内存泄露。所以必须在unregister方法中释放对象所占的内存。

#项目有什么难点 OK

1.在我们产品被下架的时候遇到一个问题：包上不去，上去就被封。
	最后得到一个解决方案，让谷歌感觉这是两个公司做的产品就行。
	针对这个问题我的解决方案如下：
	每个包对应一套电脑手机vpn,账号，一个服务器(后来换成了服务端提出的方案加代理，有谷歌的地方加服务器)
	代码：对应一个三方账号，代码结构，包名，类名，全部重新写,框架能换的换，不能换的重新封装，里面的字符串全部加密，混淆换字典

2.打包工具dex没处理好

3.本地定时任务  消息机制

4.数据倒灌

#介绍一下你们项目的架构 ok

这个项目的架构是Mvvm，主要使用Jetpack 组件 + Repository来搭建，Repository管理本地数据和网络数据并提供数据，ViewModel 无需关心数据的来源，也不关心UI，只需要关注数据和业务逻辑即可，activity/frgament作为View，View层订阅LiveData，当ViewModel获取到数据使用LiveData通知View更新，使View和Model完全解耦，这就是我们架构

![mvvm架构图.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/mvvm%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)



# 单元测试 Ok

> Robolectric environment 测试跟Android相关使用的框架

```
@RunWith(RobolectricTestRunner.class)
@Config(application = RoboApp.class)
public class SharedPreferenceDaoTest {

    public static final String TEST_KEY = "instrumentedTest";
    public static final String TEST_STRING = "玉刚说";

    SharedPreferenceDao spDao;

    @Before
    public void setUp() {
        //这里的Context采用RuntimeEnvironment.application来替代应用的Context
        spDao = new SharedPreferenceDao(RuntimeEnvironment.application);
    }

    @Test
    public void sharedPreferenceDaoWriteRead() {
        spDao.put(TEST_KEY, TEST_STRING);
        Assert.assertEquals(TEST_STRING, spDao.get(TEST_KEY));
    }

}
```

> Mockito framework       测试跟Android不太相关使用的框架

```
@RunWith(MockitoJUnitRunner.class)
public class UnitTestSample {
	@Mock
    Context mMockContext;

    @Test
    public void readStringFromContext_LocalizedString() {
        //模拟方法调用的返回值，隔离对Android系统的依赖
        when(mMockContext.getString(R.string.app_name)).thenReturn(FAKE_STRING);
        assertThat(mMockContext.getString(R.string.app_name), is(FAKE_STRING));
        
        when(mMockContext.getPackageName()).thenReturn("com.jdqm.androidunittest");
        System.out.println(mMockContext.getPackageName());
    }
｝
```

# 网络 Ok

##Http概念

Http：超文本传输协议.Http协议是以明文方式发送信息的

##Https概念

Http的安全版。Https的安全基础是SSL。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。

二、Http与Https的区别

1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。(网易官网是http，而网易邮箱是https。)

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。（找工作时这个答案一定要说）

4、http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接受都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

三、Https的优点

1、使用Https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。

2、Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。

3、Https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

四、Https的缺点（对比优点）

1、Https协议握手阶段比较费时，会使页面的加载时间延长近。

2、Https连接缓存不如Http高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响；

3、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

4、Https协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

##网页中输入url，到渲染整个界面的整个过程，以及中间用了什么协议

过程分析：主要分为三步

- `DNS解析`。用户输入url后，需要通过DNS解析找到域名对应的ip地址，有了ip地址才能找到服务器端。首先会查找浏览器缓存，是否有对应的dns记录。再继续按照操作系统缓存—路由缓存—isp的dns服务器—根服务器的顺序进行DNS解析，直到找到对应的ip地址。
- `客户端（浏览器）和服务器交互`。浏览器根据解析到的ip地址和端口号发起HTTP请求，请求到达传输层，这里也就是TCP层，开始三次握手建立连接。服务器收到请求后，发送相应报文给客户端（浏览器），客户端收到相应报文并进行解析，得到html页面数据，包括html，js，css等。
- `客户端（浏览器）解析html数据`，构建DOM树，再构造呈现树（render树），最终绘制到浏览器页面上。

2）其中涉及到TCP/IP协议簇，包括DNS，TCP，IP，HTTP协议等等。

> OKHttp有哪些拦截器，分别起什么作用

okhttp的拦截器就是将整个请求网络的过程的每一步都封装成不同的Interceptor

* RetryAndFollowUpInterceptor 负责失败重试和重定向
* BridgeInterceptor 负责把用户请求转换为发送到服务器的请求，并把服务器的响应转化为用户需要的响应
* CacheInterceptor 负责读取缓存、更新缓存
* ConnectInterceptor 负责和服务器建立连接
* CallServerInterceptor 负责向服务器发送数据，从服务器读取响应数据

>CacheInterceptor源码解读（继续背5）

读取候选缓存；

创建缓存策略（根据头信息，判断强制缓存，对比缓存等策略)；

根据策略，不使用网络，缓存又没有直接报错；

根据策略，不使用网络，有缓存就直接返回；

前面个都没有返回，读取网络结果（跑下一个拦截器）；

接收到的网络结果，如果是code 304, 使用缓存，返回缓存结果（对比缓存）

读取网络结果；

对数据进行缓存；

删除无效缓存；

返回网络读取的结果。

http://yydcdut.com/2019/07/10/okhttp-cache-interceptor-analyse/

> 响应码

1**	信息，服务器收到请求，需要请求者继续执行操作

2**	成功，操作被成功接收并处理

3**	重定向，需要进一步的操作以完成请求

4**	客户端错误，请求包含语法错误或无法完成请求

5**	服务器错误，服务器在处理请求的过程中发生了错误

> 网络封装怎么实现？如果让你写一个网络框架，你怎么写

如何实现一个网络框架(参考Volley)
 1.缓存队列,以url为key缓存，内容可以参考Bitmap的处理方式，这里单独开启一个线程。
 2.网络请求队列，使用线程池进行请求。
 3.提供各种不同类型的返回值的解析如String，Json，图片等等。

> 三次握手，四次挥手

客户端简称A，服务器端简称B 

1）TCP建立连接需要三次握手

- A向B表示想跟B进行连接（A发送`syn`包，A进入`SYN_SENT`状态）
- B收到消息，表示我也准备好和你连接了（B收到`syn`包，需要确认`syn`包，并且自己也发送一个`syn`包，即发送了`syn+ack`包，B进入`SYN_RECV`状态）
- A收到消息，并告诉B表示我收到你也准备连接的信号了（A收到`syn+ack`包，向服务器发送确认包`ack`，AB进入`established`状态）开始连接。

2）TCP断开连接需要四次挥手

- A向B表示想跟B断开连接（A发送`fin`，进入`FIN_WAIT_1`状态）
- B收到消息，但是B消息没发送完，只能告诉A我收到你的断开连接消息（B收到fin，发送ack，进入`CLOSE_WAIT`状态，A进入`FIN-WAIT-2`状态）
- 过一会，B数据发送完毕，告诉A，我可以跟你断开了（B发送fin，进入`LAST_ACK`状态，A进入`TIME-WAIT`状态）
- A收到消息，告诉B，可以他断开（A收到fin，发送ack，B进入`closed`状态）

TCP 协议为了实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要重发。

问题：

1. 为什么建立TCP连接需要三次握手，而关闭连接则需要四次握手
   这是由于TCP连接是全双工的，我关了你的连接，并不等于你关了我的连接（一端关闭是单方向关闭），因此双方都必须单独进行关闭。当一方完成它的数据发送任务后可以发送FIN包来终止这个方向的连接，表明自己不再有数据需要发送；收到FIN包的那一方虽然不能再读取数据，但仍能发送数据

2. 为什么连接需要三次，而不是两次。

   TCP是双向通信协议，如果两次握手，不能保证B发给A的消息正确到达

   为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
   “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用三次握手，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用三次握手的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。

3. TCP是怎么保证可靠传输的？

   序列号和确认号。比如连接的一方发送一段80byte数据，会带上一个序列号，比如101。接收方收到数据，回复确认号181（180+1），这样下一次发送消息就会从181开始发送了。

   

   

#算法的时间、空间复杂度

https://zhuanlan.zhihu.com/p/50479555

> pow(x,n)

```
class Solution {
    public double myPow(double x, int n) {
        double res = 1.0;
        for(int i = n; i != 0; i /= 2){
            if(i % 2 != 0){
                res *= x;
            }
            x *= x;
        }
        return  n < 0 ? 1 / res : res;
    }
}
```

> 快速排序

```
/*
快速排序：

1.选定一个合适的值作为主元（理想情况中值最好，但实现中一般使用数组第一个值）

2.基于这个值，将数组分为两部分，较小的分在左边，较大的分在右边。

3.可以肯定，如此一轮下来，这个主元的位置一定在最终位置上。

4.对两个子数组分别重复上述过程，直到每个数组只有一个元素。

5.排序完成。


快速排序使用分治法策略来把一个序列分为两个子序列，基本步骤为：

1.先从序列中取出一个数作为基准数；
2.分区过程：将把这个数大的数全部放到它的右边，小于或者等于它的数全放到它的左边；
3.递归地对左右子序列进行不走2，直到各区间只有一个数。
 */
 
package 排序;

public void quickSort(int[] arr, int start, int end) {
    if (start < end) {
        int p = partition(arr, start, end);//将数组分为两部分
        quickSort(arr, start, p - 1);//递归排序左子数组
        quickSort(arr, p + 1, end); //递归排序右子数组
    }
}

public static int partition(int[] arr, int left, int right) {
    int pivot = arr[left]; //主元
    while (left < right) {
        while (left < right && arr[right] >= pivot)
            right--;
        
        arr[left] = arr[right]; //交换比主元小的记录到左端
        while (left < right && arr[left] <= pivot)
            left++;
        
        arr[right] = arr[left]; //交换比主元小的记录到右端
    }
    arr[left] = pivot; //扫描完成，主元到位
    return left; //返回的是主元的位置
}
```

# 数据库

> 聊天信息表设计

表结构：

1.聊天主表

```
id(主键id)                             
user_id(用户id)                   
another_id(对方用户id)     
```

2.聊天列表表

    id(自增id)                            
    chat_id (聊天主表id)        
    user_id (用户id)                  
    another_id (对方用户id)     
    is_online (是否在线)      
    unread (未读数)         
    status (是否删除)        

3.聊天详情表

    id (自增id)                          
    chat_id (主表聊天id)        
    user_id (消息所有者id)               
    content (聊天内容)       
    time (发送时间)          
    type (消息类型)         
    is_latest (是不是最后一条消息（默认1）)         
聊天逻辑：

1. 点击聊天

判断是不是第一次聊天，如果是会在主表生成一条记录返回聊天主表id，并在聊天列表表分别插入两条记录，如果不是第一次聊天进入下一步

2. 进入聊天对话框

获取上一次聊天聊天记录，将用户在此对话的在线状态改为在线

3. 发送聊天信息
   1. 先判断对方是否在线，不在线的话对方未读数+1
   2. 将上一条最后一条消息状态改为否
   3. 往聊天详情表插入聊天信息数据

4. 删除聊天列表

将该用户的聊天列表删除状态改为删除       



