https://github.com/JsonChao/Awesome-Android-Interview/blob/master/Java%E7%9B%B8%E5%85%B3/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.md

算法：https://zhuanlan.zhihu.com/p/84230862

面试题：https://juejin.cn/post/6876968255597051917#heading-13

# Java

## equals和hashcode，他们为何必须一起重写？hashcode方法重写规则

Object中的equals是判断两个对象的地址值，hashcode是内存地址换算出来的一个哈希值。

创建两个地址值不同，字面量相同的字符串对象，如果重写了equals，这时候hashCode返回的是内存地址值。就会变成两个不等的对象。

规则：hashCode方法的重写原则就是保证equals方法认定为相同的两个对象拥有相同的哈希值

hashcode和equals的约定关系如下：

如果两个对象相等，那么他们一定有相同的哈希值（hashcode）

如果两个对象的哈希值相等，那么这两个对象有可能相等也有可能不相等



自动装箱发生在什么时候？编译期还是运行期



java和字节码有什么区别？

string,equals,==有什么区别

##方法内部的匿名内部类，比如说给View设置的OnClickListener，它里面相关调用外部方法的形参，必须使用final修饰这个形参

# 线程 O

## 自定义线程池以及线程池的工作原理

> 1.通过ThreadPoolExecutor构造线程池

ThreadPoolExecutor 线程池用于管理线程任务队列、若干个线程

构造函数

- corePoolSize： 线程池核心线程数量。核心线程一旦创建会一直执行任务或等待任务到来，而非核心线程只在任务队列塞满任务时去执行多出的任务，并且非核心线程在等待一段时间后将会被回收，这个时间是keepAliveTime参数。
- maximumPoolSize：线程池最大线程数量。最大线程数=核心线程+非核心线程
- keepAliveTime： 非核心线程的超时时长。当执行时间超过这个时间时，非核心线程就会被回收。当任务很多，每个任务执行时间很短的情况下调大该值有助于提高线程利用率。注意：当allowCoreThreadTimeOut属性设为true时，该属性也可用于核心线程。
- unit： 线程池维护线程所允许的空闲时间的单位
- workQueue： 线程池所使用的任务队列
- threadFactory：线程池用于创建线程
- handler： 线程池对拒绝任务的处理策略

> 2.通过Executors构造线程池

```
ExecutorService executorService = Executors.newCachedThreadPool();
```

* newCachedThreadPool：底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)；通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。**适用：执行很多短期异步的小程序或者负载较轻的服务器**
* newFixedThreadPool：底层：返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列；通俗：创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不再添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)**适用：执行长期的任务，性能好很多**
* newSingleThreadExecutor:*底层：FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列；通俗：创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)**适用：一个任务一个任务执行的场景**
* newScheduledThreadPool:底层：创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列；通俗：创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构**适用：周期性执行任务的场景**



如何让两个线程循环交替打印

怎么中止一个线程，Thread.Interupt一定有效吗？

线程间同步的方法

#锁和并发 O

##ReentranLock跟synchronized有什么区别？synchronized与ReentranLock发生异常的场景？

> 相同

都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待

> 不同

1. API层面

   * synchronized是关键字，是原生语法层面的互斥，需JVM实现。ReentranLock是1.5之后API提供的

   * synchronized可以修饰方法和代码块,Reentranlock只能在方法内使用

2. 等待可中断

   * 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，去处理别的事情
   * 假如业务代码中有两个线程，Thread1 Thread2。假设 Thread1 获取了对象object的锁，Thread2将等待Thread1释放object的锁。
     - 使用synchronized。如果Thread1不释放，Thread2将一直阻塞等待，不能被中断。
     - 使用ReentrantLock。如果Thread1不释放，Thread2等待了很长时间以后，可以中断等待，转而去做别的事情。

3. 公平锁

   * 公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序获取锁，而非公平锁则是任何一个等待的线程都可以获取锁
   * synchronized是非公平锁，ReentranLock默认是非公平锁，但可以通过构造函数设置True使用公平锁

```
private ReentrantLock lock = new ReentrantLock();
public void run() {
    lock.lock();
    try{
        for(int i=0;i<5;i++){
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }finally{
        lock.unlock();
    }
}
```

> synchronized与ReentranLock发生异常的场景

发生异常的场景我查了半天没查到，应该就是线程抛出异常吧

在发生异常时，synchronized会自动释放锁，ReentranLock则需要与try{}finally{}搭配手动释放锁

##synchronized是公平锁还是非公平锁,ReentranLock是公平锁吗？是怎么实现的

synchronized是非公平锁，ReentranLock默认是非公平锁，但可以通过构造函数设置True使用公平锁

>ReentranLock是怎么实现的

文章： https://juejin.cn/post/6844903805683761165

ReentranLock是基于 AQS来实现的。 是一个重入锁：一个线程获得了锁之后仍然可以反复的加锁，不会出现自己阻塞自己的情况。

AQS内部实现了两个队列，分别是同步队列和条件队列。其中同步队列是一个双向链表，里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而条件队列是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，AQS所做的就是管理这两个队列里面线程之间的等待状态-唤醒的工作。

##synchronized底层原理是什么

文章：https://juejin.cn/post/6844903670933356551#comment

Synchronized经过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。

> 静态方法与普通方法加synchronized有什么区别 

普通方法是对调用该方法的对象加锁，静态方法是对该方法所在的类加锁

> synchronized能不能继承？

父类方法中有synchronized关键字修饰，子类继承该父类的方法也有Synchronizde关键字的效果，但是如果重写该方法时不显式加上synchronized关键字时则不会有效果



synchronized实现。非静态方法A和B在同一个类中，方法A用synchronized修饰，当A方法因为多线程请求有线程阻塞在对象锁上的时候，B方法的访问受不受影响？

##volatile字段有什么用途？

> synchronized和volatile的区别

volatile 本质是在告诉jvm当前变量在寄存器中的值是不确定的，需从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其它线程被阻塞住。
区别

1.volatile 仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。

2.volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性。

3.volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。

4.volatile 标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。

> voliate原理

Java内存模型规定了所有字段（这些字段包括实例字段、静态字段等，不包括局部变量、方法参数等，因为这些是线程私有的，并不存在竞争）都存在主内存中，每个线程会  有自己的工作内存，工作内存里保存了线程所使用到的变量在主内存里的副本拷贝，线程对变量的操作只能在工作内存里进行，而不能直接读写主内存，当然不同内存之间也 无法直接访问对方的工作内存，也就是说主内存是线程传值的媒介。



关键字 `volatile` 可以说是 Java 虚拟机提供的最轻量级的同步机制。

当一个变量定义为 `volatile` 之后，它将具备两种特性，

1. 保证此变量对所有线程是可见的，当一条线程修改了这个变量的值后会被强制写回主内存，其他线程在使用时也会强制从主内存刷新。

   - 原理

     1. Lock 前缀的指令会引起处理器缓存（工作内存）写回内存（共享内存）；
  2. 一个处理器的缓存回写到内存会导致其他处理器的缓存失效；
     3. 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。

   - 但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的，所以在不符合以下两条规则的运算场景中，我们仍然要通过加锁（synchronized）来保证原子性。
   
     1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。

        ```
        
        ```

    volatile boolean shutdownRequested；
         
    public void shutdown(){
         	shutdownRequested = true；
    }
         
      public void doWork(){
         	while（!shutdownRequested）{
      		//dostuff
         	}
         }
        ```
     
     2. 变量不需要与其他的状态变量共同参与不变约束。

2. 禁止指令重排序优化

   - 什么是指令重排序？

     - 指令重排序是指指令乱序执行，即在条件允许的情况下直接运行当前有能力立即执行的后续指令，避开为获取一条指令所需数据而造成的等待，通过乱序执行的技术提供执行效率。
  - 指令重排序会在被volatile修饰的变量的赋值操作前，添加一个内存屏障，指令重排序时不能把后面的指令重排序移到内存屏障之前的位置。

  

#HashMap的原理 

HashMap添加元素的过程，hash方法细节；扩容的触发条件、扩容过程中是数据是整体复制么？链表转红黑树的阈值为何是8，红黑树转链表的阈值为何是6，为何不上同一个阈值？链表为何要转红黑树？红黑树有何特性？hashmap为何如此设计？

数据结构、hash过程、扩容、加载因子为何是0.75等

讲下hashmap；链表转红黑树的限制为何是8；红黑树的时间复杂度；红黑树转链表的限制为何是6；current hashmap在所有情况下都是线程安全的吗？hashtable呢？

文章：https://www.jianshu.com/p/dde9b12343c1

```
问题：
HashMap是通过对 key 的 hash 值进行转换来定位每个 key 在内部数组上的位置。HashMap 是实现原理是数组 + 链表，Java 1.8 以后加入了红黑树。
Key的Hash值计算

第一步：正常计算出 key 的 hash 值（调用 key 的 hashCode() 方法，如果 key 是 null 则其 hash 值是0）； 第二步：对得到的 hash 值进行扰乱，目的是为了让 hash 值能尽可能的均匀分布。
问题

1. 为什么不直接使用 key 而要使用 key 的 hash 值？

答：考虑到效率问题如果直接使用 key，那么在查找的时候需要调用 key 的 equals() 方法去逐个比较，时间复杂度从原本的 O(1) 变成了 O(n) ，且 equals() 比较的效率也很低，而通过 hash 值可以直接定位到桶。

2. 那为什么又不直接用 hash 值作为数组上的索引？

答：为了防止数组下标越界，因为 hash 值不确定性，很容易越界。

3. 索引为什么用的是 (n - 1) & hash，而不是 hash % n 呐？

答：其实早期版本就是用 hash % n，但是为了追求效率，后来就改成了位运算 (n - 1) & hash（位运速度比取余算快，注意：%是取余不是取模）， 当 n 为 2 的指数，(n - 1) & hash 与 hash % n是等价的

4. 为什么 (n - 1) & hash 和 hash % n 是等价的？

答：这里利用了 HashMap 的一个特性：HashMap 规定其容量必须是 2 的 n 次方（最大为 230 次方）,那么 n 肯定就是 2xx 次方了，用二进制表示就是 1000...00，最前面是 1，后面全是 0（假设有k个0），那么 n-1 就全变成 1 了 111...1111（k-1个1），hash ^ (n - 1) 得到的最大值就是 n-1，最小值是 0。效果和hash % n 一样，只是改为位运算了。位运算比取模运算更快。

5. 为什么 HashMap 的容量是 2 的幂次方（参考问题 4）

答：是为了 hash 值的计算，早期版本的 hash 值计算是 hash % n，来得到一个数组范围内的 hash 值，而当容量为2的幂次方（其二进制永远是100.....，再减去1，就是全部都是11111，方便做与运算），通过 (n - 1) & hash 来计算哈希值，会更加效率。


```

## Android里面的LRUCache是如何实现的

LinkedHashMap LinkedHashMap的数据结构

#泛型有什么优点？ O
1. 保证类型安全性
	1. list<integer> arraylist 一个只能存放int,一个啥都可以存，编译的时候不会报错
2. 避免了强制转换，提高了性能
3. 代码观看清晰条理

##泛型擦除，为何会有擦除？擦除的时机。通配符

> 反射可以反射final修饰的字段吗

在编译阶段，所有泛型类的类型参数都会被Object或者它们的限定边界来替换

# JVM类加载机制&垃圾回收 O

## JVM类加载机制了解吗，类什么时候会被加载？类加载的过程具体生命周期是怎样的？

> 类加载机制

JVM把类数据从Class文件加载到内存，并对数据进行校验，最终形成可以被JVM直接使用的字节码的过程就是类加载机制

object o =new object() 主要包括三个阶段：

1. 通过不同的类加载器加载，
2. 当类被加载之后，进行验证，只要包括：文件格式验证，元数据验证，字节码验证，符号引用验证；
3. 为类的静态变量分配内存；

> 什么时候被加载

Java虚拟机没有明确规定一个类在什么时候会被加载，但是它严格规定了只有以下6种情况必须对类进行初始化操作，在初始化操作之前必定会触发类的加载和连接

1. 遇到`new`、`getstatic`、`putstatic`、`invokestatic`这四条字节码指令时
   1. 使用`new`关键字实例化对象时；对应`new`字节码指令
   2. 读取或设置一个类的静态字段（被`final`修饰的、在编译期把结果放入常量池的静态变量除外）时；对应`getstatic`和`putstatic`字节码指令
   3. 调用一个类的静态方法时；对应`invokestatic`字节码指令
2. 使用`java.lang.reflect`包的方法**第一次**对类进行**反射调用**时会触发类的初始化

> 生命周期

Java类从加载到内存到移除，它的整个生命周期分为：

1. 加载：加载Class文件到内存
2. 验证：验证文件格式、元数据、字节码、符号引用
3. 准备：为类变量赋初始值
4. 解析：引用替换、字段解析、接口，方法解析
5. 初始化：1.执行静态代码块 2.为类变量赋值
6. 使用：对象实例化
7. 卸载：GC

> DexClassLoader与PathClassLoader的区别



##垃圾回收机制与jvm结构，老年代算法，方法区有啥，GCRoot都有啥 

    这篇文章写得挺好挺全的  https://juejin.im/post/6844903905457864718

>jvm内存结构

![Jvm内存结构.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/Jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png?raw=true)

* GC、虚拟机栈，本地方法栈是线程私有区域，其生命周期和线程相同；方法区和堆是线程共享区域，生命周期跟虚拟机相同，
* 除pc之外，别的区域都有可能造成OOM

1. 程序计数器 :指向当前线程所执行的字节码的行号
2. 虚拟机栈：主要描述方法执行，每个方法在执行的时候创建一个栈帧，其中栈帧中存储了函数中定义的基本数据类型变量以及对象的引用变量(局部变量表，操作数栈，动态链接，方法出口等信息)。每一个方法从调用到执行结束，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
3. 本地方法栈：虚拟机栈执行java方法；本地方法栈执行native方法。比如java中调用C或C++中的方法，在这里执行。
4. 堆：创建的对象与数组都保存在java堆内存中，因为是线程共享，所以与方法区两个是垃圾收集的区域，java堆中从GC的角度细分为：新生区与老年区。
5. 方法区：用于存储被jvm加载的类信息、常量、静态变量、编译器编译后的代码等数据
   1. 实现类似堆的永久代实现，GC算法也一样，GC主要用于常量池和无用的类的回收
   2. Class文件包括 1.类信息包括类的版本，字段，方法，接口等描述信息 2.常量池

> 如何判断一个对象需要被回收

不再使用的对象需要进行回收，不使用的类也有可能回收。

通过两个方法来判断对象不再被使用：

1. 引用计数法: 给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减一；任何时刻计数器为0的对象就是不会被使用的对象。

2. GC root: 以GC Root的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到“GC Roots”没有任何引用链相连的时候，就证明此对象是不可用的

>可以作为GC root对象包括：

* 虚拟机栈（栈帧中的本地变量表）中的引用对象。
* 方法区中的静态属性或常量（final）引用的对象。
* 本地方法栈中Native方法引用的对象。

>垃圾回收机制

垃圾回收机制采用的是分代收集。根据根据对象存活的不同年龄划分不同的域。

* 新生代：复制算法
  * 新生代分为Eden和两块Survivor,比例为8：1：1，每次使用Eden和其中一块Survivor空间，当进行回收时，将两块空间中还存活的对象复制到另一块Survivor空间中。如果存活的某对象的空间>Survivor空间，则将对象移到老年代
  * GC触发条件：当要申请的空间>Eden和其中一块Survivor剩余的空间时，会发生GC
  * 当对象在Survivor躲过一次GC，其年龄会+1，默认情况下当年龄到达15时，会被移到老年代
  * 因为新生代对象的特点是生命周期短，存活率低，所以采用复制算法。一般的复制算法每次只能使用一半的空间，这个是全部空间
* 老年代：标记清除算法或者标记整理算法
  * GC触发条件：
    * 显式调用System.gc()方法
    * 老年代空间不足
    * 从新生代进入老年代的空间大于老年代空闲空间
  * 因为存活对象多，所以采用标记复制算法

垃圾回收算法：

1. 标记-清除算法：首先标记出存活的对象，在标记完成后会对未标记的对象进行回收   
   1. 缺点：碎片多；虚拟机在给内存较大对象分配空间时，有可能找不到足够大的连续空间存放，从而引发垃圾回收动作。实际上有大量空闲空间，只是不连续；
2. 复制算法：将内存分为两块大小一样的区域，每次是使用其中的一块。当这块内存块用完了，就将这块内存中还存活的对象复制到另一块内存中，然后清空这块内存。
   1. 可用内存小
3. 标记-整理算法：标记过程与标记-清除算法一样，接下来让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
   1. 仍需要进行局部对象移动，一定程度上降低了效率

# 内存泄漏 O

> 什么时候会发生内存泄漏

- 集合类泄漏
- 单例/静态变量造成的内存泄漏
- 匿名内部类/非静态内部类
- 资源未关闭造成的内存泄漏

> 如何分析解决

使用库，比较出名的就是`LeakCanary`，导入库，然后运行后，就可以发现app内的内存泄漏情况。

原理：

在一个Activity执行完onDestroy()之后，将它放入WeakReference中，然后将这个WeakReference类型的Activity对象与ReferenceQueque关联。这时再从ReferenceQueque中查看是否有该对象，如果没有，执行gc，再次查看，还是没有的话则判断发生内存泄露了。最后用HAHA这个开源库去分析dump之后的heap内存。

fragment监控是在onDestoryView和onDestory监控的

通过`WeakReference` + `ReferenceQueue`来判断对象是否被系统GC回收，WeakReference 创建时，可以传入一个 ReferenceQueue 对象。当被 WeakReference 引用的对象的生命周期结束，一旦被 GC  检查到，GC 将会把该对象添加到 ReferenceQueue 中，待ReferenceQueue处理。当 GC 过后对象一直不被加入  ReferenceQueue，它可能存在内存泄漏。



#编译期注解处理的是字节码还是java文件 O

应该是处理的Java文件，然后生成字节码

APT即为Annotation Processing Tool，它是javac的一个工具，中文意思为编译时注解处理器。APT可以用来在编译时扫描和处理注解。通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来自动的生成一些代码，省去了手动编写。注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。APT的核心是AbstractProcessor类。

ButterKnife，eventbus都使用了APT技术

#设计模式 O

##你在项目中有用到什么设计模式吗

> 单例

工具类封装、GlideEnger

```
懒汉：
public class Singleton {
    private volatile static Singleton instance = null;

    private Singleton() {
    }
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

```
饿汉：
public class Singleton2 {

    private static final Singleton2 instance = new Singleton2();

    private Singleton2() {
    }

    public static Singleton2 getInstance() {
        return instance;
    }
}

静态内部类

public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}
```

> 抽象工厂模式：一个具体的工厂类负责创建一系列相关的对象

BaseActivity



单例模式有什么缺点？

## 动画里面用到了什么设计模式

将一系列的算法封装起来，方便替换，实例：动画的时间插值器

##代理模式与装饰模式的区别，手写一个静态代理，一个动态代理,动态代理有什么用

>代理模式:

Java动态代理的优势是实现无侵入式的代码扩展，也就是方法的增强；让你可以在不用修改源码的情况下，增强一些方法；在方法的前后你可以做你任何想做的事情


1. 静态代理

想要生成代理类，需要让代理类和被代理类实现同一个接口，并且在代理类中添加被代理类的引用，代理类方法实现中添加代理逻辑，并决定是否调用被代理类方法，这种通过硬编码的方式指定代理类与被代理类的方式，叫静态代理。可以明显看出，**静态代理类与被代理类是耦合的，如果要代理100个类，你就得写100个代理类**

代码：

    public class RealTest{
    	public void doSomthing(){
    		system.out.print("原生方法");
    	}
    }
    
    public interface Test{
    	public void doSomthing();
    }
    
    public class TestProxy implements Test {
      Test t = new RealTest();
      public void doSomething() {
         t.doSomething();
      }
    }
刚开始我会觉得TestProxy定义出来纯属多余，直接实例化实现类完成操作不就结了吗？后来随着业务庞大，你就会知道，实现proxy类对真实类的封装对于粒度的控制有着重要的意义。但是静态代理这个模式本身有个大问题，如果类方法数量越来越多的时候，代理类的代码量是十分庞大的。所以引入动态代理来解决此类问题

3.动态代理

其实动态代理与静态代理的本质一样，最终程序运行时都需要生成一个代理对象实例，通过它来完成相关增强以及业务逻辑，只不过静态代理需要硬编码的方式指定，而动态代理则是以动态方式生成代理(编译时操作字节码以及运行时通过反射方式)。动态生成的好处很明显，代理逻辑与业务逻辑是互相独立的，没有耦合，代理1个类100个类没有任何区别

代码：

	public interface Subject   
	{   
	  public void doSomething();   
	}
	
	public class RealSubject implements Subject   
	{   
	  public void doSomething()   
	  {   
	    System.out.println( "call doSomething()" );   
	  }   
	}  
	
	public class ProxyHandler implements InvocationHandler
	{
	    private Object tar;
	
	    //绑定委托对象，并返回代理类
	    public Object bind(Object tar)
	    {
	        this.tar = tar;
	        //绑定该类实现的所有接口，取得代理类 
	        return Proxy.newProxyInstance(tar.getClass().getClassLoader(),
	                                      tar.getClass().getInterfaces(),
	                                      this);
	    }    
		@Override
	    public Object invoke(Object proxy , Method method , Object[] args)throws Throwable
	    {
	        Object result = null;
	        //这里就可以进行所谓的AOP编程了
	        //在调用具体函数方法前，执行功能处理
	        result = method.invoke(tar,args);
	        //在调用具体函数方法后，执行功能处理
	        return result;
	    }
	}
	public class TestProxy
	{
	    public static void main(String args[])
	    {
	           ProxyHandler proxy = new ProxyHandler();
	           //绑定该类实现的所有接口
	           Subject sub = (Subject) proxy.bind(new RealSubject());
	           sub.doSomething();
	    }
	}

Proxy类的代码量被固定下来，不会因为业务的逐渐庞大而庞大；可以实现AOP编程，实际上静态代理也可以实现，总的来说，AOP可以算作是代理模式的一个典型应用；解耦，通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。

>代理模式与装饰模式的区别

**装饰器模式应当为所装饰的对象提供增强功能，而代理模式对所代理对象的使用施加控制，并不提供对象本身的增强功能**。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

##AOP
传统面向对象思想中，如果想要实现功能复用，要么继承、要么引用，无论哪种方式，对代码都有一定的侵入性，耦合无可避免，侵入性啥意思？简单来说：如果你想要用它增强你程序的功能，你必须改动你的程序代码，那它就具有侵入性。如果只有一点两点需要增强还好说，如果大量的功能点需要被增强，工作量就会很大，代码也不太优雅。想象一下，如果你对外公开了一系列的接口，现在领导说了，接口要加权限控制。在哪加？最笨的当然就是写个程序验证的逻辑，然后每个接口都拿来调用一遍。这也正是面向对象思想的短板，在要为程序新增一些通用功能时，只能通过耦合的方式才能进行。AOP正是为此而生，AOP旨在通过一种无耦合的方式来为程序带来增强。而动态代理，就是AOP实现方式中的一种

# 软引用、弱引用、强引用、虚引用的区别 O

* 强引用:直接new出来的对象;强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象。。

  ```
  String str = new String(“yc”);
  ```

* 软引用 ：如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。

  ```
  MyObject aRef = new  MyObject();
  SoftReference aSoftRef = new SoftReference(aRef);
  MyObject anotherRef = (MyObject)aSoftRef.get();
  ```

  可用来处理图片这种占用内存大的情况

* 弱引用：在垃圾回收器扫描的过程中，一旦发现了弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。  
  * 防止内存泄漏
  * 使用频率高的用软引用，使用频率低的用弱引用
* 虚引用：虚引用随时都可能被垃圾回收器回收。

---

#activity

##Activity与AppCompactActivity区别，Activity会打包到包里面去吗？

Fragment hide show生命周期变化

19.Fragment replace生命周期变化

##启动模式 O

启动模式（launchMode）在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例共用一个task。

> Activity一共有以下四种launchMode：

1. standard 标准启动模式
   * 默认的启动模式，每次启动activity都会创建新的实例。
2. singletop 栈顶复用模式  适合接收通知启动的内容显示页面
   * 当栈顶有将要开启的Activity时，会复用这个Activity，同时这个activity的onNewIntent方法会被回调。这个activity的onCreate方法不会被调用，因为它没有发生改变。若是栈顶没有，那么就会重新创建
   * 应用场景：适用于接收到消息后显示的界面。例如：QQ接收到消息后会弹出activity，但如果一次来10条消息，总不能一次弹出10个activity。  

3. singetask栈内复用模式，在当前任务栈里面只能有一个实例存在 适合作为程序入口点

   * 当一个启动模式为singleTask的activityA请求启动后，系统会先寻找是否存在A想要的任务栈（在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在），如果不存在，就重新创建一个任务栈，然后创建A的实例并将A放到栈中。如果存在A所需的任务栈，这时要看栈中有是否有要开启的activityA，如果有则直接复用并删除A上面的activity，将A移动到栈顶，同singletop一样，也会回调这个activity的onNewIntent方法。如果没有实例，则创建A实例并压入栈中

   * 现在有两个任务栈，前台任务栈中有BA，后台任务栈中有DC，假设DC启动启动模式都为singleTask。现在请求启动D，那么整个后台任务栈都会被切到前台，这时候前台任务栈为DCBA，当按back键时，前台栈中activity会一一出栈；如果请求启动C，那么情况就不一样了，会把D删除,C切换到前台。（具体看图——singleTask启动模式特例.pptx）
   * 所以这种启动模式通常可以用来退出整个应用程序。将主activity设为singleTask,然后在要退出的activity中转到主Activity，从而将主Activity上的其他activity全部清除，然后在主Activity中的onNewIntent()中加上finish(),将最后一个activity结束。

4. singleInstance 单实例模式，可以看作加强版singleTask模式

   * activity会开启一个新的任务栈，并且这个任务栈里面只有一个实例存在。
* 这种启动模式和浏览器的工作原理类似。当多个程序访问浏览器时，如果浏览器没有打开，则打开浏览器，否则会在当前打开的浏览器中访问。举个例子来说，当应用A的任务栈创建了ActivityA实例，并且其启动模式为sinleInstance，如果应用B也要激活ActivityA，则不需要创建，两个应用共享即可。    
   * 如果你要保证一个activity在整个手机操作系统里面只有一个实例存在，使用singleInstance
   * 关于singleInstance这种启动模式还有一点需要特殊说明:如果在一个singleInstance的activityA中通过startActivityForResult()去启动另一个activityB，那么在A中拿不到数据。因为android不允许task间互相传递数据。
   2. 以singleInstance模式启动的Activity在整个系统中是单例的，如果再启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。
   4. singleInstance模式的Activity开启的其他activity，新Activity会存放到已有的任务栈中(如果没设置新的任务栈的话)。

> onNewIntent()

通过这个方法可以取出当前请求的信息
第一次创建Activity A时，执行的逻辑顺序是：
    onCreate() ­­­>onStart()­­­>onResume()
而如果使用singleTask模式第二次启动Activity A，且A处于任务栈的顶端，则执行的逻辑顺序是：
    onNewIntent() ­­­>onRestart> onStart>onResume()。 
注意，getIntent()仍返回原来的意图。你可以使用setIntent来设置新的意图。

> FLAG

* FLAG_ACTIVITY_SINGLE_TOP：与launchMode = "singleTop"行为一致

* FLAG_ACTIVITY_NEW_TASK：如果设置taskAffinity，系统会查找有没有相应的栈存在，如果存在将Activity压入栈中，如果不存在，将Activity压入默认栈中

* FLAG_ACTIVITY_CLEAR_TOP：如果目标存在，直接复用，并清除目标以上的活动，否则重建。
* FLAG_ACTIVITY_NEW_TASK和FLAG_ACITIVTY_CLEAR_TASK = singleTask

# onCreate,onResume,onStart里面，什么地方可以获得宽高 O

如果在`onCreate、onStart、onResume`中直接调用View的`getWidth/getHeight`方法，是无法得到View宽高的正确信息，因为view的measure过程与Activity的生命周期是不同步的，

onCreate创建 DecorView ，onResume添加 DecorView 到 WindowManager，这时候都没有调用View的measure流程，所以视图宽高是获取不到的

有以下三个方法来获取view的宽高：

- view.post()方法

- onWindowFocusChanged() 

  - ```
    当 Activity 获取和失去焦点的时候
    override fun onWindowFocusChanged(hasFocus: Boolean) {  
        super.onWindowFocusChanged(hasFocus)
        if (hasFocus){
            ...
        }
    }
    ```

    

- OnGlobalLayoutListener

  - ```
    当 View 树发生状态变化时
    view.viewTreeObserver.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener{
        override fun onGlobalLayout() {
            binding.dialog.viewTreeObserver.removeOnGlobalLayoutListener(this)
            ...
        }
    })
    ```

> View 在什么时间点被测量

WindowManager添加decorView的时候回调ViewRootImpl.setView()，在setView方法中调用requestLayout()发起绘制流程

> 为什么view.post可以获得宽高

根据 ViewRootImpl 是否已经创建，View.post() 会执行不同的逻辑。如果 ViewRootImpl 已经创建，即 mAttachInfo 已经初始化，直接通过 Handler 发送消息来执行任务。如果 ViewRootImpl 未创建，即 View 尚未开始绘制，会将任务保存为 HandlerAction，暂存在队列 HandlerActionQueue 中，等到 View 开始绘制，执行 performTraversal() 方法时，在 dispatchAttachedToWindow() 方法中通过 Handler 分发 HandlerActionQueue 中暂存的任务。

文章：https://juejin.cn/post/6895735092438630407#heading-2

# 启动流程

##APP启动流程

在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。



当冷启动 (应用进程不存在) 一个 app 时，首先要和 zygote 建立 socket 连接，将创建进程需要的参数发送给 zygote， zygote 服务端接收到参数之后调用 `ZygoteConnection.processOneCommand()` 处理参数，并 fork 出应用进程。最后通过 `findStaticMain()` 找到 `ActivityThread` 类的 `main()` 方法并执行，应用进程就启动了。

`ActivityThread` 虽然不是一个线程类，但它是运行在主线程的，你就把它认为是主线程也没有关系。在 `main()` 方法中， 创建了 `ActivityThread` 对象，调用其 `attach()` 方法，并开启了主线程消息循环，基于事件的消息队列机制就开始工作了。

在 `ActivityThread.attach()` 方法中，Binder 调用了 `AMS.attachApplication()` 方法，其中主要做了两件事：

1. 将当前进程与 AMS 进行绑定。然后再 Binder 调用回应用进程的 `ApplicationThread.bindApplication()` 方法，进行客户端的准备工作，创建 Context，创建 Application 等等
2. `mStackSupervisor.attachApplicationLocked(app)`，最终调用到 `realStartActivityLocked()` 启动 Activity

> 说说App的启动过程,在ActivityThread的main方法里面做了什么事，什么时候启动第一个Activity？

##Activity启动流程

1. `Luancher` 进程通过binder向AMS发起`startActivity`请求
2. AMS收到请求， `ActivityStarter`解析flag，启动模式等，`ActivityStack`处理activity栈
3. 然后AMS通过socket调用到`Zygote`，fork新的app进程
4. app进程创建后，再通过binder向AMS发起`attachApplication`请求
5. AMS通过binder调用发送`scheduleLaunchActivity`到app进程
6. APP进程的binder线程`ApplicationThread`接收到请求，通过handler发送`LAUNCH_ACTIVITY`消息到主线程
7. `ActivityThread`接收到消息，执行到`handleLaunchActivity`，开始Activity的生命周期

##APP打包经过了哪几个流程

- 打包资源文件，通过AAPT(Android Asset Packaging Tool)打包成R.java类(资源索引表)以及.arsc资源文件。
- 处理AIDL文件，检查app中是否有aidl文件，如果有会通过aidl工具(源码位于system/tools/aidl）打包成java接口类
- 编译R.java源码部分以及aidl.java通过javac生成对应的.class文件。
- 将上面生成的.class文件和第三方jar或者library通过dx工具打包生成dex文件。
- 生成未签名的apk，包括apkbuilder工具将所有没有编译的资源、.arsc资源、.dex文件打包到一个完成apk文件中
- 生成签名的apk，包括jarsigner工具对未签名的apk验证签名。得到一个签名后的apk（signed.apk）
- zipAlign工具对齐上面签名的apk文件。

# intentService O

intentService可以异步运行一个任务并在结束时自行终止。需要在一个单独的线程中执行的代码可以放在onHandleIntent()中，如从服务器下载数据，当代码执行完毕，线程被终止，服务自行停止。

是通过HandlerThread来实现耗时操作的

> HandlerThread

`HandlerThread`继承Thread，内置了Handler和Looper，在run方法中创建了looper对象，这也是为什么在IntentService中能在HandlerThread中直接用handler的原因。

# 广播与RxBus的区别，全局广播与局部广播区别 O

本地广播：广播事件的发送和接收都在本应用，不能跨进程(APP内部进程也不能跨)，只能动态注册，不能静态注册--使用Handler通信机制

全局广播：广播事件的发送和接收都在本应用可以跨应用，全局广播既可以动态注册，也可以静态注册--采用的binder方式实现跨进程间的通信

广播是四大组件之一，可以直接获取上下文，比较消耗资源，Rxbus不能跨进程，耦合性低，比广播更轻量，书写简便。可实现粘性事件

#attachToWindow什么时候调用？ O

attachToWindow在onResume之后调用，onDetachFromWindow() 在页面退出的时候都会被调用

```
MainActivity打开
MainActivity: onCreate
MainActivity: onStart
MainActivity: onResume
MainActivity: onAttachedToWindow
MainActivity: onViewAttachedToWindow(界面View设置的监听)
点击home键
MainActivity: onPause
MainActivity: onStop
恢复展示
MainActivity: onRestart
MainActivity: onStart
MainActivity: onResume
关闭
MainActivity: onPause
MainActivity: onStop
MainActivity: onDestroy
MainActivity: onViewDetachedFromWindow
MainActivity: onDetachedFromWindow


MainActivity打开
MainActivity: onCreate
MainActivity: onStart
MainActivity: onResume
MainActivity: onAttachedToWindow
MainActivity: onViewAttachedToWindow
SecondActivity打开
MainActivity: onPause
SecondActivity: onCreate
SecondActivity: onStart
SecondActivity: onResume
SecondActivity: onAttachedToWindow
MainActivity: onStop
SecondActivity关闭
SecondActivity: onPause
MainActivity: onRestart
MainActivity: onStart
MainActivity: onResume
SecondActivity: onStop
SecondActivity: onDestroy
SecondActivity: onDetachedFromWindow
```

# 图片相关

大图加载；xhdpi的图片放到xxhdp的手机上，内存会如何变化；Bitmap内存复用？

> bitmap内存计算

素数据的内存=图片宽 x 图片高 x 单个像素内存大小

#setOnTouchListener,onClickeListener和onTouchEvent的关系 O

setOnTouchListener-onTouch
onClickeListener-onClick

onTouch在dispatchTouchEvent()方法中调用

    public boolean dispatchTouchEvent(MotionEvent event) {      
    	if (onFilterTouchEventForSecurity(event)) {        
    		if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
                		result = true;        
    		}        
    		if (!result && onTouchEvent(event)) {
    	            result = true;        
    		}   
    	}     
    	return result;
    }

当设置了setOnTouchListener(),li和mOnTouchListener会被初始化，不为null，前两个条件成立，所以当onTouch()方法返回值为true，就不会执行onTouchEvent(event)方法，返回false会执行。

接下来看onTouchEvent的源码

	public boolean onTouchEvent(MotionEvent event) {
	     if (((viewFlags & CLICKABLE)  ==  CLICKABLE  ||(viewFlags & LONG_CLICKABLE)  ==  LONG_CLICKABLE) 
	        || (viewFlags & CONTEXT_CLICKABLE)  ==  CONTEXT_CLICKABLE) {
	           switch (action) {
	               case MotionEvent.ACTION_UP:                           
	                //如果执行了该方法，其返回值就是onTouchEvent()的返回值                
	                performClick();                             
	                break;        
	            }        
	        return true;    
	    }    
	    return false;
	}
在performClick方法中调用了mOnClickListener.onClick(this)方法。只要我们在代码中通过 setOnClickListener() 方法设置了对单击事件的监听，则对应 View 的 onTouchEvent() 方法返回 true，当然事件就此消费，反之返回 false
>总结：

onTouch() 方法的返回值决定了 onTouchEvent() 方法要不要执行，如果 onTouch() 返回 true，则 onTouchEvent() 不会再执行，返回 false ,则 onTouchEvent() 继续执行，而 onClick() 的回调是在 onTouchEvent() 方法中调用，onTouchEvent() 不执行则 onClick() 不执行。

#事件分发机制

![事件分发机制.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6.png?raw=true)

View事件分发是对MotionEvent的分发，最终传递给一个View的过程。view的分发事件是从`Viewgroup#dispatchTouchEvent`到`Viewgroup#onInterceptTouchEvent`再到`View#dispatchTouchEvent`，然后到view的`onTouchEvent`，最后又回到了`Viewgroup(Parent)#onTouchEvent`

方法解释：

* dispatchTouchEvent：方法返回值为true表示事件被当前视图消费掉；返回为super.dispatchTouchEvent表示继续分发该事件，返回为false表示交给父类的onTouchEvent处理。

* onInterceptTouchEvent：方法返回值为true表示拦截这个事件并交由自身的onTouchEvent方法进行消费；返回false表示不拦截，需要继续传递给子视图的dispatchTouchEvent。如果return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: 　
  * 1.如果该View存在子View且点击到了该子View, 则不拦截, 继续分发 给子View 处理, 此时相当于return false。
  * 2.如果该View没有子View或者有子View但是没有点击中子View(此时ViewGroup 相当于普通View), 则交由该View的onTouchEvent响应，此时相当于return true。 ？

* onTouchEvent：方法返回值为true表示当前视图可以处理对应的事件；返回值为false表示当前视图不处理这个事件，它会被传递给父视图的onTouchEvent方法进行处理。如果return super.onTouchEvent(ev)，事件处理分为两种情况：
  * 1.如果该View是clickable或者longclickable的,则会返回true, 表示消费 了该事件, 与返回true一样;
  * 2.如果该View不是clickable或者longclickable的,则会返回false, 表示不 消费该事件,将会向上传递,与返回false一样。

注意：在Android系统中，拥有事件传递处理能力的类有以下三种：

- Activity/View：拥有分发和消费两个方法。
- ViewGroup：拥有分发、拦截和消费三个方法。

一些重要的结论：

1、事件传递优先级：onTouchListener.onTouch > onTouchEvent > onClickListener.onClick。

2、正常情况下，一个事件序列只能被一个View拦截且消耗。因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不会再调用这个View的拦截方法去询问它是否要拦截了，而是把剩余的ACTION_MOVE、ACTION_DOWN等事件直接交给它来处理）。

4、ViewGroup默认不拦截任何事件（返回false）。

5、View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable默认为false。

6、View的enable属性不影响onTouchEvent的默认返回值。

7、通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。

高深:

android事件分发核心是在`viewgroup`的`dispatchTouchEvent`的`action_down`过程中找到`mFirstTouchTarget`是否为空，通过反序遍历子view的dispatchTouchEvent的方法，如果发现有一个子view的`dispatchTouchEvent`方法返回true，那么`mFirstTouchTarget`就不为空，否则为空。如果`mFirstTouchTarget`不为空，那么`action_move`和`action_up`才会往下传递，如果在`action_move`和`action_up`过程中有viewgroup拦截了事件，则此时先向子view的`dispatchTouchEvent`传递一个`action_cancel`，并且将`mFirstTouchTarget`至为null，所以此时`action_move`和`action_up`只会走`viewgroup`的`dispatchTouchEvent`和`onTouchEvent`；如果`mFirstTouchTarget`在`action_down`过程中就已经null的话，则从`action_down`一直向上层view传递，不会有后续的`action_move`和`action_up`了。

> ViewGroup在Action_Move时onIntercept返回true，事件怎么传递?

> 手势操作ActionCancel后怎么取消 

- 一般ACTION_CANCEL和ACTION_UP都作为View一段事件处理的结束。如果在父View中拦截ACTION_UP或ACTION_MOVE，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到ACTION_CANCEL事件。
- 如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现action_cancel。

> 点击事件被拦截，但是想传到下面的View，如何操作？

重写子类的requestDisallowInterceptTouchEvent()方法返回true就不会执行父类的onInterceptTouchEvent()，即可将点击事件传到下面的View。

> 如何解决View的事件冲突？举个开发中遇到的例子？

常见开发中事件冲突的有ScrollView与RecyclerView的滑动冲突、RecyclerView内嵌同时滑动同一方向。

滑动冲突的处理规则：

- 对于由于外部滑动和内部滑动方向不一致导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件。
- 对于由于外部滑动方向和内部滑动方向一致导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件，何时由内部View拦截事件。
- 对于上面两种情况的嵌套，相对复杂，可同样根据需求在业务上找到突破点。

滑动冲突的实现方法：

- 外部拦截法：指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。具体方法：需要重写父容器的onInterceptTouchEvent方法，在内部做出相应的拦截。
- 内部拦截法：指父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法：需要配合requestDisallowInterceptTouchEvent方法。

> 实现一个不能滑动的ViewPager

onInterceptTouchEvent()方法和onTouchEvent()方法，这两个方法的返回值都是boolean类型的，只需要将返回值改为false，那么ViewPager就不会消耗掉手指滑动的事件了

#View绘制流程
View的工作流程主要是指measure、layout、draw这三大流程，其中measure确定View的测量宽/高，layout确定View的最终位置，而draw则将View绘制到屏幕上

1. View 的绘制始于 ViewRootImpl 的 performTraversal() 开始遍历，会先从根视图开始测量
2. 根视图（DecorView）的宽高一般是屏幕宽高，而ViewGroup的宽高会循环调用它所有子视图的测量 measure()，来决定自己的大小
3. onMeasure：方法主要有两个重要的参数，分别是宽度测量规格和高度测量规格，MeasureSpec 测量规格有三种模式，分别是 AT_MOST、EXACTLY、UNSPECIFIED，主要是**代表父布局堆子布局的期望**。我们可以重写onMeasure()，循环测量子View，根据子 View 确定父 View，最后调用 setMeasuredDimension() 就行
4. onLayout：代表如何布局子 View 的位置，只有 ViewGroup 需要重写，会传入四个参数。其中布局也是自上而下，不同的是  ViewGroup 先在 layout() 中确定自己的布局，然后在 onLayout() 方法中再调用子 View 的 layout()  方法，让子 View 布局。在 Measure 过程中，ViewGroup 一般是先测量子 View 的大小，然后再确定自身的大小。
5. onDraw：传入一个 Canvas，绘制背景 -> 绘制自己 -> 绘制子视图 -> 绘制装饰

> MeasureSpec

> 如何求当前Activity View的深度
>
> 自定义LinearLayout，怎么测量子View宽高
>
> 自定义实现一个FlexLayout

##自定义圆角图片
>BitmapShader实现

	public class RoundImageViewByBitmapShader extends ImageView {
	
	  private Shader mShader;
	  private Paint mPaint;
	
	  public RoundImageViewByBitmapShader(Context context) {
	    super(context);
	  }
	
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs) {
	    super(context, attrs);
	  }
	
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
	    super(context, attrs, defStyleAttr);
	  }
	
	  @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
	    super(context, attrs, defStyleAttr, defStyleRes);
	  }
	
	  @Override
	  protected void onDraw(Canvas canvas) {
	    BitmapDrawable drawable = (BitmapDrawable) getDrawable();
	    if (mShader == null) {
	      mShader = new BitmapShader(drawable.getBitmap(), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
	      mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
	    }
	    mPaint.setShader(mShader);
	    canvas.drawRoundRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), 100, 100, mPaint);
	  }
	}

>Xfermode

	public class RoundedImageViewByXfermode extends ImageView {
	
	  private Paint mPaint;
	  private Xfermode mXfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);
	  private RectF mRectF;
	  private Bitmap mBitmap;
	
	  public RoundedImageViewByXfermode(Context context) {
	    this(context, null);
	  }
	
	  public RoundedImageViewByXfermode(Context context, @Nullable AttributeSet attrs) {
	    this(context, attrs, 0);
	  }
	
	  public RoundedImageViewByXfermode(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
	    super(context, attrs, defStyleAttr);
	    init();
	  }
	
	  @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
	  public RoundedImageViewByXfermode(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
	    super(context, attrs, defStyleAttr, defStyleRes);
	  }
	
	  private void init() {
	    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
	  }
	
	  @Override
	  protected void onDraw(Canvas canvas) {
	    canvas.saveLayer(0, 0, getMeasuredWidth(), getMeasuredHeight(), null, Canvas.ALL_SAVE_FLAG);
	    Drawable drawable = getDrawable();
	    if (mBitmap == null) {
	      mBitmap = Bitmap.createBitmap(getMeasuredWidth(), getMeasuredHeight(), Bitmap.Config.ARGB_8888);
	      Canvas drawCanvas = new Canvas(mBitmap);
	      drawable.draw(drawCanvas);
	    }
	    if (mRectF == null) {
	      mRectF = new RectF(0, 0, getMeasuredWidth(), getMeasuredHeight());
	    }
	    mPaint.setXfermode(null);
	    canvas.drawRoundRect(mRectF, 100, 100, mPaint);
	    mPaint.setXfermode(mXfermode);
	    canvas.drawBitmap(mBitmap, 0, 0, mPaint);
	    canvas.restore();
	  }
	}
先绘制Dst图层和src图层，然后根据规则设置不同的Xfermode，从而达到裁剪图层的效果


#Handler机制 
##简单描述下Handler机制？一个线程有几个Looper？为什么？
Handler机制由MessageQueue，Message，Looper，Handler组成。Handler的主要作用是发送和处理消息；MessageQueue称作消息队列，采用单链表的数据结构存储Message；Looper是一个循环，会在一个无限循环中不断从MessageQueue中获取Message，如果有Message，就交给对应的Handler去处理；Message是传递的消息，它的target参数持有是发送它的Handler对象。Handler通过sendMessage()发送消息Message到消息队列MessageQueue。Looper通过loop()不断提取触发条件的Message，并将Message交给对应target的handler来处理。handler调用自身的handleMessage()方法来处理Message。

一个线程只有1个Looper，是通过ThreadLocal来保证的

##Handler内存泄漏的GCRoot是什么？

ThreadLocal静态变量作为gcRoot，导致activity无法被回收

handler的内存泄漏原因：

1. 当直接在activity中声明handler时，由于后面的匿名内部类，使handler持有了activity的引用。
2. 当任务未执行完，即message未被执行完时，message持有了messageQueue的引用。
3. messageQueue持有了mLooper的引用。
4. mLooper持有sThreadLocal 的引用。
5. sThreadLocal 是一个静态变量，无法被回收，最终导致了activity无法被回收，造成了内存泄漏。

##Handler休眠是怎样的？epoll的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？

Handler消息机制的休眠和唤醒是通过native层的epoll机制和pipe机制来实现的(也就是线程的休眠和唤醒)

epoll 相关方法： epoll_wait()、epoll_create()、epoll_ctl()

在Linux系统内核中，所有执行I/O操作的系统调用都会通过文件描述符。内核利用文件描述符来访问文件，文件描述符是非负整数。

pipe是Linux中最基本的一种IPC机制，可以用来实现进程、线程间通信。

pipe其本质是一个伪文件，它有两个文件描述符引用，一个表示读端，一个表示写端，规定数据从管道的写端流入管道，从读端流出。

Handler机制中，底层使用pipe创建两个fd：writeFD、readFD。当线程A想唤醒线程B的时候，就可以往writeFD中写数据，这样线程B阻塞在readFD中就能返回。 也就是说，当文件描述符指向的文件（内核缓冲区）为空时，则线程进行休眠。当另一个线程向缓冲区写入内容时，则将当前线程进行唤醒。

epoll机制是linux内核实现IO多路复用的一个实现。IO多路复用的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。



UI线程进入Looper的无限循环之后，为什么没有ANR，是因为底层使用了Linux的epoll机制和pipe实现了线程在空闲时的休眠，并且不会占用系统CPU资源。

> Message是根据什么排序的

是根据when字段排序的，when=系统开机时间+delayMillis

。MessageQueue中的Message是如何排列的？Msg的runnable对象可以外部设置么，比如说不用Handler#post系列方法（反射可以实现）；

##Handler是怎么切换线程的,Handler同步屏障

> 同步屏障

Handler中的Message可以分为两类：同步消息，异步消息，一般我们直接发送的消息都是同步消息，只有在msg.setAsynchronous(true)时，发送的消息都会变成异步消息。

一般来说这两种消息没有什么区别，只有在设置了同步屏障时才会出现差异。

可通过mHandler.getLooper().getQueue().postSyncBarrier()设置同步屏障。设置同步屏障后，设置了一个 target 字段为空的 Message到消息队列，loop循环会遍历找到异步消息去处理

Handler设置同步屏障之后，Looper只会获取和处理异步消息，如果没有异步消息会进入阻塞状态。

>Handler线程切换

在A线程正常创建handlerA，然后在B线程中利用handlerA发送消息，此时消息就发送给与handlerA关联的Looper了，而这个Looper唯一关联的线程就是A，这样我们的消息就会在A线程中执行了

> IdleHandler调用时机 IdleHandler应用场景

# Binder机制

* 基于C/S架构，包括`Server`、`Client`、`ServiceManager`和`Binder`驱动，其中`Binder`驱动运行在内核空间，其他的运行在用户空间
* ServiceManager负责服务管理，服务端向`ServiceManager`注册后，客户端可以向`ServiceManager`查询获取到目标服务的引用
* Binder驱动：负责进程之间的`Binder`通信的建立，基于内存映射技术，传统的通信方式需要将数据从用户空间拷贝到内核空间，然后从内核空间拷贝到目标进程的用户空间，需要两次拷贝，`Binder`驱动可以建立用户空间内存和内核空间内存的一个映射，只需要一次拷贝，非常高效。

实现原理

Linux 的可加载内核模块（Loadable Kernel Module，LKM）的机制

内存映射, mmap()（内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。）



首先 Binder 驱动在内核空间创建一个数据接收缓存区

接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系

发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。



Server向ServiceManager注册服务（保存DNS地址）

Client向ServiceManager查询Service地址（DNS查询）

Client得到ServiceManager返回的Service地址（返回DNS地址）

Client使用服务（请求服务器）

Service向Client返回数据（返回数据）



binder是cs架构，Server端的binder都是运行在同一个线程里面么

# Kotlin

## let和with的区别

```
1.返回值
	lambda表达式结果-> let\run\with
  	上下文对象->apply\also
2.作用域中对象引用方式
  	it->let\also
  	this->with\run\apply
let->统一判null
run->对象配置并计算结果
with->对象的一组操作
apply->对象配置
also->并且对象还做什么事情
```

##lateinit和by lazy的区别

1. lazy只能用在val类型, lateinit 只能用在var类型
2. lateinit可以在任何位置初始化并且可以初始化多次。而lazy在第一次被调用时就被初始化

##kotlin的扩展方法是怎么实现的，inline关键字的作用

- 扩展方法编译成java后，实际上是一个 public static的静态方法，传入了对象实例和参数
- Inline关键字修饰的函数是内联函数，用于优化函数调用的压栈操作，相当于在编译期间把内联函数的代码拷贝到函数调用处，可以提升性能，但是增加了代码量

kotlin与Java互相调用有什么问题？

协程怎么取消

##你对协程的理解，协程有什么作用？可以完全取代rxjava吗？协程怎么取消？协程可以在Java项目中使用吗？

协程和线程一样都是用来解决`并发任务（异步任务）`的方案。 所以协程和线程是属于一个层级的概念，但是对于`kotlin`中的协程，又与广义的协程有所不同。 kotlin中的协程其实是对线程的一种`封装`，或者说是一种线程框架，为了让异步任务更好更方便使用。



kotlinc与javac编译字节码有什么区别？

kotlin空安全的原理是什么？



协程：一套基于线程而实现的上层API。优点：异步变同步

suspend 挂起函数，可在挂起函数中执行子线程操作，挂起函数执行完成后，也会继续执行下面的代码

>协程怎么取消

```kotlin
val job1 = scope.launch { … }
val job2 = scope.launch { … }
scope.cancel()
```

但是调用了`cancel`并不代表协程内的工作会马上停止，他并不会组织代码运行。 比如上述的`job1`，正常情况处于`active `状态，调用了`cancel`方法后，协程会变成`Cancelling `状态，工作完成之后会变成`Cancelled` 状态，所以可以通过判断协程的状态来停止工作。



协程可以在Java项目中使用吗？？

##协程的scope与context，协程的+号代表什么

# 性能优化

## 启动速度的优化

Application的attachBaseContext和onCreate，三方sdk采用线程池异步初始化，activity的onCreate中，设置布局的优化（xml的io操作、反射创建view的操作，通过异步inflater和自定义inflater.factory来优化）

1. 延迟初始化非必要的库，拓展到异步启动器的设计和实现，有向无环图来解决库依赖的问题。
2. 给闪屏页设置图片背景避免冷启动白屏，其实不能加快启动，只是避免白屏给用户的体验不佳



启动优化做过什么工作？如果首页就要用到的初始化？

》解决UI卡顿优化的经历

## 包大小优化

1，开启混淆压缩代码 2，压缩和混淆资源，图片压缩采用webP格式，整理Raw、assets资源 3，减少非必要so库，目前主流的机型都是支持armeabi-v7a的，并且armeabi-v7a兼容armeabi 4，移除未使用的资源，如图标，字符串，字体等 5，一些小图像可以使用矢量图，大矢量图渲染时间很长，不适用 6，减少三方库使用，避免枚举的使用 7，动态下发一些资源，如换肤包，so，字体等

## 内存优化

内存泄露优化（包括常见的内存泄漏、分析方法、LeakCanrary等）、使用优化的数据结构（ArrayMap和SparseArray），对频繁创建的对象使用对象池技术，减少不必要的内存开销

> 看视频的时候网络请求很慢怎么优化？

HttpDNS优化，传统DNS解析一般是用UDP的方式与DNS服务器交互，HttpDNS采用Http协议交互，绕过运营商的 LocalDNS 服务器，有效的防止了域名劫持，提高域名解析的效率

使用缓存，需要服务端支持，或者通过OkHttp拦截器添加统一的缓存策略

HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。在HTTP1.1中默认开启keep-alive

数据压缩，gzip压缩，http2.0也支持header的压缩

根据网络质量来下载不同质量的图片

##卡顿优化

> App上线后用户使用时卡顿怎么查看是什么原因

# 图片优化

## Bitmap内存大小，注意事项，如何优化



Bitmap优化的实际经验

# Application中可以显示Dialog么？为什么？

屏幕适配做过什么工作

#说说MVP和MVVM的特点

`MVP`:主要是分离了M层和V层的代码，通过P层来建立他们的关联，实现M层和V层的解耦。缺点就是每增加一个功能，需要增加相应的接口回调。MVP的核心就是通过接口实现隔离，将相关的业务层交给了P层。

如果要细说mvp需要注意几点:

- p层的逻辑处理单一的功能，不要融合一个模块下的增删改查的整个功能。
- 由于p层持有了v层的引用，通常在p层使用弱引用来持有view层实例，在p层销毁的时候需要将v层的引用销毁掉。
- 契约类指的p层和v层的接口类放在一个contract接口类中，契合类方便管理业务层的功能，将单个功能放到一个contract契合类中。

`MVVM`:主要是用到了观察者模式，通过数据的改变来通知相应的View改变的过程。M层和上面的MVP中的M层是一样的，都是网络请求+数据缓存来实现该层的，里面的VM是ViewModel实现的，ViewModel层获取到M层的数据后，通过观察者模式通知UI的改变。

MVP怎么处理内存泄漏

# JetPack组件用过哪些？lifeCycle的原理是什么？如果在onStart里面订阅，会回调onCreate吗？

ViewModel为什么在旋转屏幕后不会丢失状态

ViewModel在Activity初始化与在Fragment中初始化，有什么区别？

viewModel是怎么实现双向数据绑定的

viewModel怎么实现自动处理生命周期

#android中用到的观察者模式有哪些地方

观察者模式是由一个被观察者和一个观察者构成的、被观察者在状态改变时（用户操作、程序主动改变等）主动通知所有观察者作相应的刷新。 android中最经典要说ListView的数据源发生变化了，刷新列表的事例。在setAdapter的时候，生成一个`AdapterDataSetObserver`，紧接着就是订阅上该观察者，该观察者`onChange`方法里面有`requestLayout`方法，该方法是触发UI发生变化的方法。在`BaseAdapter`里面可以看到`notifyDataSetChanged`实际上触发的是`DataSetObservable`被观察者的`notifyChanged`方法，`notifyChanged`会触发`AdapterDataSetObserver`的`onChange`方法。所以最终会走listView的`requestLayout`，最后刷新了UI。

3说说google新出的Lifecycle框架

将类的生命周期方法移交到Lifecycle中管理，实现对类的生命周期的监听，从而在Lifecycle中处理生命周期的逻辑代码。这里涉及到几个对象: `LifecycleObserver接口`（ Lifecycle观察者）：实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。 `LifecycleOwner接口`（Lifecycle持有者）：实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。 `Lifecycle`(生命周期)：和LifecycleOwner不同的是，LifecycleOwner本身持有Lifecycle对象，LifecycleOwner通过其Lifecycle getLifecycle()的接口获取内部Lifecycle对象。 `State`(当前生命周期所处状态)：几种事件状态。 `Event`(当前生命周期改变对应的事件)：当Lifecycle发生改变，事件状态的回调event。

# RecyclerView

> Recyclerview缓存

Recycleview有四级缓存，分别是`mAttachedScrap(屏幕内)，mCacheViews(屏幕外)，mViewCacheExtension(自定义缓存)，mRecyclerPool(缓存池)`

- `mAttachedScrap(屏幕内)`，用于屏幕内itemview快速重用，不需要重新createView和bindView
- `mCacheViews(屏幕外)`，保存最近移出屏幕的ViewHolder，包含数据和position信息，复用时必须是相同位置的ViewHolder才能复用，应用场景在那些需要来回滑动的列表中，当往回滑动时，能直接复用ViewHolder数据，不需要重新bindView。
- `mViewCacheExtension(自定义缓存)`，不直接使用，需要用户自定义实现，默认不实现。
- `mRecyclerPool(缓存池)`，当cacheView满了后或者adapter被更换，将cacheView中移出的ViewHolder放到Pool中，放之前会把ViewHolder数据清除掉，所以复用时需要重新bindView。

四级缓存按照顺序需要依次读取。所以**完整缓存流程**是：

1. 保存缓存流程：

- 插入或是删除`itemView`时，先把屏幕内的ViewHolder保存至`AttachedScrap`中
- 滑动屏幕的时候，先消失的itemview会保存到`CacheView`，CacheView大小默认是2，超过数量的话按照先入先出原则，移出头部的itemview保存到`RecyclerPool缓存池`（如果有自定义缓存就会保存到自定义缓存里），RecyclerPool缓存池会按照itemview的`itemtype`进行保存，每个itemTyep缓存个数为5个，超过就会被回收。

1. 获取缓存流程：

- AttachedScrap中获取，通过pos匹配holder——>获取失败，从`CacheView`中获取，也是通过pos获取holder缓存

——>获取失败，从`自定义缓存`中获取缓存——>获取失败，从`mRecyclerPool`中获取 ——>获取失败，重新创建`viewholder`——createViewHolder并bindview。

需要注意的是，如果从缓存池找到缓存，还需要重新bindview。

> RecyclerView性能优化

- `bindViewHolder`方法是在UI线程进行的，此方法不能耗时操作，不然将会影响滑动流畅性。比如进行日期的格式化。
- 对于新增或删除的时候，可以使用`diffutil`进行局部刷新，少用全局刷新
- 对于`itemVIew`进行布局优化，比如少嵌套等。
- 25.1.0 (>=21)及以上使用` Prefetch` 功能，也就是预取功能，嵌套时且使用的是LinearLayoutManager，子RecyclerView可通过setInitialPrefatchItemCount设置预取个数
- 加大`RecyclerView缓存`，比如cacheview大小默认为2，可以设置大点，用空间来换取时间，提高流畅度
- 如果高度固定，可以设置`setHasFixedSize(true)`来避免requestLayout浪费资源，否则每次更新数据都会重新测量高度。

```java
void onItemsInsertedOrRemoved() {
   if (hasFixedSize) layoutChildren();
   else requestLayout();
}
```

- 如果多个` RecycledView` 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 `RecyclerView.setRecycledViewPool(pool); `来共用一个 `RecycledViewPool`。这样就减少了创建VIewholder的开销。
- 在RecyclerView的元素比较高，一屏只能显示一个元素的时候，第一次滑动到第二个元素会卡顿。这种情况就可以通过设置额外的缓存空间，重写`getExtraLayoutSpace`方法即可。

```java
new LinearLayoutManager(this) {
    @Override
    protected int getExtraLayoutSpace(RecyclerView.State state) {
        return size;
    }
};
```

- 设置`RecyclerView.addOnScrollListener();`来在滑动过程中停止加载的操作。
- 减少对象的创建，比如设置监听事件，可以全局创建一个，所有view公用一个listener，并且放到`CreateView`里面去创建监听，因为CreateView调用要少于bindview。这样就减少了对象创建所造成的消耗
- 用`notifyDataSetChange`时，适配器不知道整个数据集中的那些内容以及存在，再重新匹配`ViewHolder`时会花生闪烁。设置adapter.setHasStableIds(true)，并重写`getItemId()`来给每个Item一个唯一的ID，也就是唯一标识，就使itemview的焦点固定，解决了闪烁问题。





#RxJava 

> 线程切换原理
>
> Rxjava是怎么实现线程切换的

- RxJava通过`subscribeOn`指定被观察者发生的线程，`observeOn`指定观察者发生的线程。其中Schedulers.IO生成的是`IoScheduler`。通过观察者与被观察者订阅的过程中，首先会触发被观察者的`subscribeActual`方法，在该方法中，可以看到最终会走`scheduler`的`schedule`方法，所以上面提到的`IoScheduler`实际是调用了它的`schedule`方法，最终会在`NewThreadWorker`里面生成`ScheduledExecutorService`对象，而`ScheduledExecutorService`实际是由`ScheduledThreadPoolExecutor`创建的一个核心线程，最大线程个数是Integer.MAX_VALUE的线程池。最终会由`ScheduledThreadPoolExecutor`的`submit`或`schedule`方法执行传过来的Runnable对象，而Runnable执行的是被观察者的`subscribe`方法。所以解释了被观察者的`subscribe`方法是在子线程中执行的。
- `observeOn`是观察者发生的线程，`AndroidSchedulers.mainThread()`实质是`HandlerScheduler`对象，而在观察者部分，最终观察部分会走Scheduler的`scheduleDirect`方法，而`HandlerScheduler`的该方法里面包装了一个`ScheduledRunnable`对象，通过主线程的handler.postDelayed处理这个runnable对象。

> map关键字的作用是什么



#Eventbus源码

EventBus 发布/订阅事件的总线框架，基于观察者模式，将事件的接收者和发送者分开，基本包括了如下几个步骤:

注册事件的订阅方法:该步骤主要是找到订阅者下面有哪些方法需要被订阅

订阅操作:将需要被订阅的方法放到类似HashMap的数据结构中存储起来，方便后面发送事件和取消注册等资源的释放的时候使用

发送事件:该步骤首先遍历事件队列，然后从队列中取出事件，并且将事件从队列中移除，拿到事件后，判断事件处于的什么线程，如果是非UI线程，则需要Handler去处理，如果是的话，则直接通过反射调用被观察的方法。

反注册:该步骤就没什么好说的，主要是上面存储到HashMap中的被订阅的方法的移除，释放在内存中的资源。

EventBus最核心的逻辑就是利用了 subscriptionsByEventType 这个重要的列表，将订阅对象，即接收事件的方法存储在这个列表，发布事件的时候在列表中查询出相对应的方法并执行。



#项目有什么难点？

不知道

介绍一下你们项目的架构

# 单元测试 O

> Robolectric environment 测试跟Android相关使用的框架

```
@RunWith(RobolectricTestRunner.class)
@Config(application = RoboApp.class)
public class SharedPreferenceDaoTest {

    public static final String TEST_KEY = "instrumentedTest";
    public static final String TEST_STRING = "玉刚说";

    SharedPreferenceDao spDao;

    @Before
    public void setUp() {
        //这里的Context采用RuntimeEnvironment.application来替代应用的Context
        spDao = new SharedPreferenceDao(RuntimeEnvironment.application);
    }

    @Test
    public void sharedPreferenceDaoWriteRead() {
        spDao.put(TEST_KEY, TEST_STRING);
        Assert.assertEquals(TEST_STRING, spDao.get(TEST_KEY));
    }

}
```

> Mockito framework       测试跟Android不太相关使用的框架

```
@RunWith(MockitoJUnitRunner.class)
public class UnitTestSample {
	@Mock
    Context mMockContext;

    @Test
    public void readStringFromContext_LocalizedString() {
        //模拟方法调用的返回值，隔离对Android系统的依赖
        when(mMockContext.getString(R.string.app_name)).thenReturn(FAKE_STRING);
        assertThat(mMockContext.getString(R.string.app_name), is(FAKE_STRING));
        
        when(mMockContext.getPackageName()).thenReturn("com.jdqm.androidunittest");
        System.out.println(mMockContext.getPackageName());
    }
｝
```

# 网络 O

kHttp网络拦截器，应用拦截器?OKHttp有哪些拦截器，分别起什么作用

> 响应码

1**	信息，服务器收到请求，需要请求者继续执行操作

2**	成功，操作被成功接收并处理

3**	重定向，需要进一步的操作以完成请求

4**	客户端错误，请求包含语法错误或无法完成请求

5**	服务器错误，服务器在处理请求的过程中发生了错误

> 网络封装怎么实现？如果让你写一个网络框架，你怎么写

如何实现一个网络框架(参考Volley)
 1.缓存队列,以url为key缓存内容可以参考Bitmap的处理方式，这里单独开启一个线程。
 2.网络请求队列，使用线程池进行请求。
 3.提供各种不同类型的返回值的解析如String，Json，图片等等。

> 三次握手，四次挥手

客户端简称A，服务器端简称B 

1）TCP建立连接需要三次握手

- A向B表示想跟B进行连接（A发送`syn`包，A进入`SYN_SENT`状态）
- B收到消息，表示我也准备好和你连接了（B收到`syn`包，需要确认`syn`包，并且自己也发送一个`syn`包，即发送了`syn+ack`包，B进入`SYN_RECV`状态）
- A收到消息，并告诉B表示我收到你也准备连接的信号了（A收到`syn+ack`包，向服务器发送确认包`ack`，AB进入`established`状态）开始连接。

2）TCP断开连接需要四次挥手

- A向B表示想跟B断开连接（A发送`fin`，进入`FIN_WAIT_1`状态）
- B收到消息，但是B消息没发送完，只能告诉A我收到你的断开连接消息（B收到fin，发送ack，进入`CLOSE_WAIT`状态，A进入`FIN-WAIT-2`状态）
- 过一会，B数据发送完毕，告诉A，我可以跟你断开了（B发送fin，进入`LAST_ACK`状态，A进入`TIME-WAIT`状态）
- A收到消息，告诉B，可以他断开（A收到fin，发送ack，B进入`closed`状态）

问题：

1. 为什么建立TCP连接需要三次握手，而关闭连接则需要四次握手
   这是由于TCP连接是全双工的，我关了你的连接，并不等于你关了我的连接（一端关闭是单方向关闭），因此双方都必须单独进行关闭。当一方完成它的数据发送任务后可以发送FIN包来终止这个方向的连接，表明自己不再有数据需要发送；收到FIN包的那一方虽然不能再读取数据，但仍能发送数据

2. 为什么连接需要三次，而不是两次。

   为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
   “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”

3. TCP是怎么保证可靠传输的？

   序列号和确认号。比如连接的一方发送一段80byte数据，会带上一个序列号，比如101。接收方收到数据，回复确认号181（180+1），这样下一次发送消息就会从181开始发送了。
   
   # 算法
   
   
