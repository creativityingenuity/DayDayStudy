https://juejin.im/post/6876968255597051917#heading-15

事件分发 https://juejin.im/post/6844903901712351240#heading-20   https://www.jianshu.com/p/3581fcf302fd

https://mp.weixin.qq.com/s?__biz=MzU2OTY0MDcwNw==&mid=2247487396&idx=1&sn=078d2387b31be9b54302bcbf84bb4270&chksm=fcfaddc8cb8d54de462fa780b6bad38b76cf1414630ea3ce45a25e5c6deadb745344cb5c76aa&mpshare=1&scene=23&srcid=11183jDL1NKD9G1Xz4EFwcTW&sharer_sharetime=1605667241424&sharer_shareid=f28cabd0a22022d9b05e071b1c1a6e0c#rd

# 线程

## 自定义线程池以及线程池的工作原理

> 1.通过ThreadPoolExecutor构造线程池

ThreadPoolExecutor 线程池用于管理线程任务队列、若干个线程

构造函数

- corePoolSize： 线程池核心线程数量。核心线程一旦创建会一直执行任务或等待任务到来，而非核心线程只在任务队列塞满任务时去执行多出的任务，并且非核心线程在等待一段时间后将会被回收，这个时间是keepAliveTime参数。
- maximumPoolSize：线程池最大线程数量。最大线程数=核心线程+非核心线程
- keepAliveTime： 非核心线程的超时时长。当执行时间超过这个时间时，非核心线程就会被回收。当任务很多，每个任务执行时间很短的情况下调大该值有助于提高线程利用率。注意：当allowCoreThreadTimeOut属性设为true时，该属性也可用于核心线程。
- unit： 线程池维护线程所允许的空闲时间的单位
- workQueue： 线程池所使用的任务队列
- threadFactory：线程池用于创建线程
- handler： 线程池对拒绝任务的处理策略

> 2.通过Executors构造线程池

```
ExecutorService executorService = Executors.newCachedThreadPool();
```

* newCachedThreadPool：底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)；通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。**适用：执行很多短期异步的小程序或者负载较轻的服务器**
* newFixedThreadPool：底层：返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列；通俗：创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不再添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)**适用：执行长期的任务，性能好很多**

* newSingleThreadExecutor:*底层：FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列；通俗：创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)**适用：一个任务一个任务执行的场景**

* newScheduledThreadPool:底层：创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列；通俗：创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构**适用：周期性执行任务的场景**

#锁和并发 

##ReentranLock跟synchronized有什么区别？synchronized与ReentranLock发生异常的场景？

> 相同

都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待

> 不同

1. API层面

   * synchronized是关键字，是原生语法层面的互斥，需JVM实现。ReentranLock是1.5之后API提供的

   * synchronized可以修饰方法和代码块,Reentranlock只能在方法内使用

2. 等待可中断

   * 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，去处理别的事情
   * 假如业务代码中有两个线程，Thread1 Thread2。假设 Thread1 获取了对象object的锁，Thread2将等待Thread1释放object的锁。
     - 使用synchronized。如果Thread1不释放，Thread2将一直阻塞等待，不能被中断。
     - 使用ReentrantLock。如果Thread1不释放，Thread2等待了很长时间以后，可以中断等待，转而去做别的事情。

3. 公平锁

   * 公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序获取锁，而非公平锁则是任何一个等待的线程都可以获取锁
   * synchronized是非公平锁，ReentranLock默认是非公平锁，但可以通过构造函数设置True使用公平锁

```
private ReentrantLock lock = new ReentrantLock();
public void run() {
    lock.lock();
    try{
        for(int i=0;i<5;i++){
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }finally{
        lock.unlock();
    }
}
```

> synchronized与ReentranLock发生异常的场景

发生异常的场景我查了半天没查到，应该就是线程抛出异常吧

在发生异常时，synchronized会自动释放锁，ReentranLock则需要与try{}finally{}搭配手动释放锁

##synchronized是公平锁还是非公平锁,ReentranLock是公平锁吗？是怎么实现的

synchronized是非公平锁，ReentranLock默认是非公平锁，但可以通过构造函数设置True使用公平锁

>ReentranLock是怎么实现的

##synchronized底层原理是什么

Synchronized经过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。

> 静态方法与普通方法加synchronized有什么区别 

普通方法是对调用该方法的对象加锁，静态方法是对该方法所在的类加锁

> synchronized能不能继承？





##volatile字段有什么用途？

> synchronized和volatile的区别

`volatile`本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,`synchronized`则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.

`volatile`仅能使用在变量级别,`synchronized`则可以使用在变量,方法.

`volatile`仅能实现变量的修改可见性,而`synchronized`则可以保证变量的修改可见性和原子性.

`volatile`不会造成线程的阻塞,而`synchronized`可能会造成线程的阻塞.

当一个域的值依赖于它之前的值时，`volatile`就无法工作了，如n=n+1,n++等，也就是不保证原子性。

使用`volatile`而不是`synchronized`的唯一安全的情况是类中只有一个可变的域。

> voliate原理

关键字 `volatile` 可以说是 Java 虚拟机提供的最轻量级的同步机制。

当一个变量定义为 `volatile` 之后，它将具备两种特性，

1. 保证此变量对所有线程的

   可见性（也就是一致性）

   ，这里的「可见性」是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量的值在线程之间传递均需要通过主内存来完成。

   - 原理

     1. Lock 前缀的指令会引起处理器缓存（工作内存）写回内存（共享内存）；
     2. 一个处理器的缓存回写到内存会导致其他处理器的缓存失效；
     3. 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。

   - 但是 Java 里面的运算并非原子操作，导致 

     volatile 变量的运算在并发下一样是不安全的，所以在不符合以下两条规则的运算场景中，**我们仍然要通过**加锁

     （synchronized 或 java.util.concurrent 的原子类）来保证

     原子性。

     1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。

        ```
         volatile boolean shutdownRequested；
         
         public void shutdown(){
         	shutdownRequested = true；
         }
         
         public void doWork(){
         	while（!shutdownRequested）{
         		//dostuff
         	}
         }
        ```

     2. 变量不需要与其他的状态变量共同参与不变约束。

2. 禁止指令重排序优化

   - 什么是指令重排序？

     从硬件架构上讲，指令重排序是指 CPU 采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU 需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。譬如指令 1 把地址 A 中的值加 10，指令 2 把地址 A 中的值乘以 2，指令 3 把地址 B 中的值减去 3，这时指令 1 和指令 2 是有依赖的，它们之间的顺序不能重排

   - 有 volatile 修饰的变量，赋值后多执行了一个**lock前缀的指令操作**，这个操作相当于一个**内存屏障**，指重排序时不能把后面的指令重排序到内存屏障之前的位置。只有一个 CPU 访问内存时，并不需要内存屏障；但如果有两个或更多CPU 访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。

     ```
       // 在JDK1.5 后使用 DCL（双锁校验）
       public class Singleton {
       	private volatile static Singleton instance;
       
       	private Singleton(){}
       
       	public static getInstance(){
       		if(instance == null){
       			synchronized(Singleton.class){
       				if(instance == null) {
       						instance = new Singleton();
       				}
       			}
       		}
       		return instance;
       	}
       }
     ```

#HashMap的原理 

HashMap是通过对 key 的 hash 值进行转换来定位每个 key 在内部数组上的位置。HashMap 是实现原理是数组 + 链表，Java 1.8 以后加入了红黑树。
Key的Hash值计算

第一步：正常计算出 key 的 hash 值（调用 key 的 hashCode() 方法，如果 key 是 null 则其 hash 值是0）； 第二步：对得到的 hash 值进行扰乱，目的是为了让 hash 值能尽可能的均匀分布。
问题
1. 为什么不直接使用 key 而要使用 key 的 hash 值？

答：考虑到效率问题如果直接使用 key，那么在查找的时候需要调用 key 的 equals() 方法去逐个比较，时间复杂度从原本的 O(1) 变成了 O(n) ，且 equals() 比较的效率也很低，而通过 hash 值可以直接定位到桶。
2. 那为什么又不直接用 hash 值作为数组上的索引？

答：为了防止数组下标越界，因为 hash 值不确定性，很容易越界。
3. 那为什么用的是 (n - 1) & hash，而不是 hash % n 呐？

答：其实早期版本就是用 hash % n，但是为了追求效率，后来就改成了位运算 (n - 1) & hash（位运速度比取余算快，注意：%是取余不是取模）， 当 n 为 2 的指数，(n - 1) & hash 与 hash % n是等价的
4. 为什么 (n - 1) & hash 和 hash % n 是等价的？

答：这里利用了 HashMap 的一个特性：HashMap 规定其容量必须是 2 的 n 次方（最大为 230 次方）,那么 n 肯定就是 2xx 次方了，用二进制表示就是 1000...00，最前面是 1，后面全是 0（假设有k个0），那么 n-1 就全变成 1 了 111...1111（k-1个1），hash ^ (n - 1) 得到的最大值就是 n-1，最小值是 0。效果和hash % n 一样，只是改为位运算了。位运算比取模运算更快。
5. 为什么 HashMap 的容量是 2 的幂次方（参考问题 4）

答：是为了 hash 值的计算，早期版本的 hash 值计算是 hash % n，来得到一个数组范围内的 hash 值，而当容量为2的幂次方（其二进制永远是100.....，再减去1，就是全部都是11111，方便做与运算），通过 (n - 1) & hash 来计算哈希值，会更加效率。

#泛型有什么优点？ O
1. 保证类型安全性
	1. list<integer> arraylist 一个只能存放int,一个啥都可以存，编译的时候不会报错
2. 避免了强制转换，提高了性能
3. 代码观看清晰条理

# JVM类加载机制&垃圾回收 O

## JVM类加载机制了解吗，类什么时候会被加载？类加载的过程具体生命周期是怎样的？

> 类加载机制

JVM把类数据从Class文件加载到内存，并对数据进行校验，最终形成可以被JVM直接使用的字节码的过程就是类加载机制

object o =new object() 主要包括三个阶段：

1. 通过不同的类加载器加载，
2. 当类被加载之后，进行验证，只要包括：文件格式验证，元数据验证，字节码验证，符号引用验证；
3. 为类的静态变量分配内存；

> 什么时候被加载

Java虚拟机没有明确规定一个类在什么时候会被加载，但是它严格规定了只有以下6种情况必须对类进行初始化操作，在初始化操作之前必定会触发类的加载和连接

1. 遇到`new`、`getstatic`、`putstatic`、`invokestatic`这四条字节码指令时
   1. 使用`new`关键字实例化对象时；对应`new`字节码指令
   2. 读取或设置一个类的静态字段（被`final`修饰的、在编译期把结果放入常量池的静态变量除外）时；对应`getstatic`和`putstatic`字节码指令
   3. 调用一个类的静态方法时；对应`invokestatic`字节码指令
2. 使用`java.lang.reflect`包的方法**第一次**对类进行**反射调用**时会触发类的初始化

> 生命周期

Java类从加载到内存到移除，它的整个生命周期分为：

1. 加载：加载Class文件到内存
2. 验证：验证文件格式、元数据、字节码、符号引用
3. 准备：为类变量赋初始值
4. 解析：引用替换、字段解析、接口，方法解析
5. 初始化：1.执行静态代码块 2.为类变量赋值
6. 使用：对象实例化
7. 卸载：GC

##垃圾回收机制与jvm结构，老年代算法，方法区有啥，GCRoot都有啥 

    这篇文章写得挺好挺全的  https://juejin.im/post/6844903905457864718

>jvm内存结构

![Jvm内存结构.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/Jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png?raw=true)

* GC、虚拟机栈，本地方法栈是线程私有区域，其生命周期和线程相同；方法区和堆是线程共享区域，生命周期跟虚拟机相同，
* 除pc之外，别的区域都有可能造成OOM

1. 程序计数器 :指向当前线程所执行的字节码的行号
2. 虚拟机栈：主要描述方法执行，每个方法在执行的时候创建一个栈帧，其中栈帧中存储了函数中定义的基本数据类型变量以及对象的引用变量(局部变量表，操作数栈，动态链接，方法出口等信息)。每一个方法从调用到执行结束，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
3. 本地方法栈：虚拟机栈执行java方法；本地方法栈执行native方法。比如java中调用C或C++中的方法，在这里执行。
4. 堆：创建的对象与数组都保存在java堆内存中，因为是线程共享，所以与方法区两个是垃圾收集的区域，java堆中从GC的角度细分为：新生区与老年区。
5. 方法区：用于存储被jvm加载的类信息、常量、静态变量、编译器编译后的代码等数据
   1. 实现类似堆的永久代实现，GC算法也一样，GC主要用于常量池和无用的类的回收
   2. Class文件包括 1.类信息包括类的版本，字段，方法，接口等描述信息 2.常量池

> 如何判断一个对象需要被回收

不再使用的对象需要进行回收，不使用的类也有可能回收。

通过两个方法来判断对象不再被使用：

1. 引用计数法: 给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减一；任何时刻计数器为0的对象就是不会被使用的对象。

2. GC root: 以GC Root的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到“GC Roots”没有任何引用链相连的时候，就证明此对象是不可用的

>可以作为GC root对象包括：

* 虚拟机栈（栈帧中的本地变量表）中的引用对象。
* 方法区中的静态属性或常量（final）引用的对象。
* 本地方法栈中Native方法引用的对象。

>垃圾回收机制

垃圾回收机制采用的是分代收集。根据根据对象存活的不同年龄划分不同的域。

* 新生代：复制算法
  * 新生代分为Eden和两块Survivor,比例为8：1：1，每次使用Eden和其中一块Survivor空间，当进行回收时，将两块空间中还存活的对象复制到另一块Survivor空间中。如果存活的某对象的空间>Survivor空间，则将对象移到老年代
  * GC触发条件：当要申请的空间>Eden和其中一块Survivor剩余的空间时，会发生GC
  * 当对象在Survivor躲过一次GC，其年龄会+1，默认情况下当年龄到达15时，会被移到老年代
  * 因为新生代对象的特点是生命周期短，存活率低，所以采用复制算法。一般的复制算法每次只能使用一半的空间，这个是全部空间
* 老年代：标记清除算法或者标记整理算法
  * GC触发条件：
    * 显式调用System.gc()方法
    * 老年代空间不足
    * 从新生代进入老年代的空间大于老年代空闲空间
  * 因为存活对象多，所以采用标记复制算法

垃圾回收算法：

1. 标记-清除算法：首先标记出存活的对象，在标记完成后会对未标记的对象进行回收   
   1. 缺点：碎片多；虚拟机在给内存较大对象分配空间时，有可能找不到足够大的连续空间存放，从而引发垃圾回收动作。实际上有大量空闲空间，只是不连续；
2. 复制算法：将内存分为两块大小一样的区域，每次是使用其中的一块。当这块内存块用完了，就将这块内存中还存活的对象复制到另一块内存中，然后清空这块内存。
   1. 可用内存小
3. 标记-整理算法：标记过程与标记-清除算法一样，接下来让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
   1. 仍需要进行局部对象移动，一定程度上降低了效率

# 内存泄漏

> 什么时候回发生内存泄漏

- 集合类泄漏
- 单例/静态变量造成的内存泄漏
- 匿名内部类/非静态内部类
- 资源未关闭造成的内存泄漏

> 如何分析解决

使用库，比较出名的就是`LeakCanary`，导入库，然后运行后，就可以发现app内的内存泄漏情况。

这里说下`LeakCanary`的原理：

- 监听

首先通过`ActivityLifecycleCallbacks`和`FragmentLifeCycleCallbacks`监听Activity和Fragment的生命周期。

- 判断

然后在销毁的生命周期中判断对象是否被回收。弱引用在定义的时候可以指定引用对象和一个 `ReferenceQueue`，通过该弱引用是否被加入ReferenceQueue就可以判断该对象是否被回收。

- 分析

最后通过haha库来分析`hprof`文件，从而找出类之前的引用关系。



#编译期注解处理的是字节码还是java文件 O

应该是处理的Java文件，然后生成字节码

APT即为Annotation Processing Tool，它是javac的一个工具，中文意思为编译时注解处理器。APT可以用来在编译时扫描和处理注解。通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来自动的生成一些代码，省去了手动编写。注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。APT的核心是AbstractProcessor类。

ButterKnife，eventbus都使用了APT技术

#设计模式

##你在项目中有用到什么设计模式吗

##代理模式与装饰模式的区别，手写一个静态代理，一个动态代理,动态代理有什么用

>代理模式:

Java动态代理的优势是实现无侵入式的代码扩展，也就是方法的增强；让你可以在不用修改源码的情况下，增强一些方法；在方法的前后你可以做你任何想做的事情


1. 静态代理

想要生成代理类，需要让代理类和被代理类实现同一个接口，并且在代理类中添加被代理类的引用，代理类方法实现中添加代理逻辑，并决定是否调用被代理类方法，这种通过硬编码的方式指定代理类与被代理类的方式，叫静态代理。可以明显看出，**静态代理类与被代理类是耦合的，如果要代理100个类，你就得写100个代理类**

代码：

    public class RealTest{
    	public void doSomthing(){
    		system.out.print("原生方法");
    	}
    }
    
    public interface Test{
    	public void doSomthing();
    }
    
    public class TestProxy implements Test {
      Test t = new RealTest();
      public void doSomething() {
         t.doSomething();
      }
    }
刚开始我会觉得TestProxy定义出来纯属多余，直接实例化实现类完成操作不就结了吗？后来随着业务庞大，你就会知道，实现proxy类对真实类的封装对于粒度的控制有着重要的意义。但是静态代理这个模式本身有个大问题，如果类方法数量越来越多的时候，代理类的代码量是十分庞大的。所以引入动态代理来解决此类问题

3.动态代理

其实动态代理与静态代理的本质一样，最终程序运行时都需要生成一个代理对象实例，通过它来完成相关增强以及业务逻辑，只不过静态代理需要硬编码的方式指定，而动态代理则是以动态方式生成代理(编译时操作字节码以及运行时通过反射方式)。动态生成的好处很明显，代理逻辑与业务逻辑是互相独立的，没有耦合，代理1个类100个类没有任何区别

代码：

	public interface Subject   
	{   
	  public void doSomething();   
	}
	
	public class RealSubject implements Subject   
	{   
	  public void doSomething()   
	  {   
	    System.out.println( "call doSomething()" );   
	  }   
	}  
	
	public class ProxyHandler implements InvocationHandler
	{
	    private Object tar;
	
	    //绑定委托对象，并返回代理类
	    public Object bind(Object tar)
	    {
	        this.tar = tar;
	        //绑定该类实现的所有接口，取得代理类 
	        return Proxy.newProxyInstance(tar.getClass().getClassLoader(),
	                                      tar.getClass().getInterfaces(),
	                                      this);
	    }    
		@Override
	    public Object invoke(Object proxy , Method method , Object[] args)throws Throwable
	    {
	        Object result = null;
	        //这里就可以进行所谓的AOP编程了
	        //在调用具体函数方法前，执行功能处理
	        result = method.invoke(tar,args);
	        //在调用具体函数方法后，执行功能处理
	        return result;
	    }
	}
	public class TestProxy
	{
	    public static void main(String args[])
	    {
	           ProxyHandler proxy = new ProxyHandler();
	           //绑定该类实现的所有接口
	           Subject sub = (Subject) proxy.bind(new RealSubject());
	           sub.doSomething();
	    }
	}

Proxy类的代码量被固定下来，不会因为业务的逐渐庞大而庞大；可以实现AOP编程，实际上静态代理也可以实现，总的来说，AOP可以算作是代理模式的一个典型应用；解耦，通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。

>代理模式与装饰模式的区别

**装饰器模式应当为所装饰的对象提供增强功能，而代理模式对所代理对象的使用施加控制，并不提供对象本身的增强功能**。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

##AOP TODO待补充
传统面向对象思想中，如果想要实现功能复用，要么继承、要么引用，无论哪种方式，对代码都有一定的侵入性，耦合无可避免，侵入性啥意思？简单来说：如果你想要用它增强你程序的功能，你必须改动你的程序代码，那它就具有侵入性。如果只有一点两点需要增强还好说，如果大量的功能点需要被增强，工作量就会很大，代码也不太优雅。想象一下，如果你对外公开了一系列的接口，现在领导说了，接口要加权限控制。在哪加？最笨的当然就是写个程序验证的逻辑，然后每个接口都拿来调用一遍。这也正是面向对象思想的短板，在要为程序新增一些通用功能时，只能通过耦合的方式才能进行。AOP正是为此而生，AOP旨在通过一种无耦合的方式来为程序带来增强。而动态代理，就是AOP实现方式中的一种

---

#activity启动模式 O

启动模式（launchMode）在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例共用一个task。

> Activity一共有以下四种launchMode：

1. standard 标准启动模式
   * 默认的启动模式，每次启动activity都会创建新的实例。
2. singletop 栈顶复用模式  适合接收通知启动的内容显示页面
   * 当栈顶有将要开启的Activity时，会复用这个Activity，同时这个activity的onNewIntent方法会被回调。这个activity的onCreate方法不会被调用，因为它没有发生改变。若是栈顶没有，那么就会重新创建
   * 应用场景：适用于接收到消息后显示的界面。例如：QQ接收到消息后会弹出activity，但如果一次来10条消息，总不能一次弹出10个activity。  

3. singetask栈内复用模式，在当前任务栈里面只能有一个实例存在 适合作为程序入口点

   * 当一个启动模式为singleTask的activityA请求启动后，系统会先寻找是否存在A想要的任务栈（在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在），如果不存在，就重新创建一个任务栈，然后创建A的实例并将A放到栈中。如果存在A所需的任务栈，这时要看栈中有是否有要开启的activityA，如果有则直接复用并删除A上面的activity，将A移动到栈顶，同singletop一样，也会回调这个activity的onNewIntent方法。如果没有实例，则创建A实例并压入栈中

   * 现在有两个任务栈，前台任务栈中有BA，后台任务栈中有DC，假设DC启动启动模式都为singleTask。现在请求启动D，那么整个后台任务栈都会被切到前台，这时候前台任务栈为DCBA，当按back键时，前台栈中activity会一一出栈；如果请求启动C，那么情况就不一样了，会把D删除,C切换到前台。（具体看图——singleTask启动模式特例.pptx）
   * 所以这种启动模式通常可以用来退出整个应用程序。将主activity设为singleTask,然后在要退出的activity中转到主Activity，从而将主Activity上的其他activity全部清除，然后在主Activity中的onNewIntent()中加上finish(),将最后一个activity结束。

4. singleInstance 单实例模式，可以看作加强版singleTask模式

   * activity会开启一个新的任务栈，并且这个任务栈里面只有一个实例存在。
* 这种启动模式和浏览器的工作原理类似。当多个程序访问浏览器时，如果浏览器没有打开，则打开浏览器，否则会在当前打开的浏览器中访问。举个例子来说，当应用A的任务栈创建了ActivityA实例，并且其启动模式为sinleInstance，如果应用B也要激活ActivityA，则不需要创建，两个应用共享即可。    
   * 如果你要保证一个activity在整个手机操作系统里面只有一个实例存在，使用singleInstance
   * 关于singleInstance这种启动模式还有一点需要特殊说明:如果在一个singleInstance的activityA中通过startActivityForResult()去启动另一个activityB，那么在A中拿不到数据。因为android不允许task间互相传递数据。
   2. 以singleInstance模式启动的Activity在整个系统中是单例的，如果再启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。
   4. singleInstance模式的Activity开启的其他activity，新Activity会存放到已有的任务栈中(如果没设置新的任务栈的话)。

> onNewIntent()

通过这个方法可以取出当前请求的信息
第一次创建Activity A时，执行的逻辑顺序是：
    onCreate() ­­­>onStart()­­­>onResume()
而如果使用singleTask模式第二次启动Activity A，且A处于任务栈的顶端，则执行的逻辑顺序是：
    onNewIntent() ­­­>onRestart> onStart>onResume()。 
注意，getIntent()仍返回原来的意图。你可以使用setIntent来设置新的意图。

> FLAG

* FLAG_ACTIVITY_SINGLE_TOP：与launchMode = "singleTop"行为一致

* FLAG_ACTIVITY_NEW_TASK：如果设置taskAffinity，系统会查找有没有相应的栈存在，如果存在将Activity压入栈中，如果不存在，将Activity压入默认栈中

* FLAG_ACTIVITY_CLEAR_TOP：如果目标存在，直接复用，并清除目标以上的活动，否则重建。
* FLAG_ACTIVITY_NEW_TASK和FLAG_ACITIVTY_CLEAR_TASK = singleTask

# onCreate,onResume,onStart里面，什么地方可以获得宽高

如果在`onCreate、onStart、onResume`中直接调用View的`getWidth/getHeight`方法，是无法得到View宽高的正确信息，因为view的measure过程与Activity的生命周期是不同步的，所以无法保证在这些生命周期里view 的measure已经完成。所以很有可能获取的宽高为0。

所以主要有以下三个方法来获取view的宽高：

- view.post()方法

在该方法里的`runnable`对象，能保证view已经绘制完成，也就是执行完`measure、layout和draw`方法了。

> 为什么view.post可以获得宽高

能获取宽高的原因肯定就是因为在此之前view 绘制已经完成，所以`View.post()` 添加的任务能够保证在所有 View 绘制流程结束之后才被执行。

# APP启动流程

当冷启动 (应用进程不存在) 一个 app 时，首先要和 zygote 建立 socket 连接，将创建进程需要的参数发送给 zygote， zygote 服务端接收到参数之后调用 `ZygoteConnection.processOneCommand()` 处理参数，并 fork 出应用进程。最后通过 `findStaticMain()` 找到 `ActivityThread` 类的 `main()` 方法并执行，应用进程就启动了。

`ActivityThread` 虽然不是一个线程类，但它是运行在主线程的，你就把它认为是主线程也没有关系。在 `main()` 方法中， 创建了 `ActivityThread` 对象，调用其 `attach()` 方法，并开启了主线程消息循环，基于事件的消息队列机制就开始工作了。

在 `ActivityThread.attach()` 方法中，Binder 调用了 `AMS.attachApplication()` 方法，其中主要做了两件事：

1. 将当前进程与 AMS 进行绑定。然后再 Binder 调用回应用进程的 `ApplicationThread.bindApplication()` 方法，进行客户端的准备工作，创建 Context，创建 Application 等等
2. `mStackSupervisor.attachApplicationLocked(app)`，最终调用到 `realStartActivityLocked()` 启动 Activity

#Activity启动流程

1. `Luancher` 进程通过binder向AMS发起`startActivity`请求
2. AMS收到请求， `ActivityStarter`解析flag，启动模式等，`ActivityStack`处理activity栈
3. 然后AMS通过socket调用到`Zygote`，fork新的app进程
4. app进程创建后，再通过binder向AMS发起`attachApplication`请求
5. AMS通过binder调用发送`scheduleLaunchActivity`到app进程
6. APP进程的binder线程`ApplicationThread`接收到请求，通过handler发送`LAUNCH_ACTIVITY`消息到主线程
7. `ActivityThread`接收到消息，执行到`handleLaunchActivity`，开始Activity的生命周期

# intentService

intentService可以异步运行一个任务并在结束时自行终止。需要在一个单独的线程中执行的代码可以放在onHandleIntent()中，如从服务器下载数据，当代码执行完毕，线程被终止，服务自行停止。

是通过HandlerThread来实现耗时操作的

> HandlerThread

`HandlerThread`继承Thread，内置了Handler和Looper，在run方法中创建了looper对象，这也是为什么在IntentService中能在HandlerThread中直接用handler的原因。

# 广播与RxBus的区别，全局广播与局部广播区别

本地广播：广播事件的发送和接收都在本应用，不能跨进程(APP内部进程也不能跨)，只能动态注册，不能静态注册--使用Handler通信机制

全局广播：广播事件的发送和接收都在本应用可以跨应用，全局广播既可以动态注册，也可以静态注册--采用的binder方式实现跨进程间的通信

广播是四大组件之一，可以直接获取上下文，比较消耗资源，Rxbus不能跨进程，耦合性低，比广播更轻量，书写简便。可实现粘性事件

#attachToWindow什么时候调用？

attachToWindow在onResume之后调用，onDetachFromWindow() 在页面退出的时候都会被调用

```
MainActivity打开
MainActivity: onCreate
MainActivity: onStart
MainActivity: onResume
MainActivity: onAttachedToWindow
MainActivity: onViewAttachedToWindow(界面View设置的监听)
点击home键
MainActivity: onPause
MainActivity: onStop
恢复展示
MainActivity: onRestart
MainActivity: onStart
MainActivity: onResume
关闭
MainActivity: onPause
MainActivity: onStop
MainActivity: onDestroy
MainActivity: onViewDetachedFromWindow
MainActivity: onDetachedFromWindow


MainActivity打开
MainActivity: onCreate
MainActivity: onStart
MainActivity: onResume
MainActivity: onAttachedToWindow
MainActivity: onViewAttachedToWindow
SecondActivity打开
MainActivity: onPause
SecondActivity: onCreate
SecondActivity: onStart
SecondActivity: onResume
SecondActivity: onAttachedToWindow
MainActivity: onStop
SecondActivity关闭
SecondActivity: onPause
MainActivity: onRestart
MainActivity: onStart
MainActivity: onResume
SecondActivity: onStop
SecondActivity: onDestroy
SecondActivity: onDetachedFromWindow
```

# Bitmap高效加载



#setOnTouchListener,onClickeListener和onTouchEvent的关系

setOnTouchListener-onTouch
onClickeListener-onClick

onTouch在dispatchTouchEvent()方法中调用

    public boolean dispatchTouchEvent(MotionEvent event) {      
    	if (onFilterTouchEventForSecurity(event)) {        
    		if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
                		result = true;        
    		}        
    		if (!result && onTouchEvent(event)) {
    	            result = true;        
    		}   
    	}     
    	return result;
    }

当设置了setOnTouchListener(),li和mOnTouchListener会被初始化，不为null，前两个条件成立，所以当onTouch()方法返回值为true，就不会执行onTouchEvent(event)方法，返回false会执行。

接下来看onTouchEvent的源码

	public boolean onTouchEvent(MotionEvent event) {
	     if (((viewFlags & CLICKABLE)  ==  CLICKABLE  ||(viewFlags & LONG_CLICKABLE)  ==  LONG_CLICKABLE) 
	        || (viewFlags & CONTEXT_CLICKABLE)  ==  CONTEXT_CLICKABLE) {
	           switch (action) {
	               case MotionEvent.ACTION_UP:                           
	                //如果执行了该方法，其返回值就是onTouchEvent()的返回值                
	                performClick();                             
	                break;        
	            }        
	        return true;    
	    }    
	    return false;
	}
在performClick方法中调用了mOnClickListener.onClick(this)方法。只要我们在代码中通过 setOnClickListener() 方法设置了对单击事件的监听，则对应 View 的 onTouchEvent() 方法返回 true，当然事件就此消费，反之返回 false
>总结：

onTouch() 方法的返回值决定了 onTouchEvent() 方法要不要执行，如果 onTouch() 返回 true，则 onTouchEvent() 不会再执行，返回 false ,则 onTouchEvent() 继续执行，而 onClick() 的回调是在 onTouchEvent() 方法中调用，onTouchEvent() 不执行则 onClick() 不执行。

#事件分发机制

![事件分发机制.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6.png?raw=true)

view的分发事件是从view的`Viewgroup(Parent)#dispatchTouchEvent`到`Viewgroup(Parent)#onInterceptTouchEvent`再到`View#dispatchTouchEvent`，然后到view的`onTouchEvent`，最后又回到了`Viewgroup(Parent)#onTouchEvent`

如果viewgroup不进行分发，那么`action_down`、`action_move`和`action_up`只会执行到viewgroup的`dispatchTouchEvent`，不分发的条件是`dispatchTouchEvent`直接返回true或false，true和false的区别是true会执行`action_down`、`action_move`和`action_up`，而如果直接返回false只会执行到action_down。并且后续的viewgroup的`onInterceptTouchEvent`后续方法都不会被执行到。

View事件分发是对MotionEvent事件分发，最终传递给一个View的过程

dispatchTouchEvent：方法返回值为true表示事件被当前视图消费掉；返回为super.dispatchTouchEvent表示继续分发该事件，返回为false表示交给父类的onTouchEvent处理。

onInterceptTouchEvent：方法返回值为true表示拦截这个事件并交由自身的onTouchEvent方法进行消费；返回false表示不拦截，需要继续传递给子视图。如果return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: 　

- 1.如果该View存在子View且点击到了该子View, 则不拦截, 继续分发 给子View 处理, 此时相当于return false。
- 2.如果该View没有子View或者有子View但是没有点击中子View(此时ViewGroup 相当于普通View), 则交由该View的onTouchEvent响应，此时相当于return true。

注意：一般的LinearLayout、 RelativeLayout、FrameLayout等ViewGroup默认不拦截， 而 ScrollView、ListView等ViewGroup则可能拦截，得看具体情况。

onTouchEvent：方法返回值为true表示当前视图可以处理对应的事件；返回值为false表示当前视图不处理这个事件，它会被传递给父视图的onTouchEvent方法进行处理。如果return super.onTouchEvent(ev)，事件处理分为两种情况：

- 1.如果该View是clickable或者longclickable的,则会返回true, 表示消费 了该事件, 与返回true一样;
- 2.如果该View不是clickable或者longclickable的,则会返回false, 表示不 消费该事件,将会向上传递,与返回false一样。

注意：在Android系统中，拥有事件传递处理能力的类有以下三种：

- Activity：拥有分发和消费两个方法。
- ViewGroup：拥有分发、拦截和消费三个方法。
- View：拥有分发、消费两个方法。

对应一个根ViewGroup来说，点击事件产生后，首先会传递给它，这是它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，这时如果它的mOnTouchListener被设置，则onTouch会被调用，否则onTouchEvent会被调用。在onTouchEvent中，如果设置了mOnCLickListener，则onClick会被调用。只要View的CLICKABLE和LONG_CLICKABLE有一个为true，onTouchEvent()就会返回true消耗这个事件。如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。



一些重要的结论：

1、事件传递优先级：onTouchListener.onTouch > onTouchEvent > onClickListener.onClick。

2、正常情况下，一个事件序列只能被一个View拦截且消耗。因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不会再调用这个View的拦截方法去询问它是否要拦截了，而是把剩余的ACTION_MOVE、ACTION_DOWN等事件直接交给它来处理）。

4、ViewGroup默认不拦截任何事件（返回false）。

5、View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable默认为false。

6、View的enable属性不影响onTouchEvent的默认返回值。

7、通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。

> 手势操作ActionCancel后怎么取消  TODO

- 一般ACTION_CANCEL和ACTION_UP都作为View一段事件处理的结束。如果在父View中拦截ACTION_UP或ACTION_MOVE，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到ACTION_CANCEL事件。
- 如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现action_cancel。

> 点击事件被拦截，但是想传到下面的View，如何操作？

重写子类的requestDisallowInterceptTouchEvent()方法返回true就不会执行父类的onInterceptTouchEvent()，即可将点击事件传到下面的View。

> 如何解决View的事件冲突？举个开发中遇到的例子？

常见开发中事件冲突的有ScrollView与RecyclerView的滑动冲突、RecyclerView内嵌同时滑动同一方向。

滑动冲突的处理规则：

- 对于由于外部滑动和内部滑动方向不一致导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件。
- 对于由于外部滑动方向和内部滑动方向一致导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件，何时由内部View拦截事件。
- 对于上面两种情况的嵌套，相对复杂，可同样根据需求在业务上找到突破点。

滑动冲突的实现方法：

- 外部拦截法：指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。具体方法：需要重写父容器的onInterceptTouchEvent方法，在内部做出相应的拦截。
- 内部拦截法：指父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法：需要配合requestDisallowInterceptTouchEvent方法。

> 实现一个不能滑动的ViewPager

onInterceptTouchEvent()方法和onTouchEvent()方法，这两个方法的返回值都是boolean类型的，只需要将返回值改为false，那么ViewPager就不会消耗掉手指滑动的事件了

#View绘制流程
View的工作流程主要是指measure、layout、draw这三大流程，其中measure确定View的测量宽/高，layout确定View的最终位置，而draw则将View绘制到屏幕上
##自定义圆角图片
>BitmapShader实现

	public class RoundImageViewByBitmapShader extends ImageView {
	
	  private Shader mShader;
	  private Paint mPaint;
	
	  public RoundImageViewByBitmapShader(Context context) {
	    super(context);
	  }
	
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs) {
	    super(context, attrs);
	  }
	
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
	    super(context, attrs, defStyleAttr);
	  }
	
	  @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
	    super(context, attrs, defStyleAttr, defStyleRes);
	  }
	
	  @Override
	  protected void onDraw(Canvas canvas) {
	    BitmapDrawable drawable = (BitmapDrawable) getDrawable();
	    if (mShader == null) {
	      mShader = new BitmapShader(drawable.getBitmap(), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
	      mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
	    }
	    mPaint.setShader(mShader);
	    canvas.drawRoundRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), 100, 100, mPaint);
	  }
	}

>Xfermode

	public class RoundedImageViewByXfermode extends ImageView {
	
	  private Paint mPaint;
	  private Xfermode mXfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);
	  private RectF mRectF;
	  private Bitmap mBitmap;
	
	  public RoundedImageViewByXfermode(Context context) {
	    this(context, null);
	  }
	
	  public RoundedImageViewByXfermode(Context context, @Nullable AttributeSet attrs) {
	    this(context, attrs, 0);
	  }
	
	  public RoundedImageViewByXfermode(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
	    super(context, attrs, defStyleAttr);
	    init();
	  }
	
	  @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
	  public RoundedImageViewByXfermode(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
	    super(context, attrs, defStyleAttr, defStyleRes);
	  }
	
	  private void init() {
	    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
	  }
	
	  @Override
	  protected void onDraw(Canvas canvas) {
	    canvas.saveLayer(0, 0, getMeasuredWidth(), getMeasuredHeight(), null, Canvas.ALL_SAVE_FLAG);
	    Drawable drawable = getDrawable();
	    if (mBitmap == null) {
	      mBitmap = Bitmap.createBitmap(getMeasuredWidth(), getMeasuredHeight(), Bitmap.Config.ARGB_8888);
	      Canvas drawCanvas = new Canvas(mBitmap);
	      drawable.draw(drawCanvas);
	    }
	    if (mRectF == null) {
	      mRectF = new RectF(0, 0, getMeasuredWidth(), getMeasuredHeight());
	    }
	    mPaint.setXfermode(null);
	    canvas.drawRoundRect(mRectF, 100, 100, mPaint);
	    mPaint.setXfermode(mXfermode);
	    canvas.drawBitmap(mBitmap, 0, 0, mPaint);
	    canvas.restore();
	  }
	}
先绘制Dst图层和src图层，然后根据规则设置不同的Xfermode，从而达到裁剪图层的效果


#Handler机制
##简单描述下Handler机制？一个线程有几个Looper？为什么？
Handler机制由MessageQueue，Message，Looper，Handler组成。Handler的主要作用是发送和处理消息；MessageQueue称作消息队列，采用单链表的数据结构存储Message；Looper是一个循环，会在一个无限循环中不断从MessageQueue中获取Message，如果有Message，就交给对应的Handler去处理；Message是传递的消息，它的target参数持有是发送它的Handler对象。Handler通过sendMessage()发送消息Message到消息队列MessageQueue。Looper通过loop()不断提取触发条件的Message，并将Message交给对应target的handler来处理。handler调用自身的handleMessage()方法来处理Message。

一个线程只有1个Looper，是通过ThreadLocal来保证的

##Handler内存泄漏的GCRoot是什么？

ThreadLocal静态变量作为gcRoot，导致activity无法被回收

handler的内存泄漏原因：

1. 当直接在activity中声明handler时，由于后面的匿名内部类，使handler持有了activity的引用。
2. 当任务未执行完，即message未被执行完时，message持有了messageQueue的引用。
3. messageQueue持有了mLooper的引用。
4. mLooper持有sThreadLocal 的引用。
5. sThreadLocal 是一个静态变量，无法被回收，最终导致了activity无法被回收，造成了内存泄漏。

##Handler休眠是怎样的？epoll的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？

Handler消息机制的休眠和唤醒是通过native层的epoll机制和pipe机制来实现的(也就是线程的休眠和唤醒)



在Linux系统内核中，所有执行I/O操作的系统调用都会通过文件描述符。内核利用文件描述符来访问文件，文件描述符是非负整数。

pipe是Linux中最基本的一种IPC机制，可以用来实现进程、线程间通信。

pipe其本质是一个伪文件，它有两个文件描述符引用，一个表示读端，一个表示写端，规定数据从管道的写端流入管道，从读端流出。

Handler机制中，底层使用pipe创建两个fd：writeFD、readFD。当线程A想唤醒线程B的时候，就可以往writeFD中写数据，这样线程B阻塞在readFD中就能返回。 也就是说，当文件描述符指向的文件（内核缓冲区）为空时，则线程进行休眠。当另一个线程向缓冲区写入内容时，则将当前线程进行唤醒。

epoll机制是linux内核实现IO多路复用的一个实现。IO多路复用的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。



UI线程进入Looper的无限循环之后，为什么没有ANR，是因为底层使用了Linux的epoll机制和pipe实现了线程在空闲时的休眠，并且不会占用系统CPU资源。

> Message是根据什么排序的

是根据when字段排序的，when=系统开机时间+delayMillis

##Handler是怎么切换线程的,Handler同步屏障

> 同步屏障

Handler中的Message可以分为两类：同步消息，异步消息，一般我们直接发送的消息都是同步消息，只有在msg.setAsynchronous(true)时，发送的消息都会变成异步消息。

一般来说这两种消息没有什么区别，只有在设置了同步屏障时才会出现差异。

可通过mHandler.getLooper().getQueue().postSyncBarrier()设置同步屏障。设置同步屏障后，设置了一个 target 字段为空的 Message到消息队列，loop循环会遍历找到异步消息去处理

Handler设置同步屏障之后，Looper只会获取和处理异步消息，如果没有异步消息会进入阻塞状态。

>Handler线程切换

在A线程正常创建handlerA，然后在B线程中利用handlerA发送消息，此时消息就发送给与handlerA关联的Looper了，而这个Looper唯一关联的线程就是A，这样我们的消息就会在A线程中执行了

# Binder机制

* 基于C/S架构，包括`Server`、`Client`、`ServiceManager`和`Binder`驱动，其中`Binder`驱动运行在内核空间，其他的运行在用户空间

* ServiceManager负责服务管理，服务端向`ServiceManager`注册后，客户端可以向`ServiceManager`查询获取到目标服务的引用

* Binder驱动：负责进程之间的`Binder`通信的建立，基于内存映射技术，传统的通信方式需要将数据从用户空间拷贝到内核空间，然后从内核空间拷贝到目标进程的用户空间，需要两次拷贝，`Binder`驱动可以建立用户空间内存和内核空间内存的一个映射，只需要一次拷贝，非常高效。

# Kotlin

##kotlin的扩展方法是怎么实现的，inline关键字的作用

- 扩展方法编译成java后，实际上是一个 public static的静态方法，传入了对象实例和参数
- Inline关键字修饰的函数是内联函数，用于优化函数调用的压栈操作，相当于在编译期间把内联函数的代码拷贝到函数调用处，可以提升性能，但是增加了代码量

##你对协程的理解，协程有什么作用？可以完全取代rxjava吗？协程怎么取消？协程可以在Java项目中使用吗？

协程和线程一样都是用来解决`并发任务（异步任务）`的方案。 所以协程和线程是属于一个层级的概念，但是对于`kotlin`中的协程，又与广义的协程有所不同。 kotlin中的协程其实是对线程的一种`封装`，或者说是一种线程框架，为了让异步任务更好更方便使用。



协程：一套基于线程而实现的上层API。优点：异步变同步

suspend 挂起函数，可在挂起函数中执行子线程操作，挂起函数执行完成后，也会继续执行下面的代码

>协程怎么取消

```kotlin
val job1 = scope.launch { … }
val job2 = scope.launch { … }
scope.cancel()
```

但是调用了`cancel`并不代表协程内的工作会马上停止，他并不会组织代码运行。 比如上述的`job1`，正常情况处于`active `状态，调用了`cancel`方法后，协程会变成`Cancelling `状态，工作完成之后会变成`Cancelled` 状态，所以可以通过判断协程的状态来停止工作。


作者：积木zz
链接：https://juejin.im/post/6888222422760488974
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

##协程的scope与context，协程的+号代表什么

# 性能优化

## 启动速度的优化

Application的attachBaseContext和onCreate，三方sdk采用线程池异步初始化，activity的onCreate中，设置布局的优化（xml的io操作、反射创建view的操作，通过异步inflater和自定义inflater.factory来优化）

1. 延迟初始化非必要的库，拓展到异步启动器的设计和实现，有向无环图来解决库依赖的问题。
2. 给闪屏页设置图片背景避免冷启动白屏，其实不能加快启动，只是避免白屏给用户的体验不佳

## 包大小优化

1，开启混淆压缩代码 2，压缩和混淆资源，图片压缩采用webP格式，整理Raw、assets资源 3，减少非必要so库，目前主流的机型都是支持armeabi-v7a的，并且armeabi-v7a兼容armeabi 4，移除未使用的资源，如图标，字符串，字体等 5，一些小图像可以使用矢量图，大矢量图渲染时间很长，不适用 6，减少三方库使用，避免枚举的使用 7，动态下发一些资源，如换肤包，so，字体等

## 内存优化

内存泄露优化（包括常见的内存泄漏、分析方法、LeakCanrary等）、使用优化的数据结构（ArrayMap和SparseArray），对频繁创建的对象使用对象池技术，减少不必要的内存开销

> 看视频的时候网络请求很慢怎么优化？

HttpDNS优化，传统DNS解析一般是用UDP的方式与DNS服务器交互，HttpDNS采用Http协议交互，绕过运营商的 LocalDNS 服务器，有效的防止了域名劫持，提高域名解析的效率

使用缓存，需要服务端支持，或者通过OkHttp拦截器添加统一的缓存策略

HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。在HTTP1.1中默认开启keep-alive

数据压缩，gzip压缩，http2.0也支持header的压缩

根据网络质量来下载不同质量的图片

> App上线后用户使用时卡顿怎么查看是什么原因

#说说MVP和MVVM的特点

`MVP`:主要是分离了M层和V层的代码，通过P层来建立他们的关联，实现M层和V层的解耦。缺点就是每增加一个功能，需要增加相应的接口回调。MVP的核心就是通过接口实现隔离，将相关的业务层交给了P层。

如果要细说mvp需要注意几点:

- p层的逻辑处理单一的功能，不要融合一个模块下的增删改查的整个功能。
- 由于p层持有了v层的引用，通常在p层使用弱引用来持有view层实例，在p层销毁的时候需要将v层的引用销毁掉。
- 契约类指的p层和v层的接口类放在一个contract接口类中，契合类方便管理业务层的功能，将单个功能放到一个contract契合类中。

`MVVM`:主要是用到了观察者模式，通过数据的改变来通知相应的View改变的过程。M层和上面的MVP中的M层是一样的，都是网络请求+数据缓存来实现该层的，里面的VM是ViewModel实现的，ViewModel层获取到M层的数据后，通过观察者模式通知UI的改变。

#android中用到的观察者模式有哪些地方

观察者模式是由一个被观察者和一个观察者构成的、被观察者在状态改变时（用户操作、程序主动改变等）主动通知所有观察者作相应的刷新。 android中最经典要说ListView的数据源发生变化了，刷新列表的事例。在setAdapter的时候，生成一个`AdapterDataSetObserver`，紧接着就是订阅上该观察者，该观察者`onChange`方法里面有`requestLayout`方法，该方法是触发UI发生变化的方法。在`BaseAdapter`里面可以看到`notifyDataSetChanged`实际上触发的是`DataSetObservable`被观察者的`notifyChanged`方法，`notifyChanged`会触发`AdapterDataSetObserver`的`onChange`方法。所以最终会走listView的`requestLayout`，最后刷新了UI。

3说说google新出的Lifecycle框架

将类的生命周期方法移交到Lifecycle中管理，实现对类的生命周期的监听，从而在Lifecycle中处理生命周期的逻辑代码。这里涉及到几个对象: `LifecycleObserver接口`（ Lifecycle观察者）：实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。 `LifecycleOwner接口`（Lifecycle持有者）：实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。 `Lifecycle`(生命周期)：和LifecycleOwner不同的是，LifecycleOwner本身持有Lifecycle对象，LifecycleOwner通过其Lifecycle getLifecycle()的接口获取内部Lifecycle对象。 `State`(当前生命周期所处状态)：几种事件状态。 `Event`(当前生命周期改变对应的事件)：当Lifecycle发生改变，事件状态的回调event。

# RecyclerView

> Recyclerview缓存

Recycleview有四级缓存，分别是`mAttachedScrap(屏幕内)，mCacheViews(屏幕外)，mViewCacheExtension(自定义缓存)，mRecyclerPool(缓存池)`

- `mAttachedScrap(屏幕内)`，用于屏幕内itemview快速重用，不需要重新createView和bindView
- `mCacheViews(屏幕外)`，保存最近移出屏幕的ViewHolder，包含数据和position信息，复用时必须是相同位置的ViewHolder才能复用，应用场景在那些需要来回滑动的列表中，当往回滑动时，能直接复用ViewHolder数据，不需要重新bindView。
- `mViewCacheExtension(自定义缓存)`，不直接使用，需要用户自定义实现，默认不实现。
- `mRecyclerPool(缓存池)`，当cacheView满了后或者adapter被更换，将cacheView中移出的ViewHolder放到Pool中，放之前会把ViewHolder数据清除掉，所以复用时需要重新bindView。

四级缓存按照顺序需要依次读取。所以**完整缓存流程**是：

1. 保存缓存流程：

- 插入或是删除`itemView`时，先把屏幕内的ViewHolder保存至`AttachedScrap`中
- 滑动屏幕的时候，先消失的itemview会保存到`CacheView`，CacheView大小默认是2，超过数量的话按照先入先出原则，移出头部的itemview保存到`RecyclerPool缓存池`（如果有自定义缓存就会保存到自定义缓存里），RecyclerPool缓存池会按照itemview的`itemtype`进行保存，每个itemTyep缓存个数为5个，超过就会被回收。

1. 获取缓存流程：

- AttachedScrap中获取，通过pos匹配holder——>获取失败，从`CacheView`中获取，也是通过pos获取holder缓存

——>获取失败，从`自定义缓存`中获取缓存——>获取失败，从`mRecyclerPool`中获取 ——>获取失败，重新创建`viewholder`——createViewHolder并bindview。

需要注意的是，如果从缓存池找到缓存，还需要重新bindview。

> RecyclerView性能优化

- `bindViewHolder`方法是在UI线程进行的，此方法不能耗时操作，不然将会影响滑动流畅性。比如进行日期的格式化。
- 对于新增或删除的时候，可以使用`diffutil`进行局部刷新，少用全局刷新
- 对于`itemVIew`进行布局优化，比如少嵌套等。
- 25.1.0 (>=21)及以上使用` Prefetch` 功能，也就是预取功能，嵌套时且使用的是LinearLayoutManager，子RecyclerView可通过setInitialPrefatchItemCount设置预取个数
- 加大`RecyclerView缓存`，比如cacheview大小默认为2，可以设置大点，用空间来换取时间，提高流畅度
- 如果高度固定，可以设置`setHasFixedSize(true)`来避免requestLayout浪费资源，否则每次更新数据都会重新测量高度。

```java
void onItemsInsertedOrRemoved() {
   if (hasFixedSize) layoutChildren();
   else requestLayout();
}
```

- 如果多个` RecycledView` 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 `RecyclerView.setRecycledViewPool(pool); `来共用一个 `RecycledViewPool`。这样就减少了创建VIewholder的开销。
- 在RecyclerView的元素比较高，一屏只能显示一个元素的时候，第一次滑动到第二个元素会卡顿。这种情况就可以通过设置额外的缓存空间，重写`getExtraLayoutSpace`方法即可。

```java
new LinearLayoutManager(this) {
    @Override
    protected int getExtraLayoutSpace(RecyclerView.State state) {
        return size;
    }
};
```

- 设置`RecyclerView.addOnScrollListener();`来在滑动过程中停止加载的操作。
- 减少对象的创建，比如设置监听事件，可以全局创建一个，所有view公用一个listener，并且放到`CreateView`里面去创建监听，因为CreateView调用要少于bindview。这样就减少了对象创建所造成的消耗
- 用`notifyDataSetChange`时，适配器不知道整个数据集中的那些内容以及存在，再重新匹配`ViewHolder`时会花生闪烁。设置adapter.setHasStableIds(true)，并重写`getItemId()`来给每个Item一个唯一的ID，也就是唯一标识，就使itemview的焦点固定，解决了闪烁问题。





#RxJava 

> 线程切换原理

- RxJava通过`subscribeOn`指定被观察者发生的线程，`observeOn`指定观察者发生的线程。其中Schedulers.IO生成的是`IoScheduler`。通过观察者与被观察者订阅的过程中，首先会触发被观察者的`subscribeActual`方法，在该方法中，可以看到最终会走`scheduler`的`schedule`方法，所以上面提到的`IoScheduler`实际是调用了它的`schedule`方法，最终会在`NewThreadWorker`里面生成`ScheduledExecutorService`对象，而`ScheduledExecutorService`实际是由`ScheduledThreadPoolExecutor`创建的一个核心线程，最大线程个数是Integer.MAX_VALUE的线程池。最终会由`ScheduledThreadPoolExecutor`的`submit`或`schedule`方法执行传过来的Runnable对象，而Runnable执行的是被观察者的`subscribe`方法。所以解释了被观察者的`subscribe`方法是在子线程中执行的。
- `observeOn`是观察者发生的线程，`AndroidSchedulers.mainThread()`实质是`HandlerScheduler`对象，而在观察者部分，最终观察部分会走Scheduler的`scheduleDirect`方法，而`HandlerScheduler`的该方法里面包装了一个`ScheduledRunnable`对象，通过主线程的handler.postDelayed处理这个runnable对象。

> map关键字的作用是什么



#Eventbus源码

EventBus 发布/订阅事件的总线框架，基于观察者模式，将事件的接收者和发送者分开，基本包括了如下几个步骤:

注册事件的订阅方法:该步骤主要是找到订阅者下面有哪些方法需要被订阅

订阅操作:将需要被订阅的方法放到类似HashMap的数据结构中存储起来，方便后面发送事件和取消注册等资源的释放的时候使用

发送事件:该步骤首先遍历事件队列，然后从队列中取出事件，并且将事件从队列中移除，拿到事件后，判断事件处于的什么线程，如果是非UI线程，则需要Handler去处理，如果是的话，则直接通过反射调用被观察的方法。

反注册:该步骤就没什么好说的，主要是上面存储到HashMap中的被订阅的方法的移除，释放在内存中的资源。

#项目有什么难点？

# 单元测试

> Robolectric environment 测试跟Android相关使用的框架

```
@RunWith(RobolectricTestRunner.class)
@Config(application = RoboApp.class)
public class SharedPreferenceDaoTest {

    public static final String TEST_KEY = "instrumentedTest";
    public static final String TEST_STRING = "玉刚说";

    SharedPreferenceDao spDao;

    @Before
    public void setUp() {
        //这里的Context采用RuntimeEnvironment.application来替代应用的Context
        spDao = new SharedPreferenceDao(RuntimeEnvironment.application);
    }

    @Test
    public void sharedPreferenceDaoWriteRead() {
        spDao.put(TEST_KEY, TEST_STRING);
        Assert.assertEquals(TEST_STRING, spDao.get(TEST_KEY));
    }

}
```



> Mockito framework       测试跟Android不太相关使用的框架

```
@RunWith(MockitoJUnitRunner.class)
public class UnitTestSample {
	@Mock
    Context mMockContext;

    @Test
    public void readStringFromContext_LocalizedString() {
        //模拟方法调用的返回值，隔离对Android系统的依赖
        when(mMockContext.getString(R.string.app_name)).thenReturn(FAKE_STRING);
        assertThat(mMockContext.getString(R.string.app_name), is(FAKE_STRING));
        
        when(mMockContext.getPackageName()).thenReturn("com.jdqm.androidunittest");
        System.out.println(mMockContext.getPackageName());
    }
｝
```



#APP打包经过了哪几个流程

- 打包资源文件，通过AAPT(Android Asset Packaging Tool)打包成R.java类(资源索引表)以及.arsc资源文件。
- 处理AIDL文件，检查app中是否有aidl文件，如果有会通过aidl工具(源码位于system/tools/aidl）打包成java接口类
- 编译R.java源码部分以及aidl.java通过javac生成对应的.class文件。
- 将上面生成的.class文件和第三方jar或者library通过dx工具打包生成dex文件。
- 生成未签名的apk，包括apkbuilder工具将所有没有编译的资源、.arsc资源、.dex文件打包到一个完成apk文件中
- 生成签名的apk，包括jarsigner工具对未签名的apk验证签名。得到一个签名后的apk（signed.apk）
- zipAlign工具对齐上面签名的apk文件。

# 网络

> HTTP3.0有什么改进

> 网络封装怎么实现？如果让你写一个网络框架，你怎么写

> 三次握手，四次挥手

客户端简称A，服务器端简称B 

1）TCP建立连接需要三次握手

- A向B表示想跟B进行连接（A发送`syn`包，A进入`SYN_SENT`状态）
- B收到消息，表示我也准备好和你连接了（B收到`syn`包，需要确认`syn`包，并且自己也发送一个`syn`包，即发送了`syn+ack`包，B进入`SYN_RECV`状态）
- A收到消息，并告诉B表示我收到你也准备连接的信号了（A收到`syn+ack`包，向服务器发送确认包`ack`，AB进入`established`状态）开始连接。

2）TCP断开连接需要四次挥手

- A向B表示想跟B断开连接（A发送`fin`，进入`FIN_WAIT_1`状态）
- B收到消息，但是B消息没发送完，只能告诉A我收到你的断开连接消息（B收到fin，发送ack，进入`CLOSE_WAIT`状态，A进入`FIN-WAIT-2`状态）
- 过一会，B数据发送完毕，告诉A，我可以跟你断开了（B发送fin，进入`LAST_ACK`状态，A进入`TIME-WAIT`状态）
- A收到消息，告诉B，可以他断开（A收到fin，发送ack，B进入`closed`状态）

为什么连接需要三次，而不是两次。 正常来说，我给你发消息，你告诉我能收到，不就代表我们之前通信是正常的吗？

- 简单回答就是，`TCP是双向通信协议`，如果两次握手，不能保证B发给A的消息正确到达。

TCP 协议为了实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要重发。

TCP是怎么保证可靠传输的？

- `序列号和确认号`。比如连接的一方发送一段80byte数据，会带上一个序列号，比如101。接收方收到数据，回复确认号181（180+1），这样下一次发送消息就会从181开始发送了。

所以握手过程中，比如A发送syn信号给B，初始序列号为120，那么B收到消息，回复`ack`消息，序列号为120+1。同时B发送`syn`信号给A，初始序列号为256，如果收不到A的回复消息，就会重发，否则丢失这个序列号，就无法正常完成后面的通信了。

这就是三次握手的原因。

-------



待删除



事件分发主要分三块:分发、拦截、消费；
当我们触摸到屏幕的时候，默认会先走Activity的分发，接着走ViewGroup的分发，然后到ViewGroup的拦截，后面再到View的分发事件，最后会传到View的消费事件，如果View不消费，紧接着回传到ViewGroup的消费事件，如果ViewGroup也不消费，最后回到View的消费事件。整个事件分发构成了一个u型结构，下面总结了分发的细节流程：

如果ViewGroup的dispatchTouchEvent返回true或false，touch事件不会往子view中传递，false的时候只会触发action_down，ViewGroup的onTouchEvent事件也不会被触发。只有在返回super.dispatchTouchEvent时候touch事件才会传递到子view。
如果ViewGroup的onInterceptTouchEvent返回false或者super.onInterceptTouchEvent时，touch事件会传递到子view。返回true事件不会向下传递，交给自己的ontouchEvent处理。
如果view的dispatchTouchEvent返回true或false，touch事件不会传给自己的ontouchEvent事件，返回false，只会触发action_down，move和up不会触发；返回true，才会触发move和up。返回super.dispatchTouchEvent，touch事件才会交给自己的onTouchEvent处理。
如果view的ontouchEvent返回false，只会有action_down事件，touch事件交给上一层处理，如果返回true才会消费，事件不会向上传递，如果返回super.ontouchEvent，得看clickable是不是返回true。

App启动流程

从Linux内核系统到init进程的分裂，以及后面会启动一个叫Zygote的进程开始，而Zygote会分裂出系统的核心服务进程SystemServer，也就是SystemServer里面包括了底层的ActivityManagerService、PackageManagerService、WindowManagerService等，这些核心服务都是通过Zygote.init启动的，ActivityManagerService就是我们后面通过binder的ipc通信机制来与客户端ActivityThread建立通信的。
当我们点击了应用之后，系统的Launcher应用会通过startActivity的方式启动应用，而Intent的获取会经过如下几部:
(1) ActivityManagerService会通过PackageManager的resolveIntent()收集这个intent对象的指向信息。
(2)指向信息被存储在一个intent对象中。
(3)下面重要的一步是通过grantUriPermissionLocked()方法来验证用户是否有足够的权限去调用该intent对象指向的Activity。
(4)如果有权限, ActivityManagerService会检查并在新的task中启动目标activity.
(5)现在, 是时候检查这个进程的ProcessRecord是否存在了。
所以如果ProcessRecord不是null，ActivityManagerService会创建新的进程来实例化该activity。
ActivityManagerService调用startProcessLocked()方法来创建新的进程, 该方法会通过前面讲到的socket通道传递参数给Zygote进程. Zygote孵化自身, 并调用ZygoteInit.main()方法来实例化ActivityThread对象并最终返回新进程的pid。
随后就是我们熟悉的ActivityThread.main方法通过Looper.prepare和Looper.loop方法开启消息循环
紧接着就是创建Application对象的过程，先是创建好ContextImpl对象，然后通过makeApplication方法将app进程与Application建立联系，这里的Application创建交给了Instrumentation的对象，其实后面activity的创建，生命周期的回调都是通过它来触发的。
创建完Application后，紧接着就是我们熟悉的Activity，activity的创建同样交给了Instrumentation对象，上面说过ActivityManagerService会将携带的Intent对象交给了Lanucher应用，Lanucher的startActivity经过一系列的操作，最终会走Instrumentation的execStartActivity方法，该方法里面会去请求ActivityManagerService服务，最终通过binder通信将信息传给了客户端的ApplicationThread，最终会触发ApplicationThread的scheduleLaunchActivity方法，该方法将消息发送给了ActivityThread的handler对象，最终交给了Instrumentation对象创建activity。后面也就触发一系列的生命周期方法。

作者：xiangcman
链接：https://juejin.im/post/6844903961099501581
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


Touch 事件发生时，事件总是先传递给Activity，Activity然后在传递给Window，最后Window再传递给顶层View(DecorView)，并由该 View 的 dispatchTouchEvent(MotionEvent ev) 方法对事件进行分发。
    public boolean dispatchTouchEvent (MotionEvent ev)     分发
        true  事件被当前view消耗,停止向下传递
        false 事件传递给当前view的 onInterceptTouchEvent()
    public boolean onInterceptTouchEvent (MotionEvent ev)  拦截    
        true  事件被拦截，并传递给当前view的onTouchEvent()   
        false 事件传递给子view的dispatchtouchevent()
     public boolean onTouchEvent(MotionEvent ev)           处理
        true  处理该事件，不想上传递
        false 事件会从当前 View 向上传递，并且都是由上层 View 的 onTouchEvent 来接收，
            如果传递到最上面的 onTouchEvent也返回false，这个事件就会“消失”，而且接收不到下一次事件。

    1. View和Activity都没有onInterceptTouchEvent方法
    2. 事件传递的返回值：
        1. true拦截
        2. false 不拦截，继续流程
    3. 事件处理的返回值：
        1. true 处理
        2. false 给上级处理
    4. 这三个默认返回的都是false
事件是从根元素依次往下传递，如果过程中有控件消费（onTouchEvent），事件不再往下传递，如果过程中没有被消费，事件再依次回传，最终回传到Activity中
添加
View的OnTouchListener优先级比OnTouchEvent要高。所以如果OnTouchListener返回true，这个View的OnTouchEvent就不会被调用
一个事件序列只能被一个View拦截并消耗
一旦某个VIew拦截了这个事件，这个事件序列以后都会交给它去处理，不会调用这个View的onInterceptTouchEvent方法(ViewGroup)
一旦某个事件交给一个View去处理，如果这个View的onTouchEvent返回了false,那么这个事件序列都不会交给这个View去处理（move,up）
eg:activity-viewgroup-view
当down事件传递到从Activity传递到view的onTouchEvent（返回false），那么MOVE，up事件，不会再传递给view。
getParent().requestDisallowInterceptTouchEvent(true);请求不要让父View去拦截这个事件
如果父View拦截了down事件，那么这个方法不起作用
事件是一组一组的，以DOWN开始，0到n个MOVE，以UP结尾，称为一个事件序列
其实事件分发是一个很复杂的事情，这里只不过把流程简单化了，便于理解。其实每层View的dispatchTouchEvent生命周期都特别长，当其下面的所有子VIew的onTouchEvent执行完成后，然后返回到了这个VIew的onTouchEvent，并且执行完成，这时这个View的dispatchTouchEvent方法的声明周期才会结束。

