https://juejin.im/post/6876968255597051917#heading-15

#锁和并发 TODO
##ReentranLock跟synchronized有什么区别？synchronized与ReentranLock发生异常的场景？
##synchronized是公平锁还是非公平锁,ReentranLock是公平锁吗？是怎么实现的
##synchronized底层原理是什么
##volatile字段有什么用途？


#说说HashMap的原理 TODO

#泛型有什么优点？
1. 保证类型安全性
	1. list<integer> arraylist 一个只能存放int,一个啥都可以存，编译的时候不会报错
2. 避免了强制转换，提高了性能
3. 代码观看清晰条理

#垃圾回收机制与jvm结构，老年代算法，方法区有啥，GCRoot都有啥 TODO
    https://juejin.im/post/6844903905457864718
    这篇文章写得挺好挺全的

>jvm内存结构

![Jvm内存结构.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/Jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png?raw=true)

* 其中线程私有数据区域的生命周期和线程相同，每个线程与操作系统的本地线程直接映射，这部分的内存区域跟着本地线程创建销毁。
* 线程共享区域随虚拟机的启动而创建，关闭而销毁。
* 除pc之外，别的区域都有可能造成OOM

1. 方法区(包含常量池)
	1. 用于存储被jvm加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。**使用java堆的永久代实现方法区，GC收集的永久代区域。**永久代的内存回收主要目标是针对常量池的回收和类型的卸载。运行时常量池是方法区的一部分，class文件除了有类的版本，字段，方法，接口等描述信息外，还有一项是常量池，主要存放编译期间生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。

2. 堆
	1. 创建的对象与数组都保存在java堆内存中，因为是线程共享，所以与方法区两个是垃圾收集的区域，java堆中从GC的角度细分为：新生区与老年区。
3. 程序计数器 :指向当前线程所执行的字节码的行号
4. 虚拟机栈：
	1. 主要描述方法执行，每个方法在执行的时候创建一个栈帧，其中栈帧中存储了局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行结束，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
5. 本地方法区：
	1. 虚拟机栈执行java方法；本地方法栈执行native方法。比如java中调用C或C++中的方法，在这里执行。有的虚拟机会将虚拟机栈与本地方法栈合二为一。
>垃圾回收算法

* 新生代：复制算法
* 老年代
>可以作为GC root对象包括：

* 虚拟机栈（栈帧中的本地变量表）中的引用对象。
* 方法区中的静态属性或常量（final）引用的对象。
* 本地方法栈中JNI(即一般说的Native方法)引用的对象。

#编译期注解处理的是字节码还是java文件 TODO待修改
应该是处理的Java文件，然后生成字节码

APT即为Annotation Processing Tool，它是javac的一个工具，中文意思为编译时注解处理器。APT可以用来在编译时扫描和处理注解。通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来自动的生成一些代码，省去了手动编写。注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。APT的核心是AbstractProcessor类。

ButterKnife，eventbus都使用了APT技术

#代理模式与装饰模式的区别，手写一个静态代理，一个动态代理,动态代理有什么用
>代理模式:

Java动态代理的优势是实现无侵入式的代码扩展，也就是方法的增强；让你可以在不用修改源码的情况下，增强一些方法；在方法的前后你可以做你任何想做的事情


1. 静态代理

想要生成代理类，需要让代理类和被代理类实现同一个接口，并且在代理类中添加被代理类的引用，代理类方法实现中添加代理逻辑，并决定是否调用被代理类方法，这种通过硬编码的方式指定代理类与被代理类的方式，叫静态代理。可以明显看出，**静态代理类与被代理类是耦合的，如果要代理100个类，你就得写100个代理类**

代码：

    public class RealTest{
    	public void doSomthing(){
    		system.out.print("原生方法");
    	}
    }
    
    public interface Test{
    	public void doSomthing();
    }
    
    public class TestProxy implements Test {
      Test t = new RealTest();
      public void doSomething() {
         t.doSomething();
      }
    }
刚开始我会觉得TestProxy定义出来纯属多余，直接实例化实现类完成操作不就结了吗？后来随着业务庞大，你就会知道，实现proxy类对真实类的封装对于粒度的控制有着重要的意义。但是静态代理这个模式本身有个大问题，如果类方法数量越来越多的时候，代理类的代码量是十分庞大的。所以引入动态代理来解决此类问题

3.动态代理

其实动态代理与静态代理的本质一样，最终程序运行时都需要生成一个代理对象实例，通过它来完成相关增强以及业务逻辑，只不过静态代理需要硬编码的方式指定，而动态代理则是以动态方式生成代理(编译时操作字节码以及运行时通过反射方式)。动态生成的好处很明显，代理逻辑与业务逻辑是互相独立的，没有耦合，代理1个类100个类没有任何区别

代码：

	public interface Subject   
	{   
	  public void doSomething();   
	}
	
	public class RealSubject implements Subject   
	{   
	  public void doSomething()   
	  {   
	    System.out.println( "call doSomething()" );   
	  }   
	}  
	
	public class ProxyHandler implements InvocationHandler
	{
	    private Object tar;
	
	    //绑定委托对象，并返回代理类
	    public Object bind(Object tar)
	    {
	        this.tar = tar;
	        //绑定该类实现的所有接口，取得代理类 
	        return Proxy.newProxyInstance(tar.getClass().getClassLoader(),
	                                      tar.getClass().getInterfaces(),
	                                      this);
	    }    
		@Override
	    public Object invoke(Object proxy , Method method , Object[] args)throws Throwable
	    {
	        Object result = null;
	        //这里就可以进行所谓的AOP编程了
	        //在调用具体函数方法前，执行功能处理
	        result = method.invoke(tar,args);
	        //在调用具体函数方法后，执行功能处理
	        return result;
	    }
	}
	public class TestProxy
	{
	    public static void main(String args[])
	    {
	           ProxyHandler proxy = new ProxyHandler();
	           //绑定该类实现的所有接口
	           Subject sub = (Subject) proxy.bind(new RealSubject());
	           sub.doSomething();
	    }
	}

Proxy类的代码量被固定下来，不会因为业务的逐渐庞大而庞大；可以实现AOP编程，实际上静态代理也可以实现，总的来说，AOP可以算作是代理模式的一个典型应用；解耦，通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。

>代理模式与装饰模式的区别

**装饰器模式应当为所装饰的对象提供增强功能，而代理模式对所代理对象的使用施加控制，并不提供对象本身的增强功能**。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

##AOP TODO待补充
传统面向对象思想中，如果想要实现功能复用，要么继承、要么引用，无论哪种方式，对代码都有一定的侵入性，耦合无可避免，侵入性啥意思？简单来说：如果你想要用它增强你程序的功能，你必须改动你的程序代码，那它就具有侵入性。如果只有一点两点需要增强还好说，如果大量的功能点需要被增强，工作量就会很大，代码也不太优雅。想象一下，如果你对外公开了一系列的接口，现在领导说了，接口要加权限控制。在哪加？最笨的当然就是写个程序验证的逻辑，然后每个接口都拿来调用一遍。这也正是面向对象思想的短板，在要为程序新增一些通用功能时，只能通过耦合的方式才能进行。AOP正是为此而生，AOP旨在通过一种无耦合的方式来为程序带来增强。而动态代理，就是AOP实现方式中的一种
---

---

#attachToWindow什么时候调用？

attachToWindow在onResume之后调用，onDetachFromWindow() 在页面退出的时候都会被调用

```
MainActivity打开
MainActivity: onCreate
MainActivity: onStart
MainActivity: onResume
MainActivity: onAttachedToWindow
MainActivity: onViewAttachedToWindow(界面View设置的监听)
点击home键
MainActivity: onPause
MainActivity: onStop
恢复展示
MainActivity: onRestart
MainActivity: onStart
MainActivity: onResume
关闭
MainActivity: onPause
MainActivity: onStop
MainActivity: onDestroy
MainActivity: onViewDetachedFromWindow
MainActivity: onDetachedFromWindow


MainActivity打开
MainActivity: onCreate
MainActivity: onStart
MainActivity: onResume
MainActivity: onAttachedToWindow
MainActivity: onViewAttachedToWindow
SecondActivity打开
MainActivity: onPause
SecondActivity: onCreate
SecondActivity: onStart
SecondActivity: onResume
SecondActivity: onAttachedToWindow
MainActivity: onStop
SecondActivity关闭
SecondActivity: onPause
MainActivity: onRestart
MainActivity: onStart
MainActivity: onResume
SecondActivity: onStop
SecondActivity: onDestroy
SecondActivity: onDetachedFromWindow
```



#setOnTouchListener,onClickeListener和onTouchEvent的关系

setOnTouchListener-onTouch
onClickeListener-onClick

onTouch在dispatchTouchEvent()方法中调用

    public boolean dispatchTouchEvent(MotionEvent event) {      
    	if (onFilterTouchEventForSecurity(event)) {        
    		if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
                		result = true;        
    		}        
    		if (!result && onTouchEvent(event)) {
    	            result = true;        
    		}   
    	}     
    	return result;
    }

当设置了setOnTouchListener(),li和mOnTouchListener会被初始化，不为null，前两个条件成立，所以当onTouch()方法返回值为true，就不会执行onTouchEvent(event)方法，返回false会执行。

接下来看onTouchEvent的源码

	public boolean onTouchEvent(MotionEvent event) {
	     if (((viewFlags & CLICKABLE)  ==  CLICKABLE  ||(viewFlags & LONG_CLICKABLE)  ==  LONG_CLICKABLE) 
	        || (viewFlags & CONTEXT_CLICKABLE)  ==  CONTEXT_CLICKABLE) {
	           switch (action) {
	               case MotionEvent.ACTION_UP:                           
	                //如果执行了该方法，其返回值就是onTouchEvent()的返回值                
	                performClick();                             
	                break;        
	            }        
	        return true;    
	    }    
	    return false;
	}
在performClick方法中调用了mOnClickListener.onClick(this)方法。只要我们在代码中通过 setOnClickListener() 方法设置了对单击事件的监听，则对应 View 的 onTouchEvent() 方法返回 true，当然事件就此消费，反之返回 false
>总结：

onTouch() 方法的返回值决定了 onTouchEvent() 方法要不要执行，如果 onTouch() 返回 true，则 onTouchEvent() 不会再执行，返回 false ,则 onTouchEvent() 继续执行，而 onClick() 的回调是在 onTouchEvent() 方法中调用，onTouchEvent() 不执行则 onClick() 不执行。

#说说事件分发机制，怎么写一个不能滑动的ViewPager TODO

View事件分发是对MotionEvent事件分发，最终传递给一个View的过程

dispatchTouchEvent：方法返回值为true表示事件被当前视图消费掉；返回为super.dispatchTouchEvent表示继续分发该事件，返回为false表示交给父类的onTouchEvent处理。

onInterceptTouchEvent：方法返回值为true表示拦截这个事件并交由自身的onTouchEvent方法进行消费；返回false表示不拦截，需要继续传递给子视图。如果return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: 　

- 1.如果该View存在子View且点击到了该子View, 则不拦截, 继续分发 给子View 处理, 此时相当于return false。
- 2.如果该View没有子View或者有子View但是没有点击中子View(此时ViewGroup 相当于普通View), 则交由该View的onTouchEvent响应，此时相当于return true。

注意：一般的LinearLayout、 RelativeLayout、FrameLayout等ViewGroup默认不拦截， 而 ScrollView、ListView等ViewGroup则可能拦截，得看具体情况。

onTouchEvent：方法返回值为true表示当前视图可以处理对应的事件；返回值为false表示当前视图不处理这个事件，它会被传递给父视图的onTouchEvent方法进行处理。如果return super.onTouchEvent(ev)，事件处理分为两种情况：

- 1.如果该View是clickable或者longclickable的,则会返回true, 表示消费 了该事件, 与返回true一样;
- 2.如果该View不是clickable或者longclickable的,则会返回false, 表示不 消费该事件,将会向上传递,与返回false一样。

注意：在Android系统中，拥有事件传递处理能力的类有以下三种：

- Activity：拥有分发和消费两个方法。
- ViewGroup：拥有分发、拦截和消费三个方法。
- View：拥有分发、消费两个方法。

对应一个根ViewGroup来说，点击事件产生后，首先会传递给它，这是它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，这时如果它的mOnTouchListener被设置，则onTouch会被调用，否则onTouchEvent会被调用。在onTouchEvent中，如果设置了mOnCLickListener，则onClick会被调用。只要View的CLICKABLE和LONG_CLICKABLE有一个为true，onTouchEvent()就会返回true消耗这个事件。如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。



一些重要的结论：

1、事件传递优先级：onTouchListener.onTouch > onTouchEvent > onClickListener.onClick。

2、正常情况下，一个事件序列只能被一个View拦截且消耗。因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不会再调用这个View的拦截方法去询问它是否要拦截了，而是把剩余的ACTION_MOVE、ACTION_DOWN等事件直接交给它来处理）。

4、ViewGroup默认不拦截任何事件（返回false）。

5、View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable默认为false。

6、View的enable属性不影响onTouchEvent的默认返回值。

7、通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。

> 手势操作ActionCancel后怎么取消  TODO

- 一般ACTION_CANCEL和ACTION_UP都作为View一段事件处理的结束。如果在父View中拦截ACTION_UP或ACTION_MOVE，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到ACTION_CANCEL事件。
- 如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现action_cancel。

> 点击事件被拦截，但是想传到下面的View，如何操作？

重写子类的requestDisallowInterceptTouchEvent()方法返回true就不会执行父类的onInterceptTouchEvent()，即可将点击事件传到下面的View。

> 如何解决View的事件冲突？举个开发中遇到的例子？

常见开发中事件冲突的有ScrollView与RecyclerView的滑动冲突、RecyclerView内嵌同时滑动同一方向。

滑动冲突的处理规则：

- 对于由于外部滑动和内部滑动方向不一致导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件。
- 对于由于外部滑动方向和内部滑动方向一致导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件，何时由内部View拦截事件。
- 对于上面两种情况的嵌套，相对复杂，可同样根据需求在业务上找到突破点。

滑动冲突的实现方法：

- 外部拦截法：指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。具体方法：需要重写父容器的onInterceptTouchEvent方法，在内部做出相应的拦截。
- 内部拦截法：指父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法：需要配合requestDisallowInterceptTouchEvent方法。

> ViewPager

onInterceptTouchEvent()方法和onTouchEvent()方法，这两个方法的返回值都是boolean类型的，只需要将返回值改为false，那么ViewPager就不会消耗掉手指滑动的事件了

#View绘制流程
View的工作流程主要是指measure、layout、draw这三大流程，其中measure确定View的测量宽/高，layout确定View的最终位置，而draw则将View绘制到屏幕上
##自定义圆角图片
>BitmapShader实现

	public class RoundImageViewByBitmapShader extends ImageView {
	
	  private Shader mShader;
	  private Paint mPaint;
	
	  public RoundImageViewByBitmapShader(Context context) {
	    super(context);
	  }
	
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs) {
	    super(context, attrs);
	  }
	
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
	    super(context, attrs, defStyleAttr);
	  }
	
	  @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
	    super(context, attrs, defStyleAttr, defStyleRes);
	  }
	
	  @Override
	  protected void onDraw(Canvas canvas) {
	    BitmapDrawable drawable = (BitmapDrawable) getDrawable();
	    if (mShader == null) {
	      mShader = new BitmapShader(drawable.getBitmap(), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
	      mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
	    }
	    mPaint.setShader(mShader);
	    canvas.drawRoundRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), 100, 100, mPaint);
	  }
	}

>Xfermode

	public class RoundedImageViewByXfermode extends ImageView {
	
	  private Paint mPaint;
	  private Xfermode mXfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);
	  private RectF mRectF;
	  private Bitmap mBitmap;
	
	  public RoundedImageViewByXfermode(Context context) {
	    this(context, null);
	  }
	
	  public RoundedImageViewByXfermode(Context context, @Nullable AttributeSet attrs) {
	    this(context, attrs, 0);
	  }
	
	  public RoundedImageViewByXfermode(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
	    super(context, attrs, defStyleAttr);
	    init();
	  }
	
	  @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
	  public RoundedImageViewByXfermode(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
	    super(context, attrs, defStyleAttr, defStyleRes);
	  }
	
	  private void init() {
	    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
	  }
	
	  @Override
	  protected void onDraw(Canvas canvas) {
	    canvas.saveLayer(0, 0, getMeasuredWidth(), getMeasuredHeight(), null, Canvas.ALL_SAVE_FLAG);
	    Drawable drawable = getDrawable();
	    if (mBitmap == null) {
	      mBitmap = Bitmap.createBitmap(getMeasuredWidth(), getMeasuredHeight(), Bitmap.Config.ARGB_8888);
	      Canvas drawCanvas = new Canvas(mBitmap);
	      drawable.draw(drawCanvas);
	    }
	    if (mRectF == null) {
	      mRectF = new RectF(0, 0, getMeasuredWidth(), getMeasuredHeight());
	    }
	    mPaint.setXfermode(null);
	    canvas.drawRoundRect(mRectF, 100, 100, mPaint);
	    mPaint.setXfermode(mXfermode);
	    canvas.drawBitmap(mBitmap, 0, 0, mPaint);
	    canvas.restore();
	  }
	}
先绘制Dst图层和src图层，然后根据规则设置不同的Xfermode，从而达到裁剪图层的效果


#Handler机制
##Handler机制？一个线程有几个Looper？为什么？
一个线程只有1个Looper

##Handler内存泄漏的GCRoot是什么？

##Handler休眠是怎样的？epoll的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？
##Handler是怎么切换线程的,Handler同步屏障
##Binder通信

#协程
##你对协程的理解，协程有什么作用？可以完全取代rxjava吗？协程怎么取消？协程可以在Java项目中使用吗？
##协程的scope与context，协程的+号代表什么

协程：一套基于线程而实现的上层API
优点：异步变同步

Dispatchers 调度器
	main io default(CPU密集型任务)
	
withContext 切换到指定线程，并在闭包任务结束之后，继续执行下面的代码

suspend 挂起函数，可在挂起函数中执行子线程操作，挂起函数执行完成后，也会继续执行下面的代码

#Eventbus源码




#项目有什么难点？

