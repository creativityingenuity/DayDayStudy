https://juejin.im/post/6876968255597051917#heading-15

#锁和并发 
##ReentranLock跟synchronized有什么区别？synchronized与ReentranLock发生异常的场景？

> 相同

都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待

> 不同

1. API层面

   * synchronized是关键字，是原生语法层面的互斥，需JVM实现。ReentranLock是1.5之后API提供的

   * synchronized可以修饰方法和代码块,Reentranlock只能在方法内使用

2. 等待可中断

   * 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，去处理别的事情
   * 假如业务代码中有两个线程，Thread1 Thread2。假设 Thread1 获取了对象object的锁，Thread2将等待Thread1释放object的锁。
     - 使用synchronized。如果Thread1不释放，Thread2将一直阻塞等待，不能被中断。
     - 使用ReentrantLock。如果Thread1不释放，Thread2等待了很长时间以后，可以中断等待，转而去做别的事情。

3. 公平锁

   * 公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序获取锁，而非公平锁则是任何一个等待的线程都可以获取锁
   * synchronized是非公平锁，ReentranLock默认是非公平锁，但可以通过构造函数设置True使用公平锁

```
private ReentrantLock lock = new ReentrantLock();
public void run() {
    lock.lock();
    try{
        for(int i=0;i<5;i++){
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }finally{
        lock.unlock();
    }
}
```

> synchronized与ReentranLock发生异常的场景

发生异常的场景我查了半天没查到，应该就是线程抛出异常吧

在发生异常时，synchronized会自动释放锁，ReentranLock则需要与try{}finally{}搭配手动释放锁

##synchronized是公平锁还是非公平锁,ReentranLock是公平锁吗？是怎么实现的

synchronized是非公平锁，ReentranLock默认是非公平锁，但可以通过构造函数设置True使用公平锁

>ReentranLock是怎么实现的

##synchronized底层原理是什么

Synchronized经过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。




##volatile字段有什么用途？

#HashMap的原理 



#泛型有什么优点？
1. 保证类型安全性
	1. list<integer> arraylist 一个只能存放int,一个啥都可以存，编译的时候不会报错
2. 避免了强制转换，提高了性能
3. 代码观看清晰条理

#垃圾回收机制与jvm结构，老年代算法，方法区有啥，GCRoot都有啥 TODO
    https://juejin.im/post/6844903905457864718
    这篇文章写得挺好挺全的

>jvm内存结构

![Jvm内存结构.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/Jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png?raw=true)

* 其中线程私有数据区域的生命周期和线程相同，每个线程与操作系统的本地线程直接映射，这部分的内存区域跟着本地线程创建销毁。
* 线程共享区域随虚拟机的启动而创建，关闭而销毁。
* 除pc之外，别的区域都有可能造成OOM

1. 方法区(包含常量池)
	1. 用于存储被jvm加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。**使用java堆的永久代实现方法区，GC收集的永久代区域。**永久代的内存回收主要目标是针对常量池的回收和类型的卸载。运行时常量池是方法区的一部分，class文件除了有类的版本，字段，方法，接口等描述信息外，还有一项是常量池，主要存放编译期间生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。

2. 堆
	1. 创建的对象与数组都保存在java堆内存中，因为是线程共享，所以与方法区两个是垃圾收集的区域，java堆中从GC的角度细分为：新生区与老年区。
3. 程序计数器 :指向当前线程所执行的字节码的行号
4. 虚拟机栈：
	1. 主要描述方法执行，每个方法在执行的时候创建一个栈帧，其中栈帧中存储了局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行结束，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
5. 本地方法区：
	1. 虚拟机栈执行java方法；本地方法栈执行native方法。比如java中调用C或C++中的方法，在这里执行。有的虚拟机会将虚拟机栈与本地方法栈合二为一。
>垃圾回收算法

* 新生代：复制算法
* 老年代
>可以作为GC root对象包括：

* 虚拟机栈（栈帧中的本地变量表）中的引用对象。
* 方法区中的静态属性或常量（final）引用的对象。
* 本地方法栈中JNI(即一般说的Native方法)引用的对象。

#编译期注解处理的是字节码还是java文件
应该是处理的Java文件，然后生成字节码

APT即为Annotation Processing Tool，它是javac的一个工具，中文意思为编译时注解处理器。APT可以用来在编译时扫描和处理注解。通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来自动的生成一些代码，省去了手动编写。注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。APT的核心是AbstractProcessor类。

ButterKnife，eventbus都使用了APT技术

#设计模式

##你在项目中有用到什么设计模式吗

##代理模式与装饰模式的区别，手写一个静态代理，一个动态代理,动态代理有什么用

>代理模式:

Java动态代理的优势是实现无侵入式的代码扩展，也就是方法的增强；让你可以在不用修改源码的情况下，增强一些方法；在方法的前后你可以做你任何想做的事情


1. 静态代理

想要生成代理类，需要让代理类和被代理类实现同一个接口，并且在代理类中添加被代理类的引用，代理类方法实现中添加代理逻辑，并决定是否调用被代理类方法，这种通过硬编码的方式指定代理类与被代理类的方式，叫静态代理。可以明显看出，**静态代理类与被代理类是耦合的，如果要代理100个类，你就得写100个代理类**

代码：

    public class RealTest{
    	public void doSomthing(){
    		system.out.print("原生方法");
    	}
    }
    
    public interface Test{
    	public void doSomthing();
    }
    
    public class TestProxy implements Test {
      Test t = new RealTest();
      public void doSomething() {
         t.doSomething();
      }
    }
刚开始我会觉得TestProxy定义出来纯属多余，直接实例化实现类完成操作不就结了吗？后来随着业务庞大，你就会知道，实现proxy类对真实类的封装对于粒度的控制有着重要的意义。但是静态代理这个模式本身有个大问题，如果类方法数量越来越多的时候，代理类的代码量是十分庞大的。所以引入动态代理来解决此类问题

3.动态代理

其实动态代理与静态代理的本质一样，最终程序运行时都需要生成一个代理对象实例，通过它来完成相关增强以及业务逻辑，只不过静态代理需要硬编码的方式指定，而动态代理则是以动态方式生成代理(编译时操作字节码以及运行时通过反射方式)。动态生成的好处很明显，代理逻辑与业务逻辑是互相独立的，没有耦合，代理1个类100个类没有任何区别

代码：

	public interface Subject   
	{   
	  public void doSomething();   
	}
	
	public class RealSubject implements Subject   
	{   
	  public void doSomething()   
	  {   
	    System.out.println( "call doSomething()" );   
	  }   
	}  
	
	public class ProxyHandler implements InvocationHandler
	{
	    private Object tar;
	
	    //绑定委托对象，并返回代理类
	    public Object bind(Object tar)
	    {
	        this.tar = tar;
	        //绑定该类实现的所有接口，取得代理类 
	        return Proxy.newProxyInstance(tar.getClass().getClassLoader(),
	                                      tar.getClass().getInterfaces(),
	                                      this);
	    }    
		@Override
	    public Object invoke(Object proxy , Method method , Object[] args)throws Throwable
	    {
	        Object result = null;
	        //这里就可以进行所谓的AOP编程了
	        //在调用具体函数方法前，执行功能处理
	        result = method.invoke(tar,args);
	        //在调用具体函数方法后，执行功能处理
	        return result;
	    }
	}
	public class TestProxy
	{
	    public static void main(String args[])
	    {
	           ProxyHandler proxy = new ProxyHandler();
	           //绑定该类实现的所有接口
	           Subject sub = (Subject) proxy.bind(new RealSubject());
	           sub.doSomething();
	    }
	}

Proxy类的代码量被固定下来，不会因为业务的逐渐庞大而庞大；可以实现AOP编程，实际上静态代理也可以实现，总的来说，AOP可以算作是代理模式的一个典型应用；解耦，通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。

>代理模式与装饰模式的区别

**装饰器模式应当为所装饰的对象提供增强功能，而代理模式对所代理对象的使用施加控制，并不提供对象本身的增强功能**。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

##AOP TODO待补充
传统面向对象思想中，如果想要实现功能复用，要么继承、要么引用，无论哪种方式，对代码都有一定的侵入性，耦合无可避免，侵入性啥意思？简单来说：如果你想要用它增强你程序的功能，你必须改动你的程序代码，那它就具有侵入性。如果只有一点两点需要增强还好说，如果大量的功能点需要被增强，工作量就会很大，代码也不太优雅。想象一下，如果你对外公开了一系列的接口，现在领导说了，接口要加权限控制。在哪加？最笨的当然就是写个程序验证的逻辑，然后每个接口都拿来调用一遍。这也正是面向对象思想的短板，在要为程序新增一些通用功能时，只能通过耦合的方式才能进行。AOP正是为此而生，AOP旨在通过一种无耦合的方式来为程序带来增强。而动态代理，就是AOP实现方式中的一种

---

#activity启动模式

启动模式（launchMode）在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例共用一个task。

> Activity一共有以下四种launchMode：

1. standard 标准启动模式
   * 默认的启动模式，每次启动activity都会创建新的实例。
2. singletop 栈顶复用模式  适合接收通知启动的内容显示页面
   * 当栈顶有将要开启的Activity时，会复用这个Activity，同时这个activity的onNewIntent方法会被回调。这个activity的onCreate方法不会被调用，因为它没有发生改变。若是栈顶没有，那么就会重新创建
   * 应用场景：适用于接收到消息后显示的界面。例如：QQ接收到消息后会弹出activity，但如果一次来10条消息，总不能一次弹出10个activity。  

3. singetask栈内复用模式，在当前任务栈里面只能有一个实例存在 适合作为程序入口点

   * 当一个启动模式为singleTask的activityA请求启动后，系统会先寻找是否存在A想要的任务栈（在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在），如果不存在，就重新创建一个任务栈，然后创建A的实例并将A放到栈中。如果存在A所需的任务栈，这时要看栈中有是否有要开启的activityA，如果有则直接复用并删除A上面的activity，将A移动到栈顶，同singletop一样，也会回调这个activity的onNewIntent方法。如果没有实例，则创建A实例并压入栈中

   * 现在有两个任务栈，前台任务栈中有BA，后台任务栈中有DC，假设DC启动启动模式都为singleTask。现在请求启动D，那么整个后台任务栈都会被切到前台，这时候前台任务栈为DCBA，当按back键时，前台栈中activity会一一出栈；如果请求启动C，那么情况就不一样了，会把D删除,C切换到前台。（具体看图——singleTask启动模式特例.pptx）
   * 所以这种启动模式通常可以用来退出整个应用程序。将主activity设为singleTask,然后在要退出的activity中转到主Activity，从而将主Activity上的其他activity全部清除，然后在主Activity中的onNewIntent()中加上finish(),将最后一个activity结束。

4. singleInstance 单实例模式，可以看作加强版singleTask模式

   * activity会开启一个新的任务栈，并且这个任务栈里面只有一个实例存在。

   * 这种启动模式和浏览器的工作原理类似。当多个程序访问浏览器时，如果浏览器没有打开，则打开浏览器，否则会在当前打开的浏览器中访问。举个例子来说，当应用A的任务栈创建了ActivityA实例，并且其启动模式为sinleInstance，如果应用B也要激活ActivityA，则不需要创建，两个应用共享即可。    
   * 如果你要保证一个activity在整个手机操作系统里面只有一个实例存在，使用singleInstance
   * 关于singleInstance这种启动模式还有一点需要特殊说明:如果在一个singleInstance的activityA中通过startActivityForResult()去启动另一个activityB，那么在A中拿不到数据。因为android不允许task间互相传递数据。

> onNewIntent()

通过这个方法可以取出当前请求的信息
第一次创建Activity A时，执行的逻辑顺序是：
    onCreate() ­­­>onStart()­­­>onResume()
而如果使用singleTask模式第二次启动Activity A，且A处于任务栈的顶端，则执行的逻辑顺序是：
    onNewIntent() ­­­>onRestart> onStart>onResume()。 
注意，getIntent()仍返回原来的意图。你可以使用setIntent来设置新的意图。

# intentService

intentService可以异步运行一个任务并在结束时自行终止。需要在一个单独的线程中执行的代码可以放在onHandleIntent()中，如从服务器下载数据，当代码执行完毕，线程被终止，服务自行停止。

是通过HandlerThread来实现耗时操作的

> HandlerThread

`HandlerThread`继承Thread，内置了Handler和Looper，在run方法中创建了looper对象，这也是为什么在IntentService中能在HandlerThread中直接用handler的原因。

# 广播与RxBus的区别，全局广播与局部广播区别

本地广播：广播事件的发送和接收都在本应用，不能跨进程(APP内部进程也不能跨)，只能动态注册，不能静态注册--使用Handler通信机制

全局广播：广播事件的发送和接收都在本应用可以跨应用，全局广播既可以动态注册，也可以静态注册--采用的binder方式实现跨进程间的通信

广播是四大组件之一，可以直接获取上下文，比较消耗资源，Rxbus不能跨进程，耦合性低，比广播更轻量，书写简便。可实现粘性事件

#attachToWindow什么时候调用？

attachToWindow在onResume之后调用，onDetachFromWindow() 在页面退出的时候都会被调用

```
MainActivity打开
MainActivity: onCreate
MainActivity: onStart
MainActivity: onResume
MainActivity: onAttachedToWindow
MainActivity: onViewAttachedToWindow(界面View设置的监听)
点击home键
MainActivity: onPause
MainActivity: onStop
恢复展示
MainActivity: onRestart
MainActivity: onStart
MainActivity: onResume
关闭
MainActivity: onPause
MainActivity: onStop
MainActivity: onDestroy
MainActivity: onViewDetachedFromWindow
MainActivity: onDetachedFromWindow


MainActivity打开
MainActivity: onCreate
MainActivity: onStart
MainActivity: onResume
MainActivity: onAttachedToWindow
MainActivity: onViewAttachedToWindow
SecondActivity打开
MainActivity: onPause
SecondActivity: onCreate
SecondActivity: onStart
SecondActivity: onResume
SecondActivity: onAttachedToWindow
MainActivity: onStop
SecondActivity关闭
SecondActivity: onPause
MainActivity: onRestart
MainActivity: onStart
MainActivity: onResume
SecondActivity: onStop
SecondActivity: onDestroy
SecondActivity: onDetachedFromWindow
```



#setOnTouchListener,onClickeListener和onTouchEvent的关系

setOnTouchListener-onTouch
onClickeListener-onClick

onTouch在dispatchTouchEvent()方法中调用

    public boolean dispatchTouchEvent(MotionEvent event) {      
    	if (onFilterTouchEventForSecurity(event)) {        
    		if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
                		result = true;        
    		}        
    		if (!result && onTouchEvent(event)) {
    	            result = true;        
    		}   
    	}     
    	return result;
    }

当设置了setOnTouchListener(),li和mOnTouchListener会被初始化，不为null，前两个条件成立，所以当onTouch()方法返回值为true，就不会执行onTouchEvent(event)方法，返回false会执行。

接下来看onTouchEvent的源码

	public boolean onTouchEvent(MotionEvent event) {
	     if (((viewFlags & CLICKABLE)  ==  CLICKABLE  ||(viewFlags & LONG_CLICKABLE)  ==  LONG_CLICKABLE) 
	        || (viewFlags & CONTEXT_CLICKABLE)  ==  CONTEXT_CLICKABLE) {
	           switch (action) {
	               case MotionEvent.ACTION_UP:                           
	                //如果执行了该方法，其返回值就是onTouchEvent()的返回值                
	                performClick();                             
	                break;        
	            }        
	        return true;    
	    }    
	    return false;
	}
在performClick方法中调用了mOnClickListener.onClick(this)方法。只要我们在代码中通过 setOnClickListener() 方法设置了对单击事件的监听，则对应 View 的 onTouchEvent() 方法返回 true，当然事件就此消费，反之返回 false
>总结：

onTouch() 方法的返回值决定了 onTouchEvent() 方法要不要执行，如果 onTouch() 返回 true，则 onTouchEvent() 不会再执行，返回 false ,则 onTouchEvent() 继续执行，而 onClick() 的回调是在 onTouchEvent() 方法中调用，onTouchEvent() 不执行则 onClick() 不执行。

#事件分发机制

![事件分发机制.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6.png?raw=true)

view的分发事件是从view的`Viewgroup(Parent)#dispatchTouchEvent`到`Viewgroup(Parent)#onInterceptTouchEvent`再到`View#dispatchTouchEvent`，然后到view的`onTouchEvent`，最后又回到了`Viewgroup(Parent)#onTouchEvent`

如果viewgroup不进行分发，那么`action_down`、`action_move`和`action_up`只会执行到viewgroup的`dispatchTouchEvent`，不分发的条件是`dispatchTouchEvent`直接返回true或false，true和false的区别是true会执行`action_down`、`action_move`和`action_up`，而如果直接返回false只会执行到action_down。并且后续的viewgroup的`onInterceptTouchEvent`后续方法都不会被执行到。

View事件分发是对MotionEvent事件分发，最终传递给一个View的过程

dispatchTouchEvent：方法返回值为true表示事件被当前视图消费掉；返回为super.dispatchTouchEvent表示继续分发该事件，返回为false表示交给父类的onTouchEvent处理。

onInterceptTouchEvent：方法返回值为true表示拦截这个事件并交由自身的onTouchEvent方法进行消费；返回false表示不拦截，需要继续传递给子视图。如果return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: 　

- 1.如果该View存在子View且点击到了该子View, 则不拦截, 继续分发 给子View 处理, 此时相当于return false。
- 2.如果该View没有子View或者有子View但是没有点击中子View(此时ViewGroup 相当于普通View), 则交由该View的onTouchEvent响应，此时相当于return true。

注意：一般的LinearLayout、 RelativeLayout、FrameLayout等ViewGroup默认不拦截， 而 ScrollView、ListView等ViewGroup则可能拦截，得看具体情况。

onTouchEvent：方法返回值为true表示当前视图可以处理对应的事件；返回值为false表示当前视图不处理这个事件，它会被传递给父视图的onTouchEvent方法进行处理。如果return super.onTouchEvent(ev)，事件处理分为两种情况：

- 1.如果该View是clickable或者longclickable的,则会返回true, 表示消费 了该事件, 与返回true一样;
- 2.如果该View不是clickable或者longclickable的,则会返回false, 表示不 消费该事件,将会向上传递,与返回false一样。

注意：在Android系统中，拥有事件传递处理能力的类有以下三种：

- Activity：拥有分发和消费两个方法。
- ViewGroup：拥有分发、拦截和消费三个方法。
- View：拥有分发、消费两个方法。

对应一个根ViewGroup来说，点击事件产生后，首先会传递给它，这是它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，这时如果它的mOnTouchListener被设置，则onTouch会被调用，否则onTouchEvent会被调用。在onTouchEvent中，如果设置了mOnCLickListener，则onClick会被调用。只要View的CLICKABLE和LONG_CLICKABLE有一个为true，onTouchEvent()就会返回true消耗这个事件。如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。



一些重要的结论：

1、事件传递优先级：onTouchListener.onTouch > onTouchEvent > onClickListener.onClick。

2、正常情况下，一个事件序列只能被一个View拦截且消耗。因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不会再调用这个View的拦截方法去询问它是否要拦截了，而是把剩余的ACTION_MOVE、ACTION_DOWN等事件直接交给它来处理）。

4、ViewGroup默认不拦截任何事件（返回false）。

5、View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable默认为false。

6、View的enable属性不影响onTouchEvent的默认返回值。

7、通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。

> 手势操作ActionCancel后怎么取消  TODO

- 一般ACTION_CANCEL和ACTION_UP都作为View一段事件处理的结束。如果在父View中拦截ACTION_UP或ACTION_MOVE，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到ACTION_CANCEL事件。
- 如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现action_cancel。

> 点击事件被拦截，但是想传到下面的View，如何操作？

重写子类的requestDisallowInterceptTouchEvent()方法返回true就不会执行父类的onInterceptTouchEvent()，即可将点击事件传到下面的View。

> 如何解决View的事件冲突？举个开发中遇到的例子？

常见开发中事件冲突的有ScrollView与RecyclerView的滑动冲突、RecyclerView内嵌同时滑动同一方向。

滑动冲突的处理规则：

- 对于由于外部滑动和内部滑动方向不一致导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件。
- 对于由于外部滑动方向和内部滑动方向一致导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件，何时由内部View拦截事件。
- 对于上面两种情况的嵌套，相对复杂，可同样根据需求在业务上找到突破点。

滑动冲突的实现方法：

- 外部拦截法：指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。具体方法：需要重写父容器的onInterceptTouchEvent方法，在内部做出相应的拦截。
- 内部拦截法：指父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法：需要配合requestDisallowInterceptTouchEvent方法。

> 实现一个不能滑动的ViewPager

onInterceptTouchEvent()方法和onTouchEvent()方法，这两个方法的返回值都是boolean类型的，只需要将返回值改为false，那么ViewPager就不会消耗掉手指滑动的事件了

#View绘制流程
View的工作流程主要是指measure、layout、draw这三大流程，其中measure确定View的测量宽/高，layout确定View的最终位置，而draw则将View绘制到屏幕上
##自定义圆角图片
>BitmapShader实现

	public class RoundImageViewByBitmapShader extends ImageView {
	
	  private Shader mShader;
	  private Paint mPaint;
	
	  public RoundImageViewByBitmapShader(Context context) {
	    super(context);
	  }
	
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs) {
	    super(context, attrs);
	  }
	
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
	    super(context, attrs, defStyleAttr);
	  }
	
	  @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
	  public RoundImageViewByBitmapShader(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
	    super(context, attrs, defStyleAttr, defStyleRes);
	  }
	
	  @Override
	  protected void onDraw(Canvas canvas) {
	    BitmapDrawable drawable = (BitmapDrawable) getDrawable();
	    if (mShader == null) {
	      mShader = new BitmapShader(drawable.getBitmap(), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
	      mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
	    }
	    mPaint.setShader(mShader);
	    canvas.drawRoundRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), 100, 100, mPaint);
	  }
	}

>Xfermode

	public class RoundedImageViewByXfermode extends ImageView {
	
	  private Paint mPaint;
	  private Xfermode mXfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);
	  private RectF mRectF;
	  private Bitmap mBitmap;
	
	  public RoundedImageViewByXfermode(Context context) {
	    this(context, null);
	  }
	
	  public RoundedImageViewByXfermode(Context context, @Nullable AttributeSet attrs) {
	    this(context, attrs, 0);
	  }
	
	  public RoundedImageViewByXfermode(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
	    super(context, attrs, defStyleAttr);
	    init();
	  }
	
	  @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
	  public RoundedImageViewByXfermode(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
	    super(context, attrs, defStyleAttr, defStyleRes);
	  }
	
	  private void init() {
	    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
	  }
	
	  @Override
	  protected void onDraw(Canvas canvas) {
	    canvas.saveLayer(0, 0, getMeasuredWidth(), getMeasuredHeight(), null, Canvas.ALL_SAVE_FLAG);
	    Drawable drawable = getDrawable();
	    if (mBitmap == null) {
	      mBitmap = Bitmap.createBitmap(getMeasuredWidth(), getMeasuredHeight(), Bitmap.Config.ARGB_8888);
	      Canvas drawCanvas = new Canvas(mBitmap);
	      drawable.draw(drawCanvas);
	    }
	    if (mRectF == null) {
	      mRectF = new RectF(0, 0, getMeasuredWidth(), getMeasuredHeight());
	    }
	    mPaint.setXfermode(null);
	    canvas.drawRoundRect(mRectF, 100, 100, mPaint);
	    mPaint.setXfermode(mXfermode);
	    canvas.drawBitmap(mBitmap, 0, 0, mPaint);
	    canvas.restore();
	  }
	}
先绘制Dst图层和src图层，然后根据规则设置不同的Xfermode，从而达到裁剪图层的效果


#Handler机制
##简单描述下Handler机制？一个线程有几个Looper？为什么？
Handler机制由MessageQueue，Message，Looper，Handler组成。

Handler通过sendMessage()发送消息Message到消息队列MessageQueue。Looper通过loop()不断提取触发条件的Message，并将Message交给对应的target handler来处理。target handler调用自身的handleMessage()方法来处理Message。



一个线程只有1个Looper，是通过ThreadLocal来保证的

##Handler内存泄漏的GCRoot是什么？

ThreadLocal静态变量作为gcRoot，导致activity无法被回收

handler的内存泄漏原因：

1. 当直接在activity中声明handler时，由于后面的匿名内部类，使handler持有了activity的引用。
2. 当任务未执行完，即message未被执行完时，message持有了messageQueue的引用。
3. messageQueue持有了mLooper的引用。
4. mLooper持有sThreadLocal 的引用。
5. sThreadLocal 是一个静态变量，无法被回收，最终导致了activity无法被回收，造成了内存泄漏。

##Handler休眠是怎样的？epoll的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？

Handler消息机制的休眠和唤醒是通过native层的epoll机制和pipe机制来实现的(也就是线程的休眠和唤醒)



在Linux系统内核中，所有执行I/O操作的系统调用都会通过文件描述符。内核利用文件描述符来访问文件，文件描述符是非负整数。

pipe是Linux中最基本的一种IPC机制，可以用来实现进程、线程间通信。

pipe其本质是一个伪文件，它有两个文件描述符引用，一个表示读端，一个表示写端，规定数据从管道的写端流入管道，从读端流出。

Handler机制中，底层使用pipe创建两个fd：writeFD、readFD。当线程A想唤醒线程B的时候，就可以往writeFD中写数据，这样线程B阻塞在readFD中就能返回。 也就是说，当文件描述符指向的文件（内核缓冲区）为空时，则线程进行休眠。当另一个线程向缓冲区写入内容时，则将当前线程进行唤醒。

epoll机制是linux内核实现IO多路复用的一个实现。IO多路复用的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。



UI线程进入Looper的无限循环之后，为什么没有ANR，是因为底层使用了Linux的epoll机制和pipe实现了线程在空闲时的休眠，并且不会占用系统CPU资源。

##Handler是怎么切换线程的,Handler同步屏障

##Binder通信



#协程

##你对协程的理解，协程有什么作用？可以完全取代rxjava吗？协程怎么取消？协程可以在Java项目中使用吗？

协程：一套基于线程而实现的上层API。优点：异步变同步

suspend 挂起函数，可在挂起函数中执行子线程操作，挂起函数执行完成后，也会继续执行下面的代码

##协程的scope与context，协程的+号代表什么

#说说MVP和MVVM的特点

`MVP`:主要是分离了M层和V层的代码，通过P层来建立他们的关联，实现M层和V层的解耦。缺点就是每增加一个功能，需要增加相应的接口回调。MVP的核心就是通过接口实现隔离，将相关的业务层交给了P层。

如果要细说mvp需要注意几点:

- p层的逻辑处理单一的功能，不要融合一个模块下的增删改查的整个功能。
- 由于p层持有了v层的引用，通常在p层使用弱引用来持有view层实例，在p层销毁的时候需要将v层的引用销毁掉。
- 契约类指的p层和v层的接口类放在一个contract接口类中，契合类方便管理业务层的功能，将单个功能放到一个contract契合类中。

`MVVM`:主要是用到了观察者模式，通过数据的改变来通知相应的View改变的过程。M层和上面的MVP中的M层是一样的，都是网络请求+数据缓存来实现该层的，里面的VM是ViewModel实现的，ViewModel层获取到M层的数据后，通过观察者模式通知UI的改变。

#android中用到的观察者模式有哪些地方

观察者模式是由一个被观察者和一个观察者构成的、被观察者在状态改变时（用户操作、程序主动改变等）主动通知所有观察者作相应的刷新。 android中最经典要说ListView的数据源发生变化了，刷新列表的事例。在setAdapter的时候，生成一个`AdapterDataSetObserver`，紧接着就是订阅上该观察者，该观察者`onChange`方法里面有`requestLayout`方法，该方法是触发UI发生变化的方法。在`BaseAdapter`里面可以看到`notifyDataSetChanged`实际上触发的是`DataSetObservable`被观察者的`notifyChanged`方法，`notifyChanged`会触发`AdapterDataSetObserver`的`onChange`方法。所以最终会走listView的`requestLayout`，最后刷新了UI。

3说说google新出的Lifecycle框架

将类的生命周期方法移交到Lifecycle中管理，实现对类的生命周期的监听，从而在Lifecycle中处理生命周期的逻辑代码。这里涉及到几个对象: `LifecycleObserver接口`（ Lifecycle观察者）：实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。 `LifecycleOwner接口`（Lifecycle持有者）：实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。 `Lifecycle`(生命周期)：和LifecycleOwner不同的是，LifecycleOwner本身持有Lifecycle对象，LifecycleOwner通过其Lifecycle getLifecycle()的接口获取内部Lifecycle对象。 `State`(当前生命周期所处状态)：几种事件状态。 `Event`(当前生命周期改变对应的事件)：当Lifecycle发生改变，事件状态的回调event。

#RxJava 的线程切换原理

- RxJava通过`subscribeOn`指定被观察者发生的线程，`observeOn`指定观察者发生的线程。其中Schedulers.IO生成的是`IoScheduler`。通过观察者与被观察者订阅的过程中，首先会触发被观察者的`subscribeActual`方法，在该方法中，可以看到最终会走`scheduler`的`schedule`方法，所以上面提到的`IoScheduler`实际是调用了它的`schedule`方法，最终会在`NewThreadWorker`里面生成`ScheduledExecutorService`对象，而`ScheduledExecutorService`实际是由`ScheduledThreadPoolExecutor`创建的一个核心线程，最大线程个数是Integer.MAX_VALUE的线程池。最终会由`ScheduledThreadPoolExecutor`的`submit`或`schedule`方法执行传过来的Runnable对象，而Runnable执行的是被观察者的`subscribe`方法。所以解释了被观察者的`subscribe`方法是在子线程中执行的。
- `observeOn`是观察者发生的线程，`AndroidSchedulers.mainThread()`实质是`HandlerScheduler`对象，而在观察者部分，最终观察部分会走Scheduler的`scheduleDirect`方法，而`HandlerScheduler`的该方法里面包装了一个`ScheduledRunnable`对象，通过主线程的handler.postDelayed处理这个runnable对象。

# 网络封装怎么实现？如果让你写一个网络框架，你怎么写



#Eventbus源码

EventBus 发布/订阅事件的总线框架，基于观察者模式，将事件的接收者和发送者分开，基本包括了如下几个步骤:

注册事件的订阅方法:该步骤主要是找到订阅者下面有哪些方法需要被订阅

订阅操作:将需要被订阅的方法放到类似HashMap的数据结构中存储起来，方便后面发送事件和取消注册等资源的释放的时候使用

发送事件:该步骤首先遍历事件队列，然后从队列中取出事件，并且将事件从队列中移除，拿到事件后，判断事件处于的什么线程，如果是非UI线程，则需要Handler去处理，如果是的话，则直接通过反射调用被观察的方法。

反注册:该步骤就没什么好说的，主要是上面存储到HashMap中的被订阅的方法的移除，释放在内存中的资源。

#项目有什么难点？

#系统打包经过了哪几个流程

- 打包资源文件，通过AAPT(Android Asset Packaging Tool)打包成R.java类(资源索引表)以及.arsc资源文件。
- 处理AIDL文件，检查app中是否有aidl文件，如果有会通过aidl工具(源码位于system/tools/aidl）打包成java接口类
- 编译R.java源码部分以及aidl.java通过javac生成对应的.class文件。
- 将上面生成的.class文件和第三方jar或者library通过dx工具打包生成dex文件。
- 生成未签名的apk，包括apkbuilder工具将所有没有编译的资源、.arsc资源、.dex文件打包到一个完成apk文件中
- 生成签名的apk，包括jarsigner工具对未签名的apk验证签名。得到一个签名后的apk（signed.apk）
- zipAlign工具对齐上面签名的apk文件。

