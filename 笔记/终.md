算法：https://zhuanlan.zhihu.com/p/84230862

面试题： https://mp.weixin.qq.com/s/CiO_T95JWA-ijKghrnCQzw?comefrom=https://blogread.cn/news/

技巧：

1.全程冷静严肃不能笑

2.问一个问题，能多回答就多回答，让别人觉得你牛逼

3.还有什么要问的吧：就问团队情况

4.语速放慢

以后要年尾找工作，10月开始准备。12月面试

项目中无需介绍这个项目到底有啥功能，单刀直入这个项目中最值得说的内容。比如遇到的 Bug，自己的思考等等。但是可能很多人会说，业务很简单没什么好说的或者压根没遇到什么问题。遇到这个问题的时候，首先跳脱出业务的框架，去思考其他的问题。相信每个人都写过组件，但是对于如何设计一个好的组件来说就不是每个人都能做的事情了。


写项目经验最好按照这样的思路：遇到了什么问题，如何解决以及结果

# Java ok

## equals和hashcode，他们为何必须一起重写？hashcode方法重写规则

Object中的equals是判断两个对象的地址值，hashcode是内存地址换算出来的一个哈希值。

创建两个地址值不同，字面量相同的字符串对象，如果重写了equals，这时候hashCode返回的是内存地址值。就会变成两个不等的对象。

规则：hashCode方法的重写原则就是保证equals方法认定为相同的两个对象拥有相同的哈希值

hashcode和equals的约定关系如下：

​	如果两个对象相等，那么他们一定有相同的哈希值（hashcode）

​	如果两个对象的哈希值相等，那么这两个对象有可能相等也有可能不相等

在集合中，判断两个对象是否相等先判断hashcode再判断equals

> string,equals,==有什么区别

==比较的是两个对象的内存地址相不相同，相同则返回true。equals默认情况下是调用==，所以也是比较内存地址

string类重写的equals方法，先判断地址是否相等，然后再在长度相同的前提下比对每个字符是否相等。

##自动装箱发生在什么时候？编译期还是运行期

是在编译时自动完成替换的，装箱阶段自动替换为了 valueOf 方法，拆箱阶段自动替换为了 xxxValue 方法。

##java和字节码有什么区别

Java文件通过javac编译成虚拟机识别的字节码文件.class

## Serializable VS Parcelable

序列化是为了传输和存储

> 区别：

* Parcelable是Android提供的，Serializable是Java提供的
* Serializable 使用 I/O 读写存储在硬盘上，而 Parcelable 是直接 在内存中读写，Parcelable的效率要高于Serializable

Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据，而Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable

静态变量不会参与序列化过程

## 为何匿名内部类的参数引用要用 final 修饰

这里所说的匿名内部类主要是指在其外部类的成员方法内定义的同时完成实例化的类，若其访问该成员方法中的局部变量，局部变量必须要被final修饰。原因是编译器实现上的困难：**内部类对象的生命周期很有可能会超过局部变量的生命周期**。

1. 局部变量的生命周期：当该方法被调用时，该方法中的局部变量在栈中被创建，当方法调用结束时，退栈，这些局部变量全部死亡。而内部类对象生命周期与其它类对象一样：自创建一个匿名内部类对象，系统为该对象分配内存，直到没有引用变量指向分配给该对象的内存，它才有可能会死亡（被JVM垃圾回收）。所以完全可能出现的一种情况是：成员方法已调用结束，局部变量已死亡，但匿名内部类的对象仍然活着。

  2. 如果匿名内部类的对象访问了同一个方法中的局部变量，就要求只要匿名内部类对象还活着，那么栈中的那些它要所访问的局部变量就不能“死亡”。
3. 解决方法：匿名内部类对象可以访问同一个方法中被定义为final类型的局部变量。**定义为final后，编译器会把匿名内部类对象要访问的所有final类型局部变量，都拷贝一份作为该对象的成员变量。这样，即使栈中局部变量已经死亡，匿名内部类对象照样可以拿到该局部变量的值，因为它自己拷贝了一份，且与原局部变量的值始终保持一致**（final类型不可变）

## 两个Integer 用== 比较

int常量池中初始化-128~127的范围，所以当为Integer i=127时(相等)，在自动装箱过程中是取自常量池中的数值，而当Integer i=128时(不相等)，128不在常量池范围内，所以在自动装箱过程中需new 128，所以地址不一样

## 静态方法和实例方法有何不同

1. 静态方法可以被类名. 对象名.调用,实例方法只能后者
2. 静态方法只能访问静态变量/方法,实例方法都可访问
3. 锁不一样

因为实例成员变量是属于某个对象的，而静态方法在执行时，并不一定存在对象。同样，因为实例方法可以访问实例成员变量，如果允许静态方法调用实例方法，将间接地允许它使用实例成员变量，所以它也不能调用实例方法

## 接口和抽象类的区别

如果一个类没有足够的信息来描述一个具体的对象，而需要其他类来支撑它，那么这样的类我们称它为抽象类。比如new Animal()。子类的共性
接口在是抽象方法的集合。功能扩展
1.接口用interface,抽象类用abstract
2.接口方法全是抽象的，抽象类可以有普通方法的实现
3.集成extends,实现implement
4.抽象类可以有构造器，而接口不能有构造器
5.抽象方法可以有public、protected和default这些修饰符 ；接口方法默认修饰符是public
6.一个类只能继承一个抽象类，但可以实现多个接口

接口中的变量会被隐式地指定为public static final变量

## switch case/if else

switch会生成一个跳转表来指示实际的case分支的地址，而这个跳转表的索引号与switch变量的值是相等的。从而，switch不用像if那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位分支的目的

# 线程 ok

##开启线程3种方式

1. 继承 Thread 类，重写 run()方法， new Thread().start();
2. 实现Runnable接口，实现run()方法new Thread(new MyRunnable()).start()
3. 实现Callable接口，实现call()方法，使用FutureTask类来包装Callable对象，使用Thread包装FutureTask,调用start开启线程。调用 FutureTask的get()方法来获得子线程执行结束后的返回值。

> Runnable和Callable的区别是

使用Thread不能成其它类，使用Runnable/Callable可以实现其他类

1. Callable规定的方法是call(),Runnable规定的方法是run().
2. Callable的任务执行后可返回值，而Runnable的任务是不能返回值得
3. call方法可以抛出异常，run方法不可以

## 自定义线程池以及线程池的工作原理

> 1.通过ThreadPoolExecutor构造线程池

ThreadPoolExecutor 线程池用于管理多个线程，减少线程创建销毁消耗，提高代码执行效率

构造函数

- corePoolSize： 线程池核心线程数量。（默认情况下，核心线程一直存在）核心线程一旦创建会一直执行任务或等待任务到来，而非核心线程只在任务队列塞满任务时去执行多出的任务，并且非核心线程在等待一段时间后将会被回收，这个时间是keepAliveTime参数。
- maximumPoolSize：线程池最大线程数量。最大线程数=核心线程+非核心线程。执行完任务后非核心线程会被销毁。
- keepAliveTime： 非核心线程的超时时长。当等待时间超过这个时间时，非核心线程就会被回收。当任务很多，每个任务执行时间很短的情况下调大该值有助于提高线程利用率。注意：当allowCoreThreadTimeOut属性设为true时，该属性也可用于核心线程。
- unit： 线程池维护线程所允许的空闲时间的单位
- workQueue： 线程池所使用的任务队列
- threadFactory：线程池用于创建线程
- handler： 线程池对拒绝任务的处理策略

规则：

当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务；

如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行；

如果任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务；

如果线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，调用RejectedtionHandler来执行拒绝策略。

> 2.通过Executors构造线程池

* newCachedThreadPool：数量无限多的非核心线程，当有新任务来时如果没有空闲的线程则直接创建新的线程不会去排队而直接执行，并且超时时间都是60s，**适用：执行大量短期异步任务**
  * corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)；
* newFixedThreadPool：数量固定的核心线程，它们没有超时机制且排队任务队列无限制，因为全都是核心线程，所以响应较快，且不用担心线程会被回收。**适用：执行长期的任务，性能好很多**
  * 参数是nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue<Runnable>() 
* newScheduledThreadPool:数量固定的核心线程，且有数量无限多的非核心线程，但是它的非核心线程超时时间是0s，所以非核心线程一旦空闲立马就会被回收。**适用：周期性执行任务的场景**
  * corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列；
* newSingleThreadExecutor:内部只有一个核心线程，线程的存活时间是无限的。当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)，它确保所有任务进来都要排队按顺序执行。**适用：一个任务一个任务执行的场景**
  * corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列

阿里不建议用：

​	newCachedThreadPool和newScheduledThreadPool：创建线程数量是Integer.MAX_VALU，可能会创建大量线程，导致oom

​	newFixedThreadPool和newSingleThreadExecutor：队列长度时Integer.MAX_VALUE,可能会堆积大量请求，导致oom

> 线程池拒绝策略

1.AbortPolicy：当触发拒绝策略时，直接抛异常(默认)
2.CallerRunsPolicy ：当触发拒绝策略时，由提交任务的线程处理(main线程提交main执行)

3.DiscardPolicy ：触发策略时，丢掉被拒绝的任务

4.DiscardOldestPolicy ：触发策略时，就弹出队列头部的任务，把当前任务放到队头，然后尝试执行

当任务添加到线程池中之所以被拒绝，可能是由于：第一，线程池异常关闭。第二，任务数量超过线程池的最大限制

> 线程池核心数量确定

1. 先看下机器的CPU核数，然后在设定具体参数：

   CPU核数 = Runtime.getRuntime().availableProcessors()

2. 分析下线程池处理的程序是CPU密集型，还是IO密集型

   CPU密集型：核心线程数 = CPU核数 + 1

   ​	尽量使用较小的线程池，因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销

   IO密集型：核心线程数 = CPU核数 * 2

   ​	可以使用稍大的线程池，IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间

> 线程池优点

线程池主要用作管理子线程，优点有：

* 重用线程池中的线程，避免频繁创建和销毁线程所带来的内存开销。
* 有效控制线程的最大并发数，避免因线程之间抢占资源而导致的阻塞现象。
* 能够对线程进行简单的管理，提供定时执行以及指定时间间隔循环执行等功能

```
eg:ExecutorService executorService = Executors.newCachedThreadPool();
线程池一般用法：                        
 shutDown()，关闭线程池，需要执行完已提交的任务；
 shutDownNow()，关闭线程池，并尝试结束已提交的任务；
 allowCoreThreadTimeOut(boolen)，允许核心线程闲置超时回收；
 execute()，提交任务无返回值；
 submit()，提交任务有返回值；
 
 public class ThreadPool {
    //可同时下载的任务数（核心线程数）
    private int CORE_POOL_SIZE = 3;
    //缓存队列的大小（最大线程数）
    private int MAX_POOL_SIZE = 20;
    //非核心线程闲置的超时时间（秒），如果超时则会被回收
    private long KEEP_ALIVE = 10L;

    private ThreadPoolExecutor THREAD_POOL_EXECUTOR;

    private ThreadFactory sThreadFactory = new ThreadFactory() {
        private final AtomicInteger mCount = new AtomicInteger();

        @Override
        public Thread newThread(@NonNull Runnable runnable) {
            return new Thread(runnable, "download_task#" + mCount.getAndIncrement());
        }
    };

    ...................省略................

    public void setCorePoolSize(int corePoolSize) {
        if (corePoolSize == 0) {
            return;
        }
        CORE_POOL_SIZE = corePoolSize;
    }

    public void setMaxPoolSize(int maxPoolSize) {
        if (maxPoolSize == 0) {
            return;
        }
        MAX_POOL_SIZE = maxPoolSize;
    }

    public int getCorePoolSize() {
        return CORE_POOL_SIZE;
    }

    public int getMaxPoolSize() {
        return MAX_POOL_SIZE;
    }

    public ThreadPoolExecutor getThreadPoolExecutor() {
        if (THREAD_POOL_EXECUTOR == null) {
            THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(
                    CORE_POOL_SIZE, MAX_POOL_SIZE,
                    KEEP_ALIVE, TimeUnit.SECONDS,
                    new LinkedBlockingDeque<Runnable>(),
                    sThreadFactory);
        }
        return THREAD_POOL_EXECUTOR;
    }
}
```


##如何让两个线程循环交替打印，线程间同步的方法

>三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC....”的字符串。

```
public class TestPrint {
    ReentrantLock lock = new ReentrantLock();

    private  int count = 10;

    public void start() {
        Condition conditionA = lock.newCondition();
        Condition conditionB = lock.newCondition();
        Condition conditionC = lock.newCondition();
        new Thread(new TestRun(conditionA,conditionB,"A"),"线程1 ：").start();
        new Thread(new TestRun(conditionB,conditionC,"B"),"线程2 ：").start();
        new Thread(new TestRun(conditionC,conditionA,"C"),"线程3 ：").start();
    }

    class TestRun implements Runnable{

        private  Condition next ;
        // 当前Condition
        private  Condition now ;
        // 打印的字符
        private String str;

        public TestRun(Condition now, Condition next, String str) {
            this.now = now;
            this.next = next;
            this.str = str;
        }

        @Override
        public void run() {
            try {
                lock.lock();
                for (int i = 0;i<count;i++){
                    next   .signal();
                    Log.e("---",str);

                    now.await();
                }
            }catch (Exception e){

            }finally {
                lock.unlock();
            }

        }
    }
}
```

> 两个线程交替打印 0~100 的奇偶数

```
public class OddEvenPrinter {

    private Object monitor = new Object();

    public void start() {
        PrintThread printThread = new PrintThread();
        new Thread(printThread, "线程1").start();
        new Thread(printThread, "线程2").start();
    }

    class PrintThread implements Runnable {

        volatile int count = 1;

        @Override
        public void run() {
            synchronized (monitor) {
                while (count < 100) {
                    try {
                        System.out.println(Thread.currentThread().getName() + " : " + (count++));
                        monitor.notify();
                        monitor.wait();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行， 只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放），调用wait方法的一个或多个线程就会解除wait状态，重新参与竞争对象锁，程序如果可以再次得到锁，就可以继续向下运行。
```

##怎么中止一个线程，Thread.Interupt一定有效吗？

停止一个线程应该从任务上去停止，而不是在线程中添加停止方法

1. 使用volatile boolean变量退出标志，使线程正常退出，也就是当run方法完成后线程终止。
2. 使用interrupt()方法中断线程，但是线程不一定会终止。
3. 使用stop,但是因为线程不安全，废弃

interupt:

- 如果线程未在阻塞状态，这个方法仅仅是设置了interrupt状态
- 如果线程在阻塞状态，这个方法会清除interrupt状态并抛异常

判断当前线程是否已经中断

​	Thread.interrupted()是静态方法，获取中断状态，并清空

​	thread.isInterrupted()是非静态方法，获取不清除状态

```
// Case 1 无阻塞的情况 通过加标记来退出循环
public static void main(String[] args) throws Exception {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                int i = 0;
                while(!Thread.interrupted()) {
                    System.out.println(i++);
                    break;
                }
            }
        });
        thread.start();
        Thread.sleep(50);
        thread.interrupt();
    }
    
// Case 2 有阻塞的情况 产生异常退出循环
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                int i = 0;
                try {
                    while(!Thread.interrupted()) {
                        System.out.println(i++);
                        Thread.sleep(1);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    // 抛出 InterruptedException 后中断标志被清除，标准做法是再次调用 interrupt 恢复中断
                    Thread.currentThread().interrupt();
                }
            }
        });
        thread.start();
        Thread.sleep(50);
        thread.interrupt();
    }
    
join:等待线程结束
yield:使线程暂停并允许执行其他线程，不会释放锁
interrupt:中断线程
```

> 为什么不能简单的停止一个线程？

因为当一个线程执行任务的时候，它会占用cpu以及内存的资源，并且锁住这些资源，如果我们要将线程异常终止，那么当前线程就来不及对资源进行清理，那么下一个线程在访问当前资源的时候就会产生异常信息

## 线程的几种状态

1. 新建状态：新创建一个线程对象。
2. 就绪状态：线程对象创建后，调用start()方法。等待获取CPU的使用权。
3. 运行状态：就绪状态的线程获取了CPU，执行程序代码。
4. 阻塞状态：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态
5. 死亡状态：run方法执行结束

## 线程间同步的方式：

1.synchronized
2.Lock

#锁和并发 OK

##为什么多线程同时访问（读写）同个变量，会有并发问题？

Java 内存模型规定了所有的变量都存储在主内存中，每条线程有自己的工作内存。
线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。
线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。
不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步。

##乐观锁与悲观锁

悲观锁：总是假设最坏的情况，每次去拿数据的时候都会认为别人会修改，所以每次拿数据的时候都会上锁，线程一旦得到锁，其他线程就挂起等待，适用于写入操作频繁的场景；synchronized 就是悲观锁 
乐观锁：总是假设最好的情况，每次拿数据时都认为别人不会修改，不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用CAS实现。适用于读取操作频繁的场景

##ReentranLock跟synchronized有什么区别？synchronized与ReentranLock发生异常的场景？

> 相同

都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待

> 不同

1. API层面

   * synchronized是关键字，是原生语法层面的互斥，需JVM实现。ReentranLock是1.5之后API提供的

   * synchronized可以修饰方法和代码块,Reentranlock只能在方法内使用

2. 等待可中断

   * 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，去处理别的事情
   * 假如业务代码中有两个线程，Thread1 Thread2。假设 Thread1 获取了对象object的锁，Thread2将等待Thread1释放object的锁。
     - 使用synchronized。如果Thread1不释放，Thread2将一直阻塞等待，不能被中断。
     - 使用ReentrantLock。如果Thread1不释放，Thread2等待了很长时间以后，可以中断等待，转而去做别的事情。

3. 公平锁

   * 公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序获取锁，而非公平锁则是任何一个等待的线程都可以获取锁
   * synchronized是非公平锁，ReentranLock默认是非公平锁，但可以通过构造函数设置True使用公平锁

```
private ReentrantLock lock = new ReentrantLock();
public void run() {
    lock.lock();
    try{
        for(int i=0;i<5;i++){
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }finally{
        lock.unlock();
    }
}
```

> synchronized与ReentranLock发生异常的场景

发生异常的场景我查了半天没查到，应该就是线程抛出异常吧

在发生异常时，synchronized会自动释放锁，ReentranLock则需要与try{}finally{}搭配手动释放锁

##synchronized是公平锁还是非公平锁,ReentranLock是公平锁吗？是怎么实现的 

公平锁是指多个线程在等待同一个锁时，必须按照申请的顺序获取锁，而非公平锁则是任何一个等待的线程都可以获取锁

公平锁：

* 优点：所有的线程都能得到资源，不会饿死在队列中。
* 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞

非公平锁：

* 优点：减少唤起线程的开销，整体的吞吐效率高,因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程
* 缺点：处于等待队列中的线程可能会饿死

synchronized是非公平锁，ReentranLock默认是非公平锁，但可以通过构造函数设置True使用公平锁

>ReentranLock是怎么实现的

文章：https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html https://juejin.cn/post/6844903805683761165 （继续背1）

ReentranLock是基于 AQS来实现的。 

AQS内部实现了两个队列，分别是同步队列和条件队列。其中同步队列是一个双向链表，里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而条件队列是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，AQS所做的就是管理这两个队列里面线程之间的等待状态-唤醒的工作。

AQS提供了两种方式去获取资源，分别是共享模式和独占模式，但是一般锁只会去继承其中一种模式，不会在一个锁里同时存在共享模式和独占模式两种模式

* 独占模式即一个线程获取到资源后，其他线程不能再对资源进行任何操作，只能阻塞获得资源
* 共享模式下，线程无论是获取资源还是释放资源，都可能会唤醒后继节点

##synchronized底层原理是什么 

文章：https://juejin.cn/post/6844903670933356551#comment （继续背2）

Monitor：

每个对象都存在着一个monitor与之关联，monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机中，monitor是由ObjectMonitor实现的。

ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装成ObjectWaiter对象)，owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入EntryList 集合，当线程获取到对象的monitor 后进入Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)


![monitor原理.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/monitor%E5%8E%9F%E7%90%86.png?raw=true)


原理：

同步代码块

Synchronized经过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。当执行monitorenter指令时，当前线程将试图获取对象锁所对应的 monitor 的持有权，若对象锁的Monitor的计数器是0，那线程可以成功取得monitor，并将计数器值设置为1，取锁成功。如果当前线程已经拥有对象锁的 monitor 的持有权，那它可以重入这个 monitor，重入时计数器的值也会加 1。倘若其他线程已经拥有对象锁的 monitor的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 

同步方法：

synchronized修饰的方法并没有monitorenter指令和monitorexit指令，取得代之的确实是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用
当方法调用时，调用指令会检查方法的 ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有monitor，然后再执行方法，最后再方法完成时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛出了异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。

> 静态方法与普通方法加synchronized有什么区别 

普通方法是对调用该方法的对象加锁，锁是对象的this实例，静态方法是对该方法所在的类加锁,锁是对象的class实例

> 类锁和对象锁有啥区别

1.一个类可以有多个对象，所以一个类可以有多个对象锁。一个类只能有一个.claas，所有一个类只能有一个类锁
2.类锁是加持在类上的，用synchronized static 或者synchronized(class)方法使用的锁都是类锁，因为class和静态方法在系统中只会产生一份，所以在单系统环境中使用类锁是线程安全的；对象锁：synchronized 修饰非静态的方法和synchronized(this)都是使用的对象锁，一个系统可以有多个对象实例，所以使用对象锁不是线程安全的，除非保证一个系统该类型的对象只会创建一个，才能保证线程安全;

> synchronized能不能继承

父类方法中有synchronized关键字修饰，子类继承该父类的方法也有Synchronizde关键字的效果，但是如果重写该方法时不显式加上synchronized关键字时则不会有效果

> 非静态方法A和B在同一个类中，方法A用synchronized修饰，当A方法因为多线程请求有线程阻塞在对象锁上的时候，B方法的访问受不受影响？

B方法若是普通方法，不受影响，若是synchronized修饰，也是获取对象锁的话，则会同样阻塞，等待A执行完才能执行，B若是用的类锁，也不影响

> 锁的释放和获取的内存语义

- 当线程释放锁时，JVM会把线程本地内存中的共享变量刷新到主内存中。
- 当线程获取锁时，JVM会把该线程本地内存置为无效。从而可以使得被监视器保护的临界区代码必须从主内存中读取共享变量。

> CAS

https://houbb.github.io/2018/07/24/java-concurrency-06-cas

CAS的思想：三个参数，一个当前内存值V、预期值A、即将更新的值B，仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。在CAS中，比较和替换是一组原子操作，不会被外部打断，且在性能上更占有优势。CAS与volatile结合，实现乐观锁

AtomicInteger底层原理：CAS与volatile结合。值用 volatile 修饰，保证了多线程之间的内存可见性。利用CAS机制去修改值，因为值是内存可见的，所以下次别的线程也能成功执行

存在的问题：
1.ABA 问题：因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A， 那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。 ABA问题的解决思路就是使用版本号。

在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。

从Java1.5开始JDK的atomic包里提供了一个类 AtomicStampedReference 来解决ABA问题。 这个类的 compareAndSet 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
2.循环时间长开销大：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。
3.只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁， 或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。

比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。

从Java1.5开始JDK提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。

> 锁升级

锁优化基本上就是基于CAS。

```
Synchronized的实现依赖于锁对象的Monitor,而monitor是基于操作系统的mutex Lock实现，而基于Mutex Lock实现的同步必须经历从用户态到内核态的转换，这个开销特别大。所以频繁的通过Synchronized实现同步会严重影响到程序效率，为了减少重量级锁带来的性能开销，JDK对Synchronized进行了种种优化。

一个锁对象默认是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。

一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象是偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则去看那个线程的操作栈，是否仍然需要持有偏向锁，如果需要则偏向锁升级为轻量级锁。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。

轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转
```

1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态

* 偏向锁

  大多数情况锁总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁

  * 获取锁：

  ​		检测锁的对象头是不是可偏向状态，若为可偏向状态，并且没有线程持有这个偏向锁，则将对象头的线程ID替换为当前线程ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作，竞争失败，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁

  * 释放锁： 

  ​		偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。

* 轻量级锁
   当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁

  * 获取锁：

    JVM首先在当前线程的栈帧中建立一个名为锁记录空间，利用CAS操作将对象的对象头指向锁记录，如果成功，表示竞争到锁，则将锁标志位变成00，执行同步操作。或者当前对象的对象头指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块。若是竞争失败说明该锁对象已经被其他线程抢占了，这时锁标志位变成10，开始自旋；

  * 释放锁： 轻量级锁的释放也是通过CAS操作来进行的

* 自旋锁：
  轻量级锁失败后，虚拟机会进行一项称为自旋锁的优化手段

  * 自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。

  * JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在这个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。

* 锁消除

  在有些情况下，JVM检测到不可能存在共享数据竞争，这时JVM会对这些同步锁进行锁消除

* 重量级锁
  重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高

##volatile字段有什么用途？

> 作用

1. 保证内存可见性
2. 禁止指令重排
   指令重排序是JVM为了优化指令、提高程序运行效率，在不影响程序执行结果的前提下，尽可能地提高并行度。指令重排序包括编译器重排序和运行时重排序。

> synchronized和volatile的区别

volatile保证修饰的变量在多个线程中数据一致的效果，需从主存中读取；synchronized则是通过加锁的方式，只有当前线程可以访问该变量，其它线程被阻塞住。
区别

1. volatile 仅能使用在变量级别；synchronized则可以使用在方法和代码块。

2. volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性。

3. volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。

4. volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住

> volatitle原理

被volatile修饰的共享变量进行写操作时候会多出Lock前缀的指令，该指令在多核处理器下会引发两件事情。
1.将当前处理器缓存行的数据写回到系统内存
2.这个写回主内存的操作会使其他CPU缓存的该共享变量内存地址的数据无效。

缓存行是为了解决CPU计算速度和内存处理速度不一致出现的

1.程序以及数据被加载到主内存

2.指令和数据被加载到CPU缓存

3.CPU执行指令，把结果写到高速缓存

4.高速缓存中的数据写回主内存

Lock指令有内存屏障的效果 

这样就保证了多个处理器的缓存是一致的，对应的处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器缓存行设置无效状态，当处理器对这个数据进行修改操作的时候会重新从主内存中把数据读取到缓存里。

> 由于volatile修饰的变量在各个线程里都是一致的，所以基于volatile变量的运算在多线程并发的情况下是安全的?

这句话的前半部分是对的，后半部分却错了，因为它忘记考虑变量的操作是否具有原子性这一问题（指一个操作是不可中断的，要么全部执行成功要么全部执行失败）

在不符合以下场景下我们依然需要通过加锁来保证原子性：

- 运算结果并不依赖变量当前的值，或者只有单一线程修改变量的值。（要么结果不依赖当前值，要么操作是原子性的，要么只要一个线程修改变量的值）
- 变量不需要与其他状态变量共同参与不变约束 比方说我们会在线程里加个boolean变量，来判断线程是否停止，这种情况就非常适合使用volatile。

> 并发三大特性

- 原子性

一个操作或者多个操作，要么全部执行成功，要么全部执行失败。满足原子性的操作，中途不可被中断。

- 可见性

多个线程共同访问共享变量时，某个线程修改了此变量，其他线程能立即看到修改后的值。

- 有序性

程序执行的顺序按照代码的先后顺序执行。

# 多进程 OK

## Android多进程导致的问题

1. 采用多进程方式，Application onCreate 方法会执行多次。
   1. 判断当前进程是主进程才执行初始化代码
2. 进程间通信

> SP使用多进程的问题

SharedPreferences不支持多个进程同时写，会有一定的几率丢失数据

> 为什么使用多进程

1. 分担主进程的内存压力，并且获取更大的内存空间
2. 防止进程被杀死

## SP

> SharedPreference的commit ，apply区别

1. commit，apply存储过程是原子性
2. commit方法有返回值，设置成功true，否则是false;apply没有返回值
3. commit写是同步的，apply写是异步提交到磁盘

如果不关心设置成功与否，并且是在主线程设置值，建议用apply方法

> SP线程安全吗，锁是啥

安全 https://leo-wxy.github.io/2020/11/18/Android-SharedPreferences%E7%AE%80%E6%9E%90/#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8 进程不安全

# 异常

##java的异常类型有哪几种？Excetpion和Error的区别是什么？
两种：Error和Exception。两者的父类都是Throwable

区别：

* Error：是程序处理的范畴之外；Error用来指示运行时环境发生的错误。例如：JVM的内存溢出，系统崩溃，一般的，程序不会从错误中恢复。
* Exception：程序可以处理的异常，可以捕获且可以恢复。遇到这类异常应该尽可能处理异常，不应该随意终止异常
  * CheckedException（编译时异常）：需要用try catch显示的捕获IOException、SQLException
  * RuntimeException（运行时异常）：不需要捕获，运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。NullPointerException、IndexOutOfBoundsException

> OOM

oom可以被捕获，eg:大图加载框架中用到了

原理：申请的内存>现有的内存

#HashMap的原理 ok 

hashmap内部结构是由在数组+链表实现的，其中数组是Node[]数组，存放的是key-value键值对的节点，默认初始长度是16，当链表大于8并且数组长度大于 64 时，链表结构会转换成红黑树结构。之所以添加红黑树是因为一旦链表过长，会严重影响 HashMap 的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题，hashmap key,value均可为null(TreeMap不支持null键，但是支持null值) O(1)

为啥有个64：为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表而导致不必要的转化

然后再说一下hashmap的方法实现

* put：先判断数组是否为空，为空的话扩容，不为空根据(n - 1) & key.hash的哈希值计算出要插入的数组索引 i，如果 table[i] 等于 null，则直接插入，不为空判断key和hash是否相等，相等就覆盖，不相等就查看table[i]是否是红黑树节点，如果是的话就用红黑树直接插入，如果不是就遍历链表，遇到重复元素就覆盖，否则直接插入，如果链表长度大于8，转为红黑树结构，执行完成后看元素个数是否大于阈值threshold，大于就扩容，否则直接结束
* get：首先判断数组是否为null，为空返回null,不为空，计算出数组索引i，判断table[i] key和hash是否相等，是返回，不是则看下一个节点，如果是树结构，则使用 getTreeNode 直接获取相应的数据，非树结构，循环节点判断，hash 相等并且 key 相同，则返回此节点

> 为什么不直接使用红黑树，而是要先使用链表实在不行再转红黑树呢

因为树节点所占的空间是链表节点的两倍，尽管转为树使得查找的速度更快（红黑树的查找效率为o(logN)，要优于链表的o(N)），但是在节点数比较少的时候，此时对于**红黑树来说内存上的劣势会超过查找等操作的优势**，自然使用链表更加好，但是在节点数比较多的时候，综合考虑，红黑树比链表要好。

> 扩容机制

什么时候发生扩容？

1. 当put时hash表为空，会发生一次。
2. 添加元素时，当元素个数>表长度*加载因子时也会扩容
3. 在链表长度>8，数组长度<64时也会发生扩容

扩容过程中是数据是整体复制么？

​	不是

hashmap的扩容中主要进行两步：

1. 把数组长度变为原来的两倍  
2. 新数组赋值时，元素的链表只有一个，则直接进行赋值，元素是红黑树，则split直接插入，元素是链表时。插入时不用重新计算hash，通过高位运算看高一位是0还是1，如果是1这个元素在新数组中的位置，是原下标+原数组长度，如果是零位置不发生变化，还是原下标。

> 是怎么解决Hash冲突的

当hash值相同，需要放到同一个位置就会发生冲突。

hashmap采用链表法来解决hash冲突：链表法就是将相同下标的对象组织成一个链表放在对应的位置

> 加载因子

加载因子用来判断什么时候进行扩容的，假如加载因子是 0.5，HashMap的初始化容量是 16，那么当 HashMap 中有 16*0.5=8个元素时，HashMap 就会进行扩容

那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？

这其实是出于容量和性能之间平衡的结果：

1.当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此底层红黑树就会变得异常复杂，这样对元素的操作时间就会增加

2.当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，但是空间就会变大

为了提升扩容效率，HashMap的容量有一个固定的要求，那就是一定是2的幂，所以，如果负载因子是3/4的话，那么和capacity的乘积结果就可以是一个整数

所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子

> hash方法细节

 (h = key.hashCode()) ^ (h >>> 16)

> 链表转红黑树的阈值为何是8,红黑树转链表的限制为何是6

在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为8的时候，概率仅为0.00000006。这是一个小于千万分之一的概率，作者应该是根据概率统计而选择了8作为阀值。通常情况下，并不会发生从链表向红黑树的转换。
链表长度超过 8 就转为红黑树的设计，更多的是为了防止用户自己实现了不好的哈希算法时导致链表过长，从而导致查询效率低，而此时转为红黑树更多的是一种保底策略，用来保证极端情况下查询的效率。
通常如果 hash 算法正常的话，那么链表的长度也不会很长，那么红黑树也不会带来明显的查询时间上的优势，反而会增加空间负担。所以通常情况下，并没有必要转为红黑树，所以就选择了概率非常小，小于千万分之一概率，也就是长度为 8 的概率，把长度 8 作为转化的默认阈值。

> hashmap大小为什么是2的幂次方

计算下标=(n - 1) & key.hash，当n是2的幂次方，n - 1的值的二进制所有的位均为1，这种情况下，Index的结果等于hashCode的最后几位。只要输入的hashCode本身符合均匀分布，Hash算法的结果就是均匀的。

HashMap的长度为2的幂次方的原因是为了减少Hash碰撞，会使计算的下标均匀分布，尽量使Hash算法的结果均匀分布。

> 为什么不直接使用 key 而要使用 key 的 hash 值？

答：考虑到效率问题如果直接使用 key，那么在查找的时候需要调用 key 的 equals() 方法去逐个比较，时间复杂度从原本的 O(1) 变成了 O(n) ，且 equals() 比较的效率也很低，而通过 hash 值可以直接定位到桶。

> 那为什么又不直接用 hash 值作为数组上的索引？

答：为了防止数组下标越界，因为 hash 值不确定性，很容易越界。

> 索引为什么用的是 (n - 1) & hash，而不是 hash % n 呐？

答：其实早期版本就是用 hash % n，但是为了追求效率，后来就改成了位运算 (n - 1) & hash， 当 n 为 2 的指数，(n - 1) & hash 与 hash % n是等价的

> HashMap为啥线程不安全

当有多个线程共同操作hashMap扩容插入元素操作时，在这个时候cpu切换资源的话，会造成链表成环问题，死循环问题。

https://www.cnblogs.com/qmillet/p/13054208.html

> HashMap 1.7和1.8区别 71 82

1. 扩容
   1. 头插法 ：采用头插法时会容易出现逆序且环形链表死循环问题：先将原位置的数据移到后1位，在插入数据到该位置，会出现环形列表问题
   2. 尾插法：可以避免：直接插入到链表尾部
2. 数据结构
   1. 数组+链表
   2. 数组+链表+红黑树

http://www.louisvv.com/archives/2487.html 

https://juejin.cn/post/6844903744711163911#comment

##HashMap ArrayMap SparseArray的区别

ArrayMap内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Key-Value值，会对key使用二分法进行从小到大排序，在添加、删除、查找也会使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作，如果在数据量比较大的情况下，那么它的性能将退化至少50%。

SparseArray 存储整型类型的 key，它比HashMap 更省内存,某些条件下 性能更好,主要是因为它避免了对key的自动装箱。ArrayMap 与 SparseArray最大的一点不同就是 ArrayMap的key可以为任意的类型。而SparseAraay的key只能是整型。

> 区别

1. 内部数据结构不一样，，一个是数组+链表，一个是两个数组
2. 占用内存不一样，arrayMap占用内存更低
3. 扩容机制不一样：
   1. 首先数组的容量会扩充到BASE_SIZE，如果BASE_SIZE无法容纳，则扩大到2 * BASE_SIZE，如果2 * BASE_SIZE仍然无法容纳，则每次扩容为当前容量的1.5倍

> HashMap 与 SparseArray比较

当数据量 少于500时,使用SparseArray ，要优于HashMap。

> SparseArray 与 ArrayMap使用场景：

- 当 key为整型时,推荐使用SparseArray
- 当 key为其它类型时,推荐使用ArrayMap

## Android里面的LRUCache是如何实现的

近期最少使用算法，它的核心思想就是会优先淘汰那些近期最少使用的缓存对象

LruCache使用了LinkedHashMap 双向链表来实现，总缓存的大小一般是可用内存的 1/8，当超过总缓存大小会删除最少使用的元素，也就是内部 LinkedHashMap 的头部元素。当使用get()访问元素后，会将该元素移动到 LinkedHashMap 的尾部

> 怎么自己实现一个

缓存策略分为添加、获取和删除

#泛型 Ok

##有什么优点？

1. 在编码期保证类型安全性
   1. list<integer> arraylist 一个只能存放int,一个啥都可以存，编译的时候不会报错
2. 避免了手动强制转换
3. 代码观看清晰条理

##泛型擦除，为何会有擦除？擦除的时机。通配符

泛型信息在编译后，进入JVM之前擦除

在类型擦除的时候，如果泛型类里的类型参数没有指定上限，则会被转成Object类型，如果指定了上限，则会被传转换成对应的类型上限。最后又通过强制转化来进行一个转变

https://juejin.cn/post/6844904083199918093#comment

> 为什么会有泛型擦除？

1.jvm不识别泛型，需要对JVM代码进行修改

2.版本兼容，兼容1.5之前的API，而且Java 中不支持高版本的 Java 编译生成的 class 文件在低版本的 JRE 上运行

> 带来的问题

1. 强制类型转换
2. 因为转成了object,所以可以通过反射，在一个List<Integer>中在不知情的情况下插入了一个String类型的数值

> 通配符

通配符的出现是为了指定泛型中的类型范围
通配符有 3 种形式：

```
<?>被称作无限定的通配符。
<? extends T>被称作有上限的通配符。
<? super T>被称作有下限的通配符。
```

> Kotlin 泛型

协变：如果A是B的子类型，那么Generic<A>也是Generic<B>的子类，这就是协变。out = <? extends T> 

​	被其修饰的泛型只能作为生产者输出，而不能作为消费者输入。所以'out'修饰的泛型常常作为方法的返回而使用

逆变：如果A是B的子类型，反过来Generic<B>是Generic<A>的子类型，我们称这种关系为逆变。in = <? super T>

​	in修饰的泛型只能作为输入类型，而不能作为返回类型

kotlin泛型是为了解决

```
ArrayList<? extends Object> list = new ArrayList<>();
list.add(0);//编译器报错

val lis = arrayListOf< Any>()
lis.add("")//不报错
```

## 反射可以反射final修饰的字段吗

可以。被final修饰的变量，只是说栈存储的地址不能再改变，但是却没有说地址指向的内容不能改变，所以反射可以破final，因为它修改该了以前地址的具体内容，但是没有改地址的信息。

然后被static修饰的变量也能修改，同样道理，只不过第一个参数为null，但是同时被final和static变量修饰的就不能被修改了，会抛出异常。这种可以通过反射去掉final来修改

> 怎么提升反射效率

1.缓存重复用到的对象
2.setAccessible(true)来关闭安全检查，安全检查其实也挺耗时的

> 反射原理

Java在编译之后会生成一个class文件，反射通过字节码文件找到其类中的方法和属性等

# JVM类加载机制&垃圾回收 Ok

## JVM类加载机制了解吗，类什么时候会被加载？类加载的过程具体生命周期是怎样的？

> 类加载机制

JVM把Class文件中的类数据加载到内存，并对数据进行校验解析初始化，最终形成可以被JVM直接使用的过程就是类加载机制

> Person p = new Person() 实例化过程

1. JVM读取class文件(方法区)，加载进内存。如果有直接父类的情况下会先加载person的父类 
2. 在栈内存声明变量P
3. 在堆内存中给对象开辟空间并对对象的属性进行默认初始化。(int = 0,String = null）
4. 构造函数进行初始化。会先初始化父类构造
5. 父构造初始化完毕以后，再对子类的属性进行赋值初始化。
6. 在进行子类构造函数的特定初始化，此时，初始化子类的成员变量，局部代码块，然后继续执行子类的构造函数。
7. 初始化完毕以后，将地址赋值给引用变量

static代码块–>普通代码块–>类构造方法

> 什么时候被加载

Java虚拟机没有明确规定一个类在什么时候会被加载，但是它严格规定了只有以下情况必须对类进行初始化操作，在初始化操作之前必定会触发类的加载和连接

1. 遇到`new`、`getstatic`、`putstatic`、`invokestatic`这四条字节码指令时
   1. 使用`new`关键字实例化对象时；对应`new`字节码指令
   2. 读取或设置一个类的静态字段（被`final`修饰的、在编译期把结果放入常量池的静态变量除外）时；对应`getstatic`和`putstatic`字节码指令
   3. 调用一个类的静态方法时；对应`invokestatic`字节码指令
2. 使用`java.lang.reflect`包的方法第一次对类进行反射调用时会触发类的初始化

> 生命周期

Java类从加载到内存到移除，它的整个生命周期分为： https://blog.csdn.net/zhangliangzi/article/details/51319033

1. 加载：通过全路径名加载Class文件到内存
2. 验证：验证被加载后的类是否有正确的结构(链接)
3. 准备：为类的静态变量在方法区分配内存，并初始赋值（对于一般的成员变量是在类实例化时候，随对象一起分配在堆内存中(链接)
4. 解析：将类的二进制数据中的符号引用换成直接引用(链接)
5. 初始化：对类的静态变量，静态代码块执行初始化操作

> DexClassLoader与PathClassLoader的区别

DexClassLoader和PathClassLoader，都继承于BaseDexClassLoader。区别在于调用父类构造器时，DexClassLoader多传了一个optimizedDirectory参数，这个目录必须是内部存储路径，用来缓存系统创建的Dex文件。而PathClassLoader该参数为null，只能加载内部存储目录的Dex文件

1. DexClassLoader用于加载指定目录中的class文件，一般用于热修复
2. PathClassLoader用于加载已经安装到系统中的apk中的class文件
3. BootClassLoader用于加载Framework层class文件

源码：https://www.jianshu.com/p/7e30ba5cb9ea

> 双亲委托机制

在加载类的时候，是采用的`双亲委派机制`，即把请求交给父类处理的一种任务委派模式

先简单介绍下双亲委托机制： 

1. 首先判断该Class是否已经加载
2. 如果没有则不是自身去查找而是委托给父加载器进行查找，这样依次的进行递归，直到委托到最顶层的ClassLoader
3. 如果顶层 ClassLoader找到了该Class，就会直接返回
4. 如果没找到，则继续依次向下查找，如果还没找到则最后会交由自身去查找

为什么使用双亲委托机制？
能有有效的确保一个类的全局唯一性

避免核心类篡改：类加载器在发现与核心API同名的类时，发现该类已被加载，就不会去加载，而直接返回已加载过Integer.class，这样便可以防止核心API库被随意篡改。java.lang.Integer

由不同的类加载器加载的类会被JVM当成同一个类吗？
不会。
在Java中，我们用包名+类名作为一个类的标识。
但在JVM中，一个类用其包名+类名和一个ClassLoader的实例作为唯一标识，不同类加载器加载的类将被置于不同的命名空间

> 热修复原理

类加载器在加载一个类时会先从自身DexPathList对象中的Element数组中获取到对应的类，再加载。采用的是数组遍历的方式，不过注意，遍历出来的是一个个的dex文件。在for循环中，首先遍历出来的是dex文件，然后再是从dex文件中获取class，所以，我们只要让修复好的class打包成一个dex文件，放于Element数组的第一个元素，这样就能保证获取到的class是最新修复好的class了（当然，有bug的class也是存在的，不过是放在了Element数组的最后一个元素中，所以没有机会被拿到而已

将补丁dex文件放到dexElements数组靠前位置，这样在加载class时，优先找到补丁包中的dex文件，加载到class之后就不再寻找，从而原来的 apk 文件中同名的类就不会再使用，从而达到修复的目的

##垃圾回收机制与jvm结构，老年代算法，方法区有啥，GCRoot都有啥 

    这篇文章写得挺好挺全的  https://juejin.im/post/6844903905457864718

>jvm内存结构

![Jvm内存结构.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/Jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png?raw=true)

* PC、虚拟机栈，本地方法栈是线程私有区域，其生命周期和线程相同；方法区和堆是线程共享区域，生命周期跟虚拟机相同，
* 除pc之外，别的区域都有可能造成OOM

1. 程序计数器 :指向当前线程所执行的字节码的行号
2. 虚拟机栈：主要描述方法执行，每个方法在执行的时候创建一个栈帧，其中栈帧中存储了函数中定义的基本数据类型变量以及对象的引用变量(局部变量表，操作数栈，动态链接，方法出口等信息)。每一个方法从调用到执行结束，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
   1. 局部变量表：方法参数和方法内局部变量
   2. 操作数栈：表达式计算在操作数栈中完成
   3. 方法出口：方法执行完后需要返回到方法被调用的位置
   4. 动态链接：指向运行时常量池的引用
   5. 异常：栈内存溢出（Stack Overflow Error）
3. 本地方法栈：虚拟机栈执行java方法；本地方法栈执行native方法。比如java中调用C或C++中的方法，在这里执行。
4. 堆：创建的对象与数组都保存在java堆内存中，因为是线程共享，所以与方法区两个是垃圾收集的区域，java堆中从GC的角度细分为：新生区与老年区。
5. 方法区：**用于存储被jvm加载的类信息、常量、静态变量、编译器编译后的代码等数据**
   1. 实现类似堆的永久代实现，GC算法也一样，GC主要用于常量池和无用的类的回收
   2. Class文件包括 1.类信息包括类的版本，字段，方法，接口等描述信息 2.常量池

> 如何判断一个对象需要被回收

不再使用的对象需要进行回收，不使用的类也有可能回收。

通过两个方法来判断对象不再被使用：

1. 引用计数法: 给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减一；任何时刻计数器为0的对象就是不会被使用的对象。

2. GC root: 以GC Root的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GC Roots没有任何引用链相连的时候，就证明此对象是不可用的

>可以作为GC root对象包括：

* 虚拟机栈（栈帧中的本地变量表）中的引用对象。
* 方法区中的静态属性或常量（final）引用的对象。
* 本地方法栈中Native方法引用的对象。

>垃圾回收机制

垃圾回收机制采用的是分代收集。根据根据对象存活的不同年龄划分不同的域。新生代：老年代=1：2

* 新生代：对象存活率低，复制算法
  * 新生代分为Eden和两块Survivor,比例为8：1：1，每次使用Eden和其中一块Survivor空间，当进行回收时，将两块空间中还存活的对象复制到另一块Survivor空间中。如果存活的某对象的空间>Survivor空间，则将对象移到老年代
  * GC触发条件：当要申请的空间>Eden和其中一块Survivor剩余的空间时，会发生GC
  * 当对象在Survivor躲过一次GC，其年龄会+1，默认情况下当年龄到达15时，会被移到老年代
  * 因为新生代对象的特点是生命周期短，存活率低，所以采用复制算法。一般的复制算法每次只能使用一半的空间，这个是全部空间
* 老年代：对象存活率高，标记整理算法和标记清除算法
  * GC触发条件：
    * 显式调用System.gc()方法
    * 老年代空间不足
    * 从新生代进入老年代的空间大于老年代空闲空间

垃圾回收算法：

1. 标记-清除算法：首先标记出存活的对象，在标记完成后会对未标记的对象进行回收   
   1. 缺点：碎片多；虚拟机在给内存较大对象分配空间时，有可能找不到足够大的连续空间存放，从而引发垃圾回收动作。实际上有大量空闲空间，只是不连续；
2. 复制算法：将内存分为两块大小一样的区域，每次是使用其中的一块。当这块内存块用完了，就将这块内存中还存活的对象复制到另一块内存中，然后清空这块内存。
   1. 可用内存小
3. 标记-整理算法：标记过程与标记-清除算法一样，接下来让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
   1. 仍需要进行局部对象移动，一定程度上降低了效率

> 方法区1.7 1.8 区别

在1.8中方法区是由元空间来实现的,常量池移到堆中，1.8不存在方法区,将方法区的实现给去掉了
元空间: 存储.class 信息, 类的信息,方法的定义,静态变量等.而常量池放到堆里存储。元数据空间并不在虚拟机中，而是使用本地内存。

![JVM1.8方法区.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/JVM1.8%E6%96%B9%E6%B3%95%E5%8C%BA.png?raw=true)

#注解

注解，是一种信息描述，可以用来配置一些代码或者功能。不影响代码执行。常见的注解比如@Override,代表重写方法

##编译期注解处理的是字节码还是java文件 Ok

应该是处理的Java文件，然后生成字节码

APT即为Annotation Processing Tool，它是javac的一个工具，中文意思为编译时注解处理器。APT可以用来在编译时扫描和处理注解。通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来自动的生成一些代码，省去了手动编写。注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。APT的核心是AbstractProcessor类。

ButterKnife，eventbus都使用了APT技术

#设计模式 Ok

##你在项目中有用到什么设计模式吗

> 单例

工具类封装、GlideEnger

```
懒汉：
public class Singleton {
	如果线程A在实例化对象的时候，指令重排序导致先将内存地址复制给对象，而不是先将对象在内存中初始化，那么此时线程B进来会跳过第一次null检查，此时是会有空指针问题的
    private volatile static Singleton instance = null;

    private Singleton() {
    }
    public static Singleton getInstance() {
        if (instance == null) {避免了每次synchronized操作，提升性能
            synchronized (Singleton.class) {避免多线程并发时出现instance多次赋值而达不到单例的效果，加同步后可以避免这个问题
                if (instance == null) {如果线程a和b同时操作，a先获得锁进入了，这个时候如果释放了锁，b进入锁先一步进行了初始化工作，这个时候a也进行了初始化工作，这就有了两个实例了，不符合要求，所以第二个判空条件不能去掉
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
为啥加volatile，禁止指令重排序
1.分配内存空间；2.初始化对象3. 将singleton对象指向分配的空间，所以这个时候instance就不为null了
如果虚拟机存在指令重排序优化，则步骤2和3的顺序是无法确定的。如果A线程率先进入同步代码块并先执行了3而没有执行2，此时因为singleton已经非null。这时候线程B，判断singleton非null并将其返回使用，因为此时Singleton实际上还未初始化，自然就会出错
优点：实现了懒加载，节约了内存空间
饿汉：
public class Singleton2 {

    private static final Singleton2 instance = new Singleton2();

    private Singleton2() {
    }

    public static Singleton2 getInstance() {
        return instance;
    }
}
优点：由于使用了static关键字，保证了在引用这个变量时，关于这个变量的所以写入操作都完成，所以保证了JVM层面的线程安全
缺点：不能实现懒加载，造成空间浪费，如果一个类比较大，我们在初始化的时就加载了这个类，但是我们长时间没有使用这个类，这就导致了内存空间的浪费
静态内部类 延迟加载，线程安全
public class Singleton {  
    private static class SingletonHolder {  
    	private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    	return SingletonHolder.INSTANCE;  
    }  
}
原理：采用的类装载的机制保证初始化实例只有一个线程。
	静态内部类在外部类被装载时并不会立即实例化，而是在需要实例化时，才会实例化。
    类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证线程的安全性，在类进行初始化时，别的线程是无法进入的。

枚举单例：
优点：1.线程安全，只会装载一次 2.不会被序列化 3.不会被反射破坏
public enum World {
    // 唯一枚举:
	INSTANCE;

	private String name = "world";

	public String getName() {
		return this.name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
String name = World.INSTANCE.getName();
破坏单例模式的方法及解决办法
1、除枚举方式外, 其他方法都会通过反射的方式破坏单例,反射是通过调用构造方法生成新的对象，所以如果我们想要阻止单例破坏，可以在构造方法中进行判断，若已有实例, 则阻止生成新的实例，解决办法如下:
private SingletonObject1(){
    if (instance !=null){
        throw new RuntimeException("实例已经存在，请通过 getInstance()方法获取");
    }
}
2、如果单例类实现了序列化接口Serializable, 就可以通过反序列化破坏单例，所以我们可以不实现序列化接口,如果非得实现序列化接口，可以重写反序列化方法readResolve(), 反序列化时直接返回相关单例对象。
public Object readResolve() throws ObjectStreamException {
     return instance;
}
```

> 模版方法模式：定义一套固定步骤，方便直接执行

BaseActivity

> build建造者模式

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

```
class Computer {
    private String cpu;
    private String zhuban;
    public Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.zhuban = builder.zhuban;
    }
    public static class Builder {
        private String cpu;
        private String zhuban;
        public Builder buildCPU(String cpu) {//组装CPU
            this.cpu = cpu;
            return this;
        }
        public Builder buildZhuBan(String zhuban) {
            this.zhuban = zhuban;
            return this;
        }
        public Computer create() {//返回组装好的电脑
            return new Computer(this);
        }
    }
}
```

封装性良好，隐藏内部构建细节。

易于解耦，将产品本身与产品创建过程进行解耦，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。

易于扩展，具体的建造者类之间相互独立，增加新的具体建造者无需修改原有类库的代码。

##android中用到的观察者模式有哪些地方

定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新

eg:ListView/RecyclerView的Adapter的notifyDataSetChanged方法、广播

在setAdapter的时候，生成一个`AdapterDataSetObserver`，紧接着就是订阅上该观察者，该观察者`onChange`方法里面有`requestLayout`方法，该方法是触发UI发生变化的方法。在`BaseAdapter`里面可以看到`notifyDataSetChanged`实际上触发的是`DataSetObservable`被观察者的`notifyChanged`方法，`notifyChanged`会触发`AdapterDataSetObserver`的`onChange`方法。所以最终会走listView的`requestLayout`，最后刷新了UI

```
public interface Observer {//抽象观察者
    public void update();
}
public class MyObserver implements Observer {//具体观察者

    @Override
    public void update() {
        System.out.println("收到消息，进行处理");
    }

}

public interface Subject {//抽象被观察者
    //增加订阅者
    public void attach(Observer observer);
    //删除订阅者
    public void detach(Observer observer);
    //通知订阅者更新消息
    public void notify(String message);
}
public class ConcreteSubject extends Subject {//具体被观察者
	private List<Observer> list = new ArrayList<Observer>();
    
    @Override
    public void attach(Observer observer) {
        list.add(observer);
    }

    @Override
    public void detach(Observer observer) {
        list.remove(observer);
    }

    @Override
    public void notify(String message) {
        for (Observer observer : list) {
            observer.update(message);
        }
    }
}
```



## 动画里面用到了什么设计模式

策略模式：将一系列的算法封装起来，方便替换，实例：动画的插值器

##代理模式与装饰模式的区别，手写一个静态代理，一个动态代理,动态代理有什么用

>代理模式:

静态代理在编译时就已生成，动态代理是在运行时动态生成的


1. 静态代理

这种代理方式需要代理对象和目标对象实现一样的接口。

优点：可以在不修改目标对象的前提下扩展目标对象的功能：

缺点：1.会产生过多的代理类 2.一旦接口增加方法，目标对象和代理对象都要修改

代码：

    //目标对象
    class RealTest implements ITest {
        @Override
        public void doSomthing() {
            System.out.print("原生方法");
        }
    }
    
    interface ITest {
        public void doSomthing();
    }
    //代理对象
    class TestProxy implements ITest {
        private ITest iTest;
    
        public TestProxy(ITest iTest) {
            this.iTest = iTest;
        }
    
        @Override
        public void doSomthing() {
            System.out.println("额外操作");
            iTest.doSomthing();
        }
    }

2.动态代理

动态代理对象不需要实现接口，但是目标对象必须实现接口。其实动态代理与静态代理的本质一样，最终程序运行时都需要生成一个代理对象实例，通过它来完成相关增强以及业务逻辑，只不过静态代理需要硬编码的方式指定，而动态代理则是以动态方式生成代理(编译时操作字节码以及运行时通过反射方式)。动态生成的好处很明显，代理逻辑与业务逻辑是互相独立的，没有耦合，代理1个类100个类没有任何区别

代码：

	//目标对象
	class RealSubject implements ISubject {
	    public void doSomething() {
	        System.out.println("call doSomething()");
	    }
	}
	
	class ProxyFactory{
	    private Object target;
	
	    public ProxyFactory(Object object) {
	        this.target = object;
	    }
	
	    //为目标对象生成代理对象
	    public Object getProxyInstance(){
	        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {
	            @Override
	            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
	                System.out.println("开启事务");
	                Object invoke = method.invoke(target, args);
	                System.out.println("关闭");
	                return invoke;
	            }
	        });
	    }
	}
	
	class TestProxy {
	    public static void main(String args[]) {
	        ISubject target = new RealSubject();
	        ISubject proxyInstance = (ISubject) new ProxyFactory(target).getProxyInstance();
	        proxyInstance.doSomething();
	    }
	}

>代理模式与装饰模式的区别

装饰模式和静态代理代码基本是一样的。

代理模式，侧重于不能直接访问一个对象，只能通过代理来间接访问。装饰器模式是因为没法在编译就确定一个对象的功能，需要运行时动态的给对象添加职责。因为这些功能是由使用者动态配置的。但是代理模式在编译器其实就已经确定了和代理对象的关系。   

这个两个设计模式是为了解决不同的问题而抽象总结出来的。是可以混用的。可以在代理的基础上在加一个装饰，也可以在装饰器的基础上在加一个代理。

# 软引用、弱引用、强引用、虚引用的区别 Ok

* 强引用:直接new出来的对象;强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象

  ```
  String str = new String(“yc”);
  ```

* 软引用 ：如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。

  ```
  MyObject aRef = new  MyObject();
  SoftReference aSoftRef = new SoftReference(aRef);
  MyObject anotherRef = (MyObject)aSoftRef.get();
  ```

  实现内存敏感的缓存：网络图片缓存

* 弱引用：在垃圾回收器扫描的过程中，一旦发现了弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 

  * 防止内存泄漏
  
* 虚引用：虚引用随时都可能被垃圾回收器回收。

> Android中如何查看一个对象的回收情况

Java提供ReferenceQueue来处理引用对象的回收情况。当SoftReference所引用的对象被GC后，JVM会先将softReference对象添加到ReferenceQueue这个队列中。当我们调用ReferenceQueue的poll()方法，如果这个队列中不是空队列，那么将返回并移除前面添加的那个Reference对象。

---

#activity ok

##Activity与AppCompactActivity区别，Activity会打包到包里面去吗？

1. 带有toolbar
2. theme主题只能用android:theme=@style/AppTheme （appTheme主题或者其子类），而不能用android:style。 否则会提示错误
3. factory

会

## Activity从创建到我们看到界面，发生了哪些事

首先是oncreata setContentView加载布局，这其中创建了一个DecorView，然后通过inflate方法加载layoutResID资源文件，解析xml文件，生成View对象；在onResume时创建一个ViewRootImpl，并将DecorView添加到window中，开始绘制流程

> setContentView流程

获取window(window在Activity的attch()里实例化)，调用PhoneWindow的setContentView，使用LayoutInflater，xml实例化view,添加到decorview中

> 为什么不能使用 Application Context 显示 Dialog

错误：BadTokenException

Android 不允许 Activity 以外的 Context 来创建和显示普通的 Dialog

## Activity生命周期

- A启动B的，然后按back键，执行了哪些方法？按home键呢？先执行onPause等第二个页面完全展示再调用stop

> 从ActivityA 启动 ActivityB的生命周期： A.onCreate —> A.onStart —> A.onResume —>A.onPause —>B.onCreate —> B.onStart —> B.onResume—> A.onStop
>
> 按下Back键: B.onPause —>A.onRestart—>A.onStart —> A.onResume -->B.onStop -- >B.onDestroy
>
> 按下Home键: B.onPause -->B.onStop —> OnSaveInstanceState 
>
> 当 B Activity 的 launchMode 为 singleTop 且 B Activity 已经在栈顶时，此时只有 B 页面自己有生命周期变化: B.onPause -> B.onNewIntent -> B.onResume
>
> 当 B Activity 的 launchMode 为 singleInstance ，singleTask 且对应的 B Activity 有可复用的实例时，生命周期回调是这样的: A.onPause -> B.onNewIntent -> B.onRestart -> B.onStart -> B.onResume -> A.onStop -> ( 如果 A 被移出栈的话还有一个 A.onDestory)

- onSaveInstance方法调用时机

> 1、当用户按下HOME键时。 
>
> 2、按任务栏键，选择运行其他的程序时。 
>
> 3、按下电源按键时。 
>
> 4、从activity A中启动一个新的activity时。 
>
> 5、屏幕方向切换时，例如从竖屏切换到横屏时。

当activity有可能被系统回收的情况下或者说在activity被异常终止的情况下会被调用
onPause()->onStop()->onSaveInstanceState()->onDestroy()，然后当Activity被重新创建后执行onCreate()->onStart()->onRestoreInstanceState()->onResume()

onSaveInstanceState保存的是Bundle，Bundle是有类型限制和大小限制的，而且需要在主线程进行序列号。而onRetainNonConfigurationInstance方法都没有限制，所以更倾向于用它

> onNewIntent 何时被执行，启动模式如何处理的？

ActivityStarter 中 deliverNewIntent会调用onNewIntent

> 弹出 Dialog 对生命周期有什么影响

我们知道，生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView() 显示的（没有经过 AMS），所以不会对生命周期有任何影响。

如果是启动一个 Theme 为 Dialog 的 Activity , 则生命周期为： A.onPause -> B.onCrete -> B.onStart -> B.onResume 注意这边没有前一个 Activity 不会回调 onStop，因为只有在 Activity 切到后台不可见才会回调 onStop；而弹出 Dialog 主题的 Activity 时前一个页面还是可见的，只是失去了焦点而已所以仅有 onPause 回调。

> onActivityResult 在哪两个生命周期之间回调

onActivityResult 回调先于该 Activity 的所有生命周期回调，从 B Activity 返回 A Activity 的生命周期调用为： B.onPause -> A.onActivityResult -> A.onRestart -> A.onStart -> A.onResume


## LayoutInflate

> XML解析的三种方式

sax:对文档进行顺序扫描，当扫描到document,element等节点时通知事件处。解析速度快，占用内存少
dom:先将xml都读取到内存，再用DOM API访问树形结构。占用内存大
pull:和sax差不多

> inflate原理

先获取根节点TAG，再递归调用遍历View树，依次反射创建View并添加到父布局中，先搞定内层View，再搞定外层View，最终返回最顶层根布局。
反射创建View：创建对应的Constructor，使用Constructor通过反射创建View对象；如果有Filter拦截处理,对应的View不能被加载成类

创建View的过程中间可以通过Factory/Factory2等进行代理/拦截,如果不做处理,则会使用反射进行创建

> inflate(int resource, ViewGroup root, boolean attachToRoot) 该方法的 attachToRoot 是什么意思?

如果 root 为 null，attachToRoot 将失去作用，设置任何值都没有意义。
如果 root 不为 null，attachToRoot 设为 true，则会给加载的布局文件的指定一个父布局，即 root。
如果 root 不为 null，attachToRoot 设为 false，则会将布局文件最外层的所有 layout 属性进行设置，当该 view 被添加到父 view 当中时，这些 layout 属性会自动生效。
在不设置 attachToRoot 参数的情况下，如果 root 不为 null，attachToRoot 参数默认为 true。
https://www.jiangkang.tech/2021/01/04/android/layoutinflater-yuan-li-fen-xi/

> Factory/Factory2

可以拦截LayoutInflater创建View，对View进行改造。

应用场景包括1）在XML布局中自定义标签名称；2）全局替换系统控件为自定义View； 3）替换app中字体；4）全局换肤等
如果我们设置了LayoutInflater Factory ，在LayoutInflater 的 createViewFromTag 方法中就会通过这个 Factory 的 onCreateView 方法来创建 View。比如你在 XML中 写了一个 TextView标签，然后在 onCreateView 这个回调里 判断如果 name 是 TextView 的话可以变成一个Button

Factory/Factory2区别：

* LayoutInflater.Factory2 是API 11 被加进来的；
* LayoutInflater.Factory2 继承自 LayoutInflater.Factory；
* 可以对创建 View 的 Parent 进行控制；

AppCompatActivity 设置 Factory 是为了将一些 widget 自动变成 兼容widget （例如将 TextView 变成 AppCompatTextView，通过AppCompatDelegate实现兼容）以便于向下兼容新版本中的效果，在高版本中的一些 widget 新特性就是这样在老版本中也能展示的。

## Android的startActivityForResult的实现为什么不使用回调

因为匿名内部类会持有外部类的引用，使用回调时，例如A启动B去获取result，由于某些原因原A已经被销毁了，当B设置结果返回A时，实际上A已经被系统重建，和原先的A不是同一个对象了，所以就不能正确的获取结果

##启动模式 

> Activity一共有以下四种launchMode：

1. standard 标准启动模式

   * 默认的启动模式，每次启动activity都会创建新的实例。
2. singletop 栈顶复用模式 
   * 当栈顶有将要开启的Activity时，会复用这个Activity，同时这个activity的onNewIntent方法会被回调。这个activity的onCreate方法不会被调用。若是栈顶没有，那么就会重新创建
   * 应用场景：适用于接收到消息后显示的界面。例如：QQ接收到消息后会弹出activity，但如果一次来10条消息，总不能一次弹出10个activity。  

3. singetask栈内复用模式，在当前任务栈里面只能有一个实例存在 适合作为程序入口点

   * 当一个启动模式为singleTask的activityA请求启动后，系统会先寻找是否存在A想要的任务栈（在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在），如果不存在，就重新创建一个任务栈，然后创建A的实例并将A放到栈中。如果存在A所需的任务栈，这时要看栈中有是否有要开启的activityA，如果有则直接复用并删除A上面的activity，将A移动到栈顶，同singletop一样，也会回调这个activity的onNewIntent方法。如果没有实例，则创建A实例并压入栈中

   * 现在有两个任务栈，前台任务栈中有BA，后台任务栈中有DC，假设DC启动启动模式都为singleTask。现在请求启动D，那么整个后台任务栈都会被切到前台，这时候前台任务栈为DCBA，当按back键时，前台栈中activity会一一出栈；如果请求启动C，那么情况就不一样了，会把D删除,C切换到前台。（具体看图——singleTask启动模式特例.pptx）
   * 所以这种启动模式通常可以用来退出整个应用程序。将主activity设为singleTask,然后在要退出的activity中转到主Activity，从而将主Activity上的其他activity全部清除，然后在主Activity中的onNewIntent()中加上finish(),将最后一个activity结束。

4. singleInstance 单实例模式

   * activity会开启一个新的任务栈，并且这个任务栈里面只有一个实例存在。
   * 这种启动模式和浏览器的工作原理类似。当多个程序访问浏览器时，如果浏览器没有打开，则打开浏览器，否则会在当前打开的浏览器中访问。举个例子来说，当应用A的任务栈创建了ActivityA实例，并且其启动模式为sinleInstance，如果应用B也要激活ActivityA，则不需要创建，两个应用共享即可。  
   * 如果你要保证一个activity在整个手机操作系统里面只有一个实例存在，使用singleInstance
   * 关于singleInstance这种启动模式还有一点需要特殊说明:如果在一个singleInstance的activityA中通过startActivityForResult()去启动另一个activityB，那么在A中拿不到数据。因为android不允许task间互相传递数据。
   * 以singleInstance模式启动的Activity在整个系统中是单例的，如果再启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。
   * singleInstance模式的Activity开启的其他activity，新Activity会存放到已有的任务栈中(如果没设置新的任务栈的话)。不跟这个在一个

> onNewIntent()

通过这个方法可以取出当前请求的信息
第一次创建Activity A时，执行的逻辑顺序是：
    onCreate() ­­­>onStart()­­­>onResume()
而如果使用singleTask模式第二次启动Activity A，且A处于任务栈的顶端，则执行的逻辑顺序是：
    onNewIntent() ­­­>onRestart> onStart>onResume()。 
注意，getIntent()仍返回原来的意图。你可以使用setIntent来设置新的意图。

> FLAG

* FLAG_ACTIVITY_SINGLE_TOP：与launchMode = "singleTop"行为一致
* FLAG_ACTIVITY_NEW_TASK：如果设置taskAffinity，系统会查找有没有相应的栈存在，如果存在将Activity压入栈中，如果不存在，将Activity压入默认栈中
* FLAG_ACTIVITY_CLEAR_TOP：如果目标存在，直接复用，并清除目标以上的活动，否则重建。 singleTask
* FLAG_ACTIVITY_NO_HISTORY：新开启的Activity不会入栈，只会显示
* FLAG_ACTIVITY_NEW_TASK和FLAG_ACITIVTY_CLEAR_TASK = 清除默认栈里所有的

# Fragment

## Fragment hide show生命周期变化、replace生命周期变化
Fragment调用show和hide时不会调用Fragment相应生命周期方法，而会调用onHiddenChanged，true隐藏，false显示;replace会重新创建：

```
Fragment2 onAttach
Fragment2 onCreate
Fragment1 onPause
Fragment1 onStop
Fragment1 onDestoryView
Fragment1 onDestory
Fragment2 onCreateView
Fragment2 onActivityCreated
Fragment2 onStart
Fragment2 onResume
```

## attach/detach方法

detach ： 分离指定Fragment的UI视图
attach ： 重新关联一个Fragment

当Fragment被detach后，Fragment的生命周期执行完onDestroyView就终止了，这意味着Fragment的实例并没有被销毁，只是UI界面被移除了（注意和remove是有区别的）。
当Fragment被detach后，执行attach操作，会让Fragment从onCreateView开始执行，一直执行到onResume。
attach无法像add一样单独使用，单独使用会抛异常。方法存在的意义是对detach后的Fragment进行界面恢复

add/remove方法：
remove()比detach()要彻底一些, 如果不加入到回退栈中, remove()的时候, fragment的生命周期会一直走到onDetach()；如果加入了回退栈，则会只执行到onDestoryView(),Fragment对象还是存在的。
add一个fragment，如果加到的是同一个id的话，有点像我们的Activity栈，启动多个Activity时候，Activity一个个叠在上面，fragment也是类似，一个个fragment叠在上面



# onCreate,onResume,onStart里面，什么地方可以获得宽高 

如果在`onCreate、onStart、onResume`中直接调用View的`getWidth/getHeight`方法，是无法得到View宽高的正确信息，因为view的measure过程与Activity的生命周期是不同步的，

onCreate创建 DecorView ，onResume添加 DecorView 到 WindowManager，这时候都没有调用View的measure流程，所以视图宽高是获取不到的

有以下三个方法来获取view的宽高：

- view.post()方法

- onWindowFocusChanged() 

  - ```
    当 Activity 获取和失去焦点的时候
    override fun onWindowFocusChanged(hasFocus: Boolean) {  
        super.onWindowFocusChanged(hasFocus)
        if (hasFocus){
            ...
        }
    }
    ```

- OnGlobalLayoutListener

  - ```
    当 View 树发生状态变化时
    view.viewTreeObserver.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener{
        override fun onGlobalLayout() {
            binding.dialog.viewTreeObserver.removeOnGlobalLayoutListener(this)
            ...
        }
    })
    ```

> 为什么获取不到

onCreate-setContentView-中将xml形成的View添加到DecView中

在onResume时 decorView才会被添加在WindowManager内并且执行view的绘制 这就是为什么在onCreate()时获取到view宽高会是0的原因

> View 在什么时间点被测量

WindowManager添加decorView的时候回调ViewRootImpl.setView()，在setView方法中调用requestLayout()发起绘制流程
onResume-添加DecorView 到 WindowManager ,在addView中：
1.初始化 ViewRootImpl
	初始化 AttachInfo
2.root.setView发起绘制并显示到屏幕上

> 为什么view.post可以获得宽高

根据ViewRootImpl是否已经创建，View.post()会执行不同的逻辑。如果 ViewRootImpl 已经创建，即 mAttachInfo 已经初始化，直接通过 Handler 发送消息来执行任务。如果 ViewRootImpl 未创建，即 View 尚未开始绘制，会将任务保存为 HandlerAction，暂存在队列 HandlerActionQueue 中，等到 View 开始绘制，执行 performTraversal() 方法时，在 dispatchAttachedToWindow() 方法中通过 Handler 分发 HandlerActionQueue 中暂存的任务。

View 绘制是发生在一次 Meesage 处理过程中的，View.post() 执行的任务也是发生在一次 Message 处理过程中的，它们一定是有先后顺序的

1:View内部的mAttachInfo 会在View的dispatchAttachedToWindow()方法内赋值,mAttachInfo是在ViewRootImpl的构造器内创建的,所以我们就可以知道当view的attchInfo不为空时 这个view是已经被添加进窗口内的,如果为null就说明view没有在window内。
2: 当ViewRootImpl在Activity的onResume()中被创建时，其实主线程的Handler是在执行处理一个Message的流程中，虽然我们从上面ViewRootImpl内的performTraversals()源码中看到 view缓存的runnable会在performMeasure(), performLayout(),performDraw()这些方法前先被post出去并且添加到MessageQueue链表中，但是这些runnable是属于下一个Message的，而performMeasure(), performLayout(),performDraw()这三个方法是属于本次Message的逻辑,只有本次消息处理完成Handler内部的Looper才会进行下一次消息的处理，最终保证了 View.post()能够正确的拿到View的宽高。

文章：https://juejin.cn/post/6895735092438630407#heading-2 （继续背7）

# 启动流程

## 冷启动与热启动

冷启动：点击桌面图标，手机系统不存在该应用进程，这时系统会重新fork一个子进程来加载Application并启动Activity，这个启动方式就是冷启动。

热启动：系统里已有该应用的进程，所以系统的工作就是将 Activity 带到前台

##说说App的启动过程,在ActivityThread的main方法里面做了什么事，什么时候启动第一个Activity？

https://juejin.cn/post/6844904116561379341#comment

> APP启动流程

1. Launcher进程通过Binder机制发送消息给 system_server 进程。在 system_server 中，会判断要启动 App 的进程是否存在，存在则通知进程启动 Activity，不存在则由AMS通过 socket 通信告知 Zygote 进程 fork 子进程
2. app 进程启动后，首先是实例化 ActivityThread，并执行其main()函数：创建 ApplicationThread，Looper，Handler 对象，并开启主线程消息循环Looper.loop()。
3. ActivityThread的main()调用 attach方法执行AMS #attachApplication()方法，用于初始化Application和Activity。 在system_server进程中，AMS#attachApplication()里依次初始化了Application和Activity，分别有2个关键函数：
   1. bindApplication()方法通知主线程Handler 创建 Application 对象、绑定 Context 、执行 Application#onCreate() 生命周期；
   2. attachApplicationLocked()方法中调用 ActivityThread#ApplicationThread#scheduleLaunchActivity()方法，进而通过主线程Handler消息通知创建 Activity 对象，然后再调用 mInstrumentation#callActivityOnCreate()执行 Activity#onCreate() 生命周期

Instrumentation调用oncreate方法

Attach方法里把ApplicationThread传给AMS，这样AMS就能通过它来调用应用的接口了（Binder通信）

![启动流程.jpg](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg?raw=true)

> AMS 和 APP通信

ApplicationThread实现了Stub,其实就是一个Binder，APP进程创建之后会把自己进程的ApplicationThread的代理端送给AMS服务。AMS服务中保存了所有应用进程的ApplicationThread的代理对象。这样也就可以通信了

![AMS 和 APP 的通信.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/AMS%20%E5%92%8C%20APP%20%E7%9A%84%E9%80%9A%E4%BF%A1.png?raw=true)

> ActivityThread的Main方法做了什么事情

创建 ApplicationThread，Looper，Handler 对象，并开启主线程消息循环Looper.loop()

> ActivityThread和ApplicationThread有什么区别 

ActivityThread负责对Activity创建的管理，而ApplicationThread是个Binder用于APP和服务端进程通信，把AMS的任务交给ActivityThread。

##Zygote进程做了些什么工作？
1.创建服务端Socket，为后续创建进程通信做准备。
2.加载虚拟机。没错，在Zygote进程中，会去加载下层的虚拟机。
3.fork了System Server进程。SystemServer是Zygote fork的第一个进程，负责启动和管理Java Framework层，包括ActivityManagerService，PackageManagerService，WindowManagerService、binder线程池等等。

##Activity启动流程中，大部分都是用Binder通讯，为啥跟Zygote通信的时候要用socket呢

* ServiceManager不能保证在zygote起来的时候已经初始化好，所以无法使用Binder。
* Binder工作依赖于多线程，但是fork的时候是不允许存在多线程的，多线程情况下进程fork容易造成死锁，所以就不用Binder了

##Activity、PhoneWindow、DecorView、ViewRootImpl 的关系

>重要认识 https://www.jianshu.com/p/e0126a4f9874

* ActivityThread

应用启动时会创建一个独立的进程，进程中的主线程会调用ActivityThread的main，也就是ActivityThread的main方法是应用程序的入口

* ActivityStack  TaskRecord  ActivityClientRecord ActivityRecord

ActivityStack持有多个 TaskRecord，控制哪个是前台任务等等。TaskRecord 是我们说的任务栈的概念，栈内有很多 Activity，而ActivityClientRecord，ActivityRecord 是记录 Activity 的结构体。比如Activity的window,配置信息等等,二者有不同,但大体上一样.ActivityClientRecord是在我们应用程序端使用的,ActivityRecord是AMS使用的

* ApplicationThread

ApplicationThread是ActivityThread的私有内部类,实现了Binder和IApplicationThread接口,ApplicationThread具有跨进程通信的能力。在应用启动时会交给AMS，用于AMS和APP通信。AMS通过ApplicationThread实现对Activity,Service等的生命周期的控制.在进程间通信中候AMS是Client,ApplicationThread是Server(实际中AMS持有的是ApplicationThread的代理对象ApplicationThreadProxy)

* ViewRoot

所有View的绘制以及事件分发等交互都是通过它来执行的。
ViewRoot对应ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程(测量，布局，绘制)均通过ViewRoot来完成。
ViewRoot并不属于View树的一份子。从源码实现上来看，它既非View的子类，也非View的父类，但是，它实现了ViewParent接口，这让它可以作为View的名义上的父视图。ViewRootHandler继承了Handler类，可以接收事件并分发，Android的所有触屏事件、按键事件、界面刷新等事件都是通过ViewRootHandler进行分发的。

* Window 

Window是视图的承载器，在Activity中实现的是PhoneWindow，PhoneWindow中有个内部类DecorView，它是 view 的根布局。通过创建DecorView来加载Activity中设置的布局R.layout.activity_main。Window 通过WindowManager将DecorView加载其中，并将DecorView交给ViewRoot，进行视图绘制以及其他交互

* Instrumentation

Instrumentation的主要作用就是监控system对app的调用，ActivityThread通过Instrumentation来创建activity和调用activity的生命周期。

## View的绘制流程、Activity、Window、View的关系

```
class ActivityThread {
  // startActivity最终会调用到这里
  fun handleLaunchActivity(){
	// 1. performLaunchActivity() 创建activity
    // 2. activity.attach() 内部创建了PhoneWindow
    // 3. activity.onCreate() -> setContentView，实际调用window的对应方法，创建DecorView 
  }
  
  fun handleResumeActivity(){
    // 1. activity.onResume()
    // 2. 获取activity的window对象，添加DecorView到WindowManagerGlobal中
    // 3. WindowManagerGlobal.addView(DecorView)时，创建了ViewRootImpl，所有view绘制的工作都是
    //		ViewRootImpl来调度，在这里才建立了ViewRootImpl和View的关联
  }
}

class ViewRoot {
// ViewRoot添加view后，会执行ViewRoot.requestLayout
// scheduleTraversals -> 在消息队列中插入一个同步消息屏障,保证UI优先绘制 
//  -> 通过choreographer提交绘制任务，同时向底层请求sync信号，
//  -> 在下一次信号到来时JNI回调doTraversal，并移除屏障消息
//  -> doTraversal中调用了performMeasure、performLayout和performDraw进行测量、布局和绘制流程
}
```

## AMS交互调用生命周期是顺序的吗

生命周期的一个重要作用就是让activity在不同状态之间切换的时候，可以执行对应的逻辑。举个栗子。我们在界面A使用了相机资源，当我们切换到下个界面B的时候，那么界面A就必须释放相机资源，这样才不会导致界面B无法使用相机；而当我们切回界面A的时候，又希望界面A继续保持拥有相机资源的状态；那么我们就需要在界面不可见的时候释放相机资源，而在界面恢复的时候再次获取相机资源

1、startActivity最终是由startActivityForResult来启动Activity，只不过传递的requestCode小于0。startActivityForResult内部由Instrumentation处理，然后它通过 Binder 向 AMS 发送请求
2、Instrumentation通过ActivityManagerNative(AMS代理)通过Binder机制请求AMS
3、AMS接收到请求之后会执行初始化操作，解析启动模式，保存请求信息等一系列操作。
4、AMS保存完请求信息之后会将当前栈顶的Activity执行onPause操作，并通过Binder机制通知应用程序继续执行当前栈顶的Activity的onPause方法
5、ActivityThread执行完栈顶的Activity的onPause方法之后会通过AMS代理执行进程间通讯告诉AMS，栈顶Actiity已经执行完成onPause方法，继续执行后续操作；
6、AMS会继续执行启动Activity的逻辑，这时候会判断需要启动的Activity所属的应用进程是否已经启动，若没有启动则首先会启动这个Activity的应用程序进程；(假设已经启动)
7、AMS将执行创建Activity的通知告知ActivityThread，然后通过反射机制创建出Activity对象，并执行Activity的onCreate方法，onStart方法，onResume方法
8、ActivityThread执行完成onResume方法之后告知AMS onResume执行完成，开始执行栈顶Activity的onStop方法
9、AMS开始执行栈顶的onStop方法并告知ActivityThread
10、ActivityThread执行真正的onStop方法

* Activity的启动主要是ActivityThread与AMS之间的通讯

* ActivityThread向AMS传递进程间消息通过ActivityManagerNative，AMS向ActivityThread进程间传递消息通过IApplicationThread

* AMS通知ApplicationThread，然后ApplicationThread发送消息通过H(Handler)执行ActivityThread里面的方法

* AMS 不关心 onStart 这个生命周期()

  * ```
    ActivityThread.handleLaunchActivity
        ActivityThread.performLaunchActivity
                Instrumentation.callApplicationOnCreate
                    Application.onCreate
            Instrumentation.callActivityOnCreate
                Activity.performCreate
                    Activity.onCreate
        ActivityThread.handleResumeActivity
            ActivityThread.performResumeActivity
                Activity.performResume
                    Activity.performRestart
                        Instrumentation.callActivityOnRestart
                            Activity.onRestart
    
                        Activity.performStart
                            Instrumentation.callActivityOnStart
                                Activity.onStart
                    Instrumentation.callActivityOnResume
                        Activity.onResume
    ```

* 不要在 onPause 中做耗时的操作，因为后一个 Activity 的启动需要等待前一个 onPause 流程的结束

* AMS 内部维护了一个 ActivityStack 并负责栈内的 Activity 的状态同步，AMS 通过 ActivityThread 去同步 Activity 的状态从而完成生命周期方法的调用

##context创建流程解析

每个activity继承自context，并且对应一个ContextImpl.

1. 应用启动后反射创建Instrumentation->然后通过反射创建Application并且创建ContextImpl实例与Application关联(Instrumentation.newApplication(application, appContext))。使用Application具有context的功能。创建Application时会判断是否创建，没有创建才会创建，保证了唯一
2. 创建完Application后会调用ActivityThread的performLauncherAcitivty方法；也是通过反射创建Activity并且创建ContextImpl与之相互持有(mInstrumentation.newActivity())。同时activity也与mApplication保存全局为一个application对象关联

Activity.attach()：在这个方法中，关联context，创建phonewindow，把applition,token等信息保存为全局变量

> Context数量

Context 数量 = Application 数量 + Activity 数量 + Service 数量
Activity 因为要显示 UI 所以它的 Context 直接继承的是 ContextThemeWrapper；Application 和 Service 的 Context 直接继承的是 ContextWrapper

# Binder机制 ok

Android Binder通信步骤：1.注册服务。2.请求服务。3.传输数据。

> Binder框架

Binder框架 是基于 C/S 架构的。由Client、Server、ServiceManager、Binder驱动组成，其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。如下图所示：

![Binder框架中个组件.jpg](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/Binder%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%B8%AA%E7%BB%84%E4%BB%B6.jpg?raw=true)

Server通过Binder驱动在ServiceManager中注册服务 ,Client通过Bindr驱动查询ServiceManager中注册的服务 ,ServiceManager通过Binder驱动返回Server的代理对象 ,Client拿到Server端的代理对象就可以进行进程间通讯了,Client和Server是开发者自己来实现，Binder驱动和ServiceManager是系统提供的。

在Android中client不是直接去和binder打交道，client是通过managerProxy去和binder进行交互的。同时service也不是直接和binder交互，而是通过stub去和binder交互。

Linux系统将一个进程分为用户空间和内核空间。对于进程之间来说，用户空间的数据不可共享，内核空间的数据可共享，为了保证安全性和独立性，一个进程不能直接操作或者访问另一个进程，即Android的进程是相互独立、隔离的，这就需要跨进程之间的数据通信方式。

> 一次完整的 Binder IPC 通信过程通常是这样：

Binder IPC机制是基于内存映射（mmap）来实现的，传统的进程通信需要两次拷贝，bander只需要一次拷贝。

1. 首先 Binder 驱动在内核空间创建一个数据接收缓存区； 
2. 接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系； 
3. 发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。 如下图：

![Binder通信流程.jpg](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/Binder%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.jpg?raw=true)

##binder是cs架构，Server端的binder都是运行在同一个线程里面么

无论是system server 进程，还是 app 进程，都是在进程 fork 完成后，会启动一个 Binder 线程池，只允许启动一个 Binder 线程池，每个进程的 Binder 线程池的线程个数上限为 15

> bindService 启动 Service 与 Binder 服务实体的流程

1. Activity 调用bindService：通过 Binder 通知 AMS，要启动哪个 Service
2. AMS创建 ServiceRecord，并利用 ApplicationThreadProxy 回调，通知 APP 新建并启动Service启动起来
3. AMS把 Service 启动起来后，继续通过  ApplicationThreadProxy，通知 APP，bindService，其实就是让 Service 返回一个 Binder 对象给  AMS，以便 AMS 传递给 Client
4. AMS把从 Service 处得到这个 Binder 对象传给 Activity，这里是通过 IServiceConnection binder 实现。
5. Activity 被唤醒后通过 Binder Stub 的 asInterface 函数将 Binder 转换为代理 Proxy，完成业务代理的转换，之后就能利用 Proxy 进行通信了

# Service Ok

> 概念

长期运行在后台的任务，Service是在main Thread中执行，Service中不能执行耗时操作

两种启动方式：

1. 通过startService启动后，service会一直无限期运行下去，只有外部调用了stopService()或stopSelf()方法时，该Service才会停止运行并销毁。
2. bind service。

> onStartCommand返回值

Service被系统销毁并再次重建的行为依赖于onStartCommand方法的返回值。返回值有三种值，start_not_sticky、start_sticky和start_redeliver_intent

* start_not_sticky：
  当Service被强制杀掉之后，不会重新创建该Service
* start_sticky：
  当Service被强制杀掉之后，系统会尝试重建该Service，并执行onStartCommand，但是onStartCommand方法的Intent参数为null
* start_redeliver_intent：
  当Service被强制杀掉之后，系统会尝试重建该Service，并执行onStartCommand，但是onStartCommand方法的Intent参数为上次的值  

##intentService

intentService是个抽象类，继承service。特点是可以异步运行一个任务并在结束时自行终止。需要在一个单独的线程中执行的代码可以放在onHandleIntent()中，如从服务器下载数据，当代码执行完毕，线程被终止，服务自行停止。

是通过HandlerThread来实现耗时操作的

> HandlerThread

`HandlerThread`继承Thread，内置了Handler和Looper，在run方法中创建了looper对象，这也是为什么在IntentService中能在HandlerThread中直接用handler的原因。

> 多个Activity共同bind一个service，一个Activity destory，问service的情况

1.startService启动的服务无限期运行，stopService，stopSelf停止
2.bindService启动的服务和Client同生共死，当client销毁的时候，client会自动与Service解除绑定，当然client也可以通过明确调用Context的unbindService方法与Service解除绑定
3.没有任何client与Service绑定的时候，Service会自行销毁
4.client在调用了unbindService方法之后，该client会与Service解除绑定，在与某个client解除绑定之后，Service会检测是否还有其他的client与其连接绑定，如果没有其他任何client与其处于连接状态，那么Service会执行onUnbind方法，然后执行onDestroy方法，最终销毁自己
5.当A绑定后，B再bindService，不会执行其onBind回调方法，而是直接获取上次已经获取到的IBinder实例

# ANR怎么产生?怎么捕捉？

Android系统对于一些事件如果超过预定时间能未能得到有效响应就会造成ANR

一般来说产生ANR的情况有以下三种：

- Activity的input事件在5秒内没有响应输入事件（例如，按键按下，屏幕触摸
- BroadcastReceiver在10秒内没有执行完毕(前台10 后台60)
- Service在特定时间内（20秒内）无法处理完成(前台20 后台200)

通过避免在主线程做太多耗时的操作来优化

> 怎么捕获

当产生ANR的时候系统会生成一个日志文件，日志存放在/data/anr/文件夹下面，一般名称为traces.txt。导出即可查看

> ANR原理

http://gityuan.com/2019/04/06/android-anr/



# 广播与RxBus的区别，全局广播与局部广播区别 Ok

本地广播：广播事件的发送和接收都在本应用，不能跨进程(APP内部进程也不能跨)，只能动态注册，不能静态注册--使用Handler通信机制

全局广播：广播事件的发送和接收都在本应用可以跨应用，全局广播既可以动态注册，也可以静态注册--采用的binder方式实现跨进程间的通信

广播是四大组件之一，可以直接获取上下文，比较消耗资源，Rxbus不能跨进程，耦合性低，比广播更轻量，书写简便。可实现粘性事件

#attachToWindow什么时候调用？ Ok

attachToWindow在onResume之后调用，onDetachFromWindow() 在onDestory之后被调用

```
MainActivity打开
MainActivity: onCreate
MainActivity: onStart
MainActivity: onResume
MainActivity: onAttachedToWindow
MainActivity: onViewAttachedToWindow(界面View设置的监听)
点击home键
MainActivity: onPause
MainActivity: onStop
恢复展示
MainActivity: onRestart
MainActivity: onStart
MainActivity: onResume
关闭
MainActivity: onPause
MainActivity: onStop
MainActivity: onDestroy
MainActivity: onViewDetachedFromWindow
MainActivity: onDetachedFromWindow
```

#事件分发机制 ok

![事件分发机制.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6.png?raw=true)

View事件分发是通过遍历view树，将MotionEvent分发给最终View的过程。流程是从`viewGroup的dispatchTouchEvent`到`viewGroup的onInterceptTouchEvent`再到`View#dispatchTouchEvent`，然后到view的`onTouchEvent`，最后又回到了`Viewgroup#onTouchEvent`

方法解释：

* dispatchTouchEvent：方法返回值为true表示事件被当前视图消费掉；返回为super.dispatchTouchEvent表示继续分发该事件，返回为false表示交给父类的onTouchEvent处理。

* onInterceptTouchEvent：方法返回值为true表示拦截这个事件并交由自身的onTouchEvent方法进行消费；返回false表示不拦截，需要继续传递给子视图的dispatchTouchEvent。如果return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: 　
  * 1.如果该View存在子View且点击到了该子View, 则不拦截, 继续分发给子View 处理, 此时相当于return false。
  * 2.如果该View没有子View或者有子View但是没有点击中子View(此时ViewGroup 相当于普通View), 则交由该View的onTouchEvent响应，此时相当于return true。 

* onTouchEvent：方法返回值为true表示当前视图可以处理对应的事件；返回值为false表示当前视图不处理这个事件，它会被传递给父视图的onTouchEvent方法进行处理。如果return super.onTouchEvent(ev)，事件处理分为两种情况：
  * 1.如果该View是clickable或者longclickable的,则会返回true, 表示消费了该事件, 与返回true一样;
  * 2.如果该View不是clickable或者longclickable的,则会返回false, 表示不消费该事件,将会向上传递,与返回false一样。

注意：在Android系统中，拥有事件传递处理能力的类有以下三种：

- Activity/View：拥有分发和消费两个方法。
- ViewGroup：拥有分发、拦截和消费三个方法。

一些重要的结论：

1、事件传递优先级：onTouchListener.onTouch > onTouchEvent > onClickListener.onClick。

2、正常情况下，一个事件序列只能被一个View拦截且消耗。因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不会再调用这个View的拦截方法去询问它是否要拦截了，而是把剩余的ACTION_MOVE、ACTION_UP等事件直接交给它来处理）。

4、ViewGroup默认不拦截任何事件（返回false）。

5、View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable默认为false。

6、View的enable属性不影响onTouchEvent的默认返回值。

7、通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。

8、requestDisallowInterceptTouchEvent 设置 true就不会走 onInterceptTouchEvent(ev) 方法

9、InputEventReceiver->ViewRoot->DecorView->Activity->phoneWindow->DecorView。为啥一来一回，是为了让Activity去处理一下事件

> 高深:

TouchTarget是对消耗事件的View以链表方式保存，且记录各个View对应的触控点列表，以实现后续的事件派分处理。TouchTarget是一个链表结构，来解决多点触控问题

```
最开始 mFirstouchTarget =null
当手指1按下时候 创建 target1    target1.next=null    mFirstouchTarget = target1
当手指2按下时候，创建 target2    target2.next= target1    mFirstouchTarget = target2
当手指3按下时候，创建 target3    target3.next= target2    mFirstouchTarget = target3
当手指4按下时候，因为没点到任何子view 所以不会创建 target   mFirstouchTarget = target3
mFirstouchTarget =  target3 →target2→target1→null  
```

1. 非多点触控：`mFirstTouchTarget`链表退化成单个`TouchTarget`对象。

2. 多点触控，目标相同：同样为单个`TouchTarget`对象，只是`pointerIdBits`保存了多个`pointerId`信息。

3. 多点触控，目标不同：`mFirstTouchTarget`成为链表。

android事件分发核心是在`viewgroup`的`dispatchTouchEvent`分发`action_down`过程中找到`mFirstTouchTarget`是否为空，如果`mFirstTouchTarget`不为空，那么`action_move`和`action_up`才会往下传递，如果在`action_move`和`action_up`过程中有viewgroup拦截了事件，则此时先向子view的`dispatchTouchEvent`传递一个`action_cancel`，并且将`mFirstTouchTarget`至为null，所以此时`action_move`和`action_up`只会走`viewgroup`的`dispatchTouchEvent`和`onTouchEvent`；如果`mFirstTouchTarget`在`action_down`过程中就已经null的话，则从`action_down`一直向上层view传递，不会有后续的`action_move`和`action_up`了。

高高高：https://www.cnblogs.com/jymblog/p/12178527.html

> ViewGroup在Action_Move时onIntercept返回true，事件怎么传递?

先向子view的`dispatchTouchEvent`传递一个`action_cancel`，并且将`mFirstTouchTarget`至为null，所以此时`action_move`和`action_up`只会走`viewgroup`的`dispatchTouchEvent`和`onTouchEvent`

> 手势操作ActionCancel后怎么取消 

- 一般ACTION_CANCEL和ACTION_UP都作为View一段事件处理的结束。如果在父View中拦截ACTION_UP或ACTION_MOVE，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到ACTION_CANCEL事件。
- 如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现action_cancel。

反射修改cancel字段即可

> 点击事件被拦截，但是想传到下面的View，如何操作？

重写子类的requestDisallowInterceptTouchEvent()方法返回true就不会执行父类的onInterceptTouchEvent()，即可将点击事件传到下面的View。

> 如何解决View的事件冲突？举个开发中遇到的例子？

常见开发中事件冲突的有ScrollView与RecyclerView的滑动冲突、RecyclerView内嵌同时滑动同一方向。

滑动冲突的处理规则：

- 对于由于外部滑动和内部滑动方向不一致导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件。
- 对于由于外部滑动方向和内部滑动方向一致导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件，何时由内部View拦截事件。
- 对于上面两种情况的嵌套，相对复杂，可同样根据需求在业务上找到突破点。

滑动冲突的解决方法：

- 外部拦截法：指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。具体方法：需要重写父容器的onInterceptTouchEvent方法，在内部做出相应的拦截。
- 内部拦截法：指父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法：需要配合requestDisallowInterceptTouchEvent，dispatchTouchEvent方法。

> 实现一个不能滑动的ViewPager

onInterceptTouchEvent()方法和onTouchEvent()方法，只需要将返回值改为false，那么ViewPager就不会消耗掉手指滑动的事件了

##setOnTouchListener,onClickeListener和onTouchEvent的关系 

onTouch在dispatchTouchEvent()方法中调用

    public boolean dispatchTouchEvent(MotionEvent event) {      
    	if (onFilterTouchEventForSecurity(event)) {        
    		if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
                		result = true;        
    		}        
    		if (!result && onTouchEvent(event)) {
    	            result = true;        
    		}   
    	}     
    	return result;
    }

当设置了setOnTouchListener(),li和mOnTouchListener会被初始化，不为null，前两个条件成立，所以当onTouch()方法返回值为true，就不会执行onTouchEvent(event)方法，返回false会执行。

接下来看onTouchEvent的源码

	public boolean onTouchEvent(MotionEvent event) {
	     if (((viewFlags & CLICKABLE)  ==  CLICKABLE  ||(viewFlags & LONG_CLICKABLE)  ==  LONG_CLICKABLE) 
	        || (viewFlags & CONTEXT_CLICKABLE)  ==  CONTEXT_CLICKABLE) {
	           switch (action) {
	               case MotionEvent.ACTION_UP:                           
	                //如果执行了该方法，其返回值就是onTouchEvent()的返回值                
	                performClick();                             
	                break;        
	            }        
	        return true;    
	    }    
	    return false;
	}

在performClick方法中调用了mOnClickListener.onClick(this)方法。只要我们在代码中通过 setOnClickListener() 方法设置了对单击事件的监听，则对应 View 的 onTouchEvent() 方法返回 true，当然事件就此消费，反之返回 false

>总结：

onTouch()方法的返回值决定了onTouchEvent()方法要不要执行，如果onTouch()返回 true，则onTouchEvent()不会再执行，返回false,则 onTouchEvent() 继续执行，而 onClick() 的回调是在 onTouchEvent() 方法中调用，onTouchEvent() 不执行则 onClick() 不执行。

#View绘制流程 ok

View的绘制流程是从ViewRootImpl 的performTraversals开始的，performTraversals会依次调用performMeasure，performLayout，performDraw三个方法，他们会依次调用measure，layout，draw方法，然后又调用了onMeasure，onLayout，dispatchDraw，其中measure确定View的测量宽/高，layout确定View的最终位置，而draw则将View绘制到屏幕上

2. 根视图（DecorView）的宽高一般是屏幕宽高，而ViewGroup的宽高会循环调用它所有子视图的测量 measure()，来决定自己的大小
3. onMeasure：对于自定义的单一view的测量，只需要根据父view传递的MeasureSpec进行计算大小，对于ViewGroup的测量，父容器会对所有的子View进行Measure，根据子 View 确定父 View大小。有两个重要的参数，分别是宽度测量规格和高度测量规格，MeasureSpec 测量规格有三种模式，分别是 AT_MOST、EXACTLY、UNSPECIFIED，主要是**代表父布局对子布局的期望**。
4. onLayout：根据 measure 子 View 所得到的布局大小和布局参数，将子View放在合适的位置上，只有 ViewGroup 需要重写
5. onDraw：传入一个 Canvas，用于绘制View
6. 绘制流程会先发一个同步屏障，再开始绘制流程，保证绘制流程立刻执行

> MeasureSpec

MeasureSpec表示的是一个32位的整形值，它的高2位表示测量模式，低30位表示某种测量模式下的规格大小。MeasureSpec是View的一个静态内部类，用来说明应该如何测量这个View。它由三种测量模式，如下：

- EXACTLY：精确测量模式，view宽高指定为match_parent或具体数值时生效，表示父视图已经决定了子视图的精确大小，这种模式下View的测量值就是SpecSize的值。
- AT_MOST：最大值测量模式，当view的宽高指定为wrap_content时生效，此时子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸。
- UNSPECIFIED：不指定测量模式, 父view没有限制子视图的大小，子视图可以是想要的任何尺寸，通常用于系统内部，应用开发中很少用到。

对于DecorView而言，它的MeasureSpec由窗口尺寸和其自身的LayoutParams共同决定；对于普通的View，它的MeasureSpec由父视图的MeasureSpec和其自身的LayoutParams共同决定。

MeasureSpec和LayoutParams的对应关系：

* 子设置的具体数值，父不管设置啥模式子都是Exactly, 
* 子设置的MatchParant,子跟随父设置的模式

* 子设置的Wrap_content,子模式是AT_MOST，AT_MOST，UNSPECIFIED

**View默认的onMeasure只支持EXACTLY模式，所以如果在自定义控件的时候不重写这个方法的话，也就只能使用EXACTLY模式了，控件可以响应你制定的具体的宽高值或者match_parent属性，如果我们自定义View要让他支持	wrap_content，那就必须重写onMeasure指定wrap_content时的大小**

> 子View大小

ViewGroup-wrap_content然后包裹view-wrap_content,view是全屏大小，ViewGroup若是100dp,子view也是100dp

> 如何求当前Activity View的深度

```
private int getParents(ViewParents view){
    if(view.getParents() == null) 
        return 0;
    } else {
    	return (1 + getParents(view.getParents));
   }
}
```

> 自定义LinearLayout，怎么测量子View宽高

```kotlin
measureChildren(widthMeasureSpec, heightMeasureSpec)
或者for循环 measureChild(child, widthMeasureSpec, heightMeasureSpec)
```

> 如何发起一个View树的测量/布局/绘制流程

* 通过调用**requestLayout/requestFocus**都将发起一个View树的测量。测量完毕后会进行布局，布局完毕后就会绘制。
* **如果View的大小没有发生改变，布局也没有变化，只是显示的内容发生了变化，则可以通过invalidate来请求绘制，此时将不会测量和布局，直接从绘制开始**
* View 和 ViewGroup绘制区别
  * 继承ViewGroup  
    * 只需要覆盖，onMeasure和onLayout 
  * 继承View    
    * 只需要覆盖，onMeasure和onDraw  

getWidth()方法只能控件调用了layout方法后才能获取 getMeasuredWidth()方法只能调用了控件的measure方法后才能获取

requestLayout方法是用来触发绘制流程，他会会一层层调用 parent  的requestLayout，一直到最上层也就是ViewRootImpl的requestLayout，最后会执行到performMeasure -> performLayout -> performDraw 三个绘制流程，也就是测量——布局——绘制。

其中performMeasure方法会执行到View的measure方法，用来测量大小。performLayout方法会执行到view的layout方法，用来计算位置。performDraw方法需要注意下，他会执行到view的draw方法，但是并不一定会进行绘制，只有只有 flag 被设置为 PFLAG_DIRTY_OPAQUE 才会进行绘制。

invalidate方法也是用来触发绘制流程，主要表现就是会调用draw()方法。虽然他也会走到scheduleTraversals方法，也就是会走到三大流程，但是View会通过mPrivateFlags来判断是否进行onMeasure和onLayout操作。而在用invalidate方法时，更新了mPrivateFlags，所以不会进行measure和layout。同时他也会设置Flag为PFLAG_DIRTY_OPAQUE，所以肯定会执行onDraw方法。

虽然两者都是用来触发绘制流程，但是在measure和layout过程中，只会对  flag 设置为 FORCE_LAYOUT 的情况进行重新测量和布局，而draw方法中只会重绘flag为 dirty  的区域。requestLayout 是用来设置FORCE_LAYOUT标志，invalidate 用来设置 dirty 标志。所以  requestLayout 只会触发 measure 和 layout，invalidate 只会触发 draw。

requestlayout会刷新同层布局？

> 自定义实现一个FlexLayout

- onMeasure 在onMeasure里实现对子view的测量，并且根据子view的测量结果决定FlowLayout的大小。
- onLayout 在这里对子view进行布局，决定子view的位置。

思路：当前行剩余空间大于子View占用的大小时，子View往后排布；当前行剩余空间不能够容纳子View时，子View换行。依照该规则进行测量和布局。 

> DecorView

DecorView是最顶层View，是FrameLayout，它有一个子元素LinearLayout。包含标题栏、内容栏都是FrameLayout。内容栏id是content，也就是activity中设置setContentView的部分，最终将布局添加到id为content的FrameLayout中

> fitsSystemWindows

设置了该属性的view的所有padding属性将失效，并且系统会根据情况给该view添加paddingTop和paddingBottom（当设置透明状态栏时，系统会为该view添加一个值等于状态栏高度的paddingTop，当设置了透明导航栏时，系统会为该view添加一个值等于导航栏高度的paddingBottom

#Handler机制  ok

文章：https://juejin.cn/post/6844903810989555726

##简单描述下Handler机制？一个线程有几个Looper？为什么？

Handler机制由MessageQueue，Message，Looper，Handler组成。

- 1、Handler主要作用是发送消息Message到消息队列MessageQueue和处理Loop循环从MessageQueue中获取的Message
- 2、MessageQueue称作消息队列，采用单链表的数据结构存储Message；消息类型有同步消息，异步消息，同步屏障
- 3、Looper是一个死循环，会不断的从MessageQueue提取触发条件的Message，并将Message交给对应的target handler来处理。如果Messagequeue没有消息或者还没有到执行第一条消息的时间，会执行idleHanlder任务，若是idleHandler没有任务就调用Native层的epoll机制进行休眠

一个线程只有1个Looper，是通过ThreadLocal来保证的

> ThreadLocal

ThreadLocal用于保存线程全局变量，当前线程独有，不与其他线程共享

Thread持有ThreadLocalMap，而且ThreadLocalMap里对ThreadLocal的引用还是弱引用，所以只要Thread对象可以被回收，那么ThreadLocalMap就能被回收

> ThreadLocalMap vs WeakHashMap

* 对象持有：两个都是弱引用
* ThreadLocalMap是线程退出时清除，WeakHashMap是GC后移出
* ThreadLocalMap通过开放地址法，WeakHashMap是链表法

##Handler发送消息的 Delay 可靠吗？

答案是不靠谱的，引起不靠谱的原因有如下

* 发送的消息太多,Looper负载越高，任务越容易积压，进而导致卡顿
* 消息队列有一些消息处理非常耗时，导致后面的消息延时处理

> 如何优化保证可靠性

消息精简，从数量上处理

* 重复消息过滤
* 互斥消息取消
* 复用消息

##Handler内存泄漏的GCRoot是什么？

ThreadLocal静态变量作为gcRoot，导致activity无法被回收

handler的内存泄漏原因：

1. 当直接在activity中声明handler时，由于后面的匿名内部类，使handler持有了activity的引用。
2. 当任务未执行完，即message未被执行完时，message持有了messageQueue的引用。
3. messageQueue持有了mLooper的引用。
4. mLooper持有sThreadLocal 的引用。
5. sThreadLocal 是一个静态变量，无法被回收，最终导致了activity无法被回收，造成了内存泄漏。

##Handler休眠是怎样的？epoll的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？

Handler消息机制，在MessageQueue中，调用了native方法实现消息循环的休眠和唤醒（也就是线程的休眠和唤醒）。当遇到延时消息时，会调用nativePollOnce休眠一段时间，时间到了自动唤醒，当新消息来时，会调用nativeWeak()唤醒线程处理消息，然后重新计算休眠消息的时间msg.when - now。

在native层，消息循环的休眠和唤醒使用了Linux内核的epoll机制和pipe

* epoll机制是linux内核实现IO多路复用的一个实现。在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源读写就绪对程序进行读写操作。
  * epoll 相关方法： 
    * epoll_create() ：创建一个epoll对象，并返回一个文件描述符，这个描述符就是epoll实例的句柄
    * epoll_ctl()：向epoll句柄添加或者删除要监听的文件句柄
    * epoll_wait()：阻塞等待注册的事件发生

* pipe是Linux中最基本的一种IPC机制，可以用来实现进程、线程间通信。pipe其本质是一个伪文件，它有两个文件描述符引用，一个表示读端，一个表示写端，规定数据从管道的写端流入管道，从读端流出。

在MessageQueue的构造里调用nativeInit()方法初始化epoll，这个方法内部调用epoll_create()，epoll_ctl()。

epoll机制在Handler中的应用，在主线程的 MessageQueue 没有消息时，便阻塞在 loop 的 queue.next() 中的 nativePollOnce() 方法里，最终调用到epoll_wait()进行阻塞等待。此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。这里采用的 epoll 机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。

https://www.jianshu.com/p/66fa1a8396ad

> 如何实现延时消息，如果移除一个延时消息会解除休眠吗？

发送延时消息，不是延时发送而是延时处理，发送消息后MessageQueue按照Message.when的先后顺序排列，队头的消息是最早触发的消息。处理消息时会调用nativePollOnce(ptr, nextPollTimeoutMillis timeoutMillis = -1表示一直阻塞。如果有delay的消息，则 timeoutMillis表示delay的时间)，这个方法会调用epoll_wait睡眠一段时间，休眠结束后在去处理这个消息。

在Meesage入队的时候，也就是执行`MessageQueue.enqueueMessage()`方法时，`enqueueMessage()`有一个`nativeWeak()`

会

>为什么我们能在主线程直接使用 Handler，而不需要创建 Looper

在ActivityThread.main() 方法中调用了 Looper.prepareMainLooper() 方法创建了 主线程的  Looper ,并且调用了 loop() 方法，所以我们就可以直接使用 Handler 了。

> 主线程的死循环一直运行是不是特别消耗CPU资源呢？

1.死循环是为了让主线程一直存在，进程里至少有一个线程，当主线程死亡，进程也会退出

2.在MessageQueue中无消息，或者等待延迟消息的时候，会调用native层的epoll机制的epoll_wait方法去休眠主线程，此时主线程会释放cpu进入休眠状态，直到有消息来或者延迟时间结束，通过往pipe管道写端写入数据来唤醒主线程工作

这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符读写就绪，则立刻通知相应程序进行读或写操作，本质是同步I/O，即读写是阻塞的。所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。

> Message是根据什么排序的

是根据when字段排序的，when=系统开机时间+delayMillis

插入消息时，根据当前`msg.when`决定插入的位置

> Handler构造中callBack是做啥的

可以起到拦截消息的作用，返回值为 `true` 表示不继续向下分发, 返回 `false` 还会向下分发, 会调用 `Handler.handleMessage()` 方法

>主线程的Looper何时退出

在App退出时，ActivityThread中的mH（Handler）收到消息后，执行退出 主线程looper设置的是不退出，所以只有程序退出时才会退出

> Handler如何保证MessageQueue并发访问安全？

答：循环加锁，配合阻塞唤醒机制。

```
for (;;) {
 ...
 nativePollOnce(ptr, nextPollTimeoutMillis);
 synchronized (this) {
 ...
 }
```

MessageQueue其实是“生产者-消费者”模型，Handler不断地放入消息，Looper不断地取出，这就涉及到死锁问题。如果Looper拿到锁，但是队列中没有消息，就会一直等待，而Handler需要把消息放进去，锁却被Looper拿着无法入队，这就造成了死锁。Handler机制的解决方法是循环加锁,他的等待是在锁外的，当队列中没有消息的时候，他会先释放锁，再进行等待，直到被唤醒。这样就不会造成死锁问题了

##高深

> Looper 是死循环，为什么主线程没有卡死

首先是因为 epoll_wait() 的情况下，主线程只是被挂起，并不耗费 CPU。其次，如果有事件到来，也会通过 epoll 机制唤醒主线程。再其次，binder 线程池的存在使得可以从其所在线程通过 Handler 发送消息到主线程或者其他方式，最终能够唤醒主线程。

> 如何唤醒的呢？

首先需要一个 文件描述符(fd，Linux 一切皆文件) 且支持 poll 操作。之后通过 epoll_ctl() 注册，epoll_wait() 等待事件到来。

Looper 处理 Java 层 enqueueMessage 唤醒时，老版本使用了 pipe，新版本使用了 eventfd

> 事件如何来？

往 fd 里写入数据等等，根据 epoll_ctl 注册的消息类型会进行相应的唤醒。

> nativePollOnce() -> pollOnce() -> pollInner()。但是 pollOnce() 是个死循环，nativePollOnce() 怎么跳出去的？

nativePollOnce会挂起线程，native层调用pollOnce，pollOnce是个死循环，但是pollOnce不会一直跳不出，只要有事件到来，都能跳出死循环。循环中return的值是由pollInner()返回的，pollInner() 才真正调用了 epoll_wait() 使得线程挂起；事件类型：超时\唤醒\错误。当 pollOnce() 和 nativePollOnce() 返回以后，Java 层的 MQ.next() 方法继续执行，才取到了 MQ.java 中的 Message，进行后续的调用。

> Java 层和 Native 层的 MQ、Looper 有什么关系吗？有什么优先级么

Java 层和 Native 层的同样的一套机制可以互相引用，但是，是完全的两套东西，包括 MQ 也是各自管理各自的。但是 Native 的优先级更高，因为处理完了 Native 的事件以后，才开始处理 Java 层的事件。

> 如果主线程处于休眠状态，点击屏幕的时候又是怎么被唤醒的？点击事件是通过什么机制传递过来的？(IMS)

点击屏幕也是个事件(点击屏幕是通过socket通信的，socket也是个事件，会在epoll_ctl中注册)，当有事件需要传递就会唤醒主线程

##如何处理Handler使用不当造成的内存泄漏？

* 有延时消息，在界面关闭后及时移除Message/Runnable，调用handler.removeCallbacksAndMessages(null)

* 内部类导致的内存泄漏改为静态内部类，并对上下文或者Activity/Fragment使用弱引用。

##Handler是怎么切换线程的,Handler同步屏障

> 同步屏障

![同步屏障.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C.png?raw=true)

如上图所示，在消息队列中有同步消息和异步消息（黄色部分）以及一道墙----同步屏障（红色部分）。有了同步屏障的存在，msg_2 和 msg_M 这两个异步消息可以被优先处理，而后面的 msg_3 等同步消息则不会被处理。那么这些同步消息什么时候可以被处理呢？那就需要先移除这个同步屏障，即调用`removeSyncBarrier()`。

Handler中的Message可以分为两类：同步消息，异步消息，一般我们直接发送的消息都是同步消息，只有在msg.setAsynchronous(true)时，发送的消息都会变成异步消息。

一般来说这两种消息没有什么区别，只有在设置了同步屏障时才会出现差异。

可通过mHandler.getLooper().getQueue().postSyncBarrier()设置同步屏障。本质上是发送一个 target 字段为空的 Message到消息队列，设置同步屏障后，loop循环会遍历找到异步消息去处理

Handler设置同步屏障之后，Looper只会获取和处理异步消息，如果没有异步消息会设置nextPollTimeoutMillis赋值为-1，表示无限制的休眠

同步屏障的设置可以方便地处理那些优先级较高的异步消息。当我们调用`Handler.getLooper().getQueue().postSyncBarrier()` 并设置消息的`setAsynchronous(true)`时，target 即为 null ，也就开启了同步屏障。当在消息轮询器 Looper 在`loop()`中循环处理消息时，如若开启了同步屏障，会优先处理其中的异步消息，而阻碍同步消息。

同步屏障只能手动移除
requestLayout/invalidate会发出同步屏障

>Handler线程切换

在A线程正常创建handlerA，然后在B线程中利用handlerA发送消息，此时消息就发送给与handlerA关联的Looper了，而这个Looper唯一关联的线程就是A，这样我们的消息就会在A线程中执行了

> IdleHandler调用时机 IdleHandler应用场景

如果当前MessageQueue中没有Message或者还没有到第一条Message执行的时间，此时MessageQueue会尝试执行IdleHandler的里面的任务

```kotlin
//可以用来获取View的宽高
Looper.myQueue().addIdleHandler {
            Loger.e("--Idle--${mView.width}，${mView.height}----")
            false//返回false的话会从mIdleHandlers集合中删除，反之保留。
 }
```

IdleHandler使用数组保存，如果IdleHandler返回了true则保留在数组中，下次还会执行，如果返回false，会被移除

* 当 mIdleHanders 一直不为空时，为什么不会进入死循环？
  	只有在 pendingIdleHandlerCount 为 -1 时，才会尝试执行 mIdleHander；
    	pendingIdlehanderCount 在 next() 中初始时为 -1，执行一遍后被置为 0，所以不会重复执行；

https://my.oschina.net/u/4308002/blog/4773639

* IdleHandler 的 queueIdle() 运行在那个线程？

  * queueIdle() 运行的线程，只和当前 MessageQueue 的 Looper 所在的线程有关；子线程一样可以构造 Looper，并添加 IdleHandler；

* 系统哪里用了


  ​	ActivityThread.Idler 在 ActivityThread.handleResumeActivity() 中调用

## 为啥会有handler

就是为了切换线程，主要就是为了解决在子线程无法访问UI的问题。

那么为什么系统不允许在子线程中访问UI呢？

​	因为Android的UI控件不是线程安全的，所以采用单线程模型来处理UI操作，通过Handler切换UI访问的线程即可。

那么为什么不给UI控件加锁呢？

​	因为加锁会让UI访问的逻辑变得复杂，而且会降低UI访问的效率，阻塞线程执行。

Handler是怎么获取到当前线程的Looper的

​	ThreadLocal

> Handler缓存池大小

50

# Kotlin ok

##Kotlin对比Java

1. 空安全处理
2. 属性访问,代替Get/Set方法
4. 省略findViewById自动绑定xml文件中控件ID
5. 使用字符串模版简化字符串拼接
6. 扩展功能：为了增强Java中当前类的功能，需要创建一个新类并派生父类；而kotlin只需要使用扩展函数
7. 多了协程
8. 没有三目操作符

## 顶层函数

Kotlin 顶层函数相当于 Java 中的静态函数，往往我们在 Java 中会用到类似 Utils 的类来放置不属于任何类的公共静态函数。

创建一个kt文件，在里面写的函数就是顶层函数，在里面写的属性就是顶层属性

## 函数式编程含义

从函数式编程的角度来说，只关心输入数据和输出数据的关系

在实际使用中，函数式编程最具代表性的就是lambda表达式的使用。lambda本质上就是可以传递给其他函数的一段代码，也就是说，在函数式编程中，函数本身可以作为参数和返回值。

## 函数字面量

函数字面值：一个函数可以当作参数来传递

```
var x : ((Int) ->Boolean)? = null

fun method(a: ((Int) -> Boolean)?) {
    val b = a?.invoke(3)
    println(b)
}

fun method1(requestMethod: suspend () -> Unit,
            errorMethod: (errorCode: String) -> Unit = {}){
    requestMethod
}
```

## let和with的区别

```
1.返回值
	lambda表达式结果-> let\run\with
  	对象->apply\also
2.作用域中对象引用方式
  	it->let\also
  	this->with\run\apply
let->统一判null
run->对象配置并计算结果
with->对象的一组操作
apply->对象配置
also->并且对象还做什么事情
```

##lateinit和by lazy的区别

1. lazy只能用在val类型, lateinit 只能用在var类型
2. lateinit可以初始化多次。而lazy在第一次被调用时就被初始化

> 分号

如果一行中有不止一条语句的时候，必须加上分号

## withContext 切换到指定线程，并在闭包任务结束之后，继续执行下面的代码

##suspend 挂起函数，可在挂起函数中执行子线程操作，挂起函数执行完成后，也会继续执行下面的代码

##kotlin的扩展方法是怎么实现的，inline关键字的作用

扩展函数并没有修改原有的类，而是生成了一个静态的方法,当我们在Kotlin中调用扩展函数时,编译器将会调用自动生成的函数传入对象实例和参数

被inline修饰的函数(内联函数)，在调用时将整个函数体的代码插人调用语句处

> inline  noline  crossinline

inline 关键字的作用，是把 inline 方法以及方法中的 lambda 参数在编译期间复制到调用方，进而减少函数调用以及对象生成。对于有时候我们不想让 inline 关键字对 lambda 参数产生影响，可以使用 noline 关键字。如果想 lambda 也被 inline，但是不影响调用方的控制流程，那么就要是用 crossinline

> 内联函数优缺点

优点：减少函数调用栈，加快运行时间
缺点：内联函数代码如果很多，并过多使用，则会大大增加代码量

## kt的伴生对象是饿汉模式还是懒汉模式

```
//懒汉
class Student private constructor() {
    companion object { //伴生对象
        val instance: Student by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) {
            Student()
        }
    }
}

//饿汉式单例模式实现 对象声明
object Student {
    fun study() {}
}
```

##kotlin与Java互相调用有什么问题？

当Kotlin函数可能被Java调用时， 必须将参数声明为可空类型, 即添加问号后缀

java里面调用Kotlin，如果kotlin参数是非空类型，在Kotlin的代码中假设想要给这个方法传入可空类型，在编译阶段就会报错，在Java代码中去调用kotlin方法如果传入空指针，那么编译阶段并不能发现问题，运行时Java这边就会抛出NullPointerException。

@JvmStatic，kotlin静态方法声明这个时，java可直接调用，否则要加instance调用。
@JvmOverloads主要是Kotlin定义默认参数生成重载方法

@file:JvmName指定Kotlin文件编译之后生成的类名。
java想直接调用kotlin的成员变量@JvmField

##kotlinc与javac编译字节码有什么区别？

kotlinc编译出的class文件变大，Constant pool常量池变大

##kotlin空安全的原理是什么？

变量声明：

跟方法参数基本一致，但是无注解

方法参数：

可空类型添加@Nullable注解，非空类型添加NotNull注解

可空类型会进行判null，不为null才会执行代码，为null啥都不做 ?

非空类型也会进行判null，为null抛出异常，不为null才会执行代码 !!

## FindViewById原理

生成一个HashMap作为成员变量。内部还是调用了findViewById，首先通过findViewById把控件ID作为key和控件View作为value放进 HashMap 中，第二次再使用该控件 ID 的时候，就直接可以从 HashMap 中根据ID获取即可

##你对协程的理解，协程有什么作用？可以完全取代rxjava吗？协程怎么取消？

协程是轻量级的线程。它依赖线程，但是在挂起时不会阻塞线程，一个线程可以创建任意个协程

​	优点是 

​		协程挂起时不需要阻塞线程  

​		比线程更轻量，性能好，切换时自动状态保存

​		不用像线程一样嵌套写法，可以将异步变同步写法

不可以替代，1.操作符没有rxjava丰富2.在java代码中还是得用这个

>协程怎么取消

```kotlin
val startTime = System.currentTimeMillis()
val job = launch(Dispatchers.Default) {
    var nextPrintTime = startTime
    var i = 0
    while (isActive) { // 可以被取消的计算循环
        // 每秒打印消息两次
        if (System.currentTimeMillis() >= nextPrintTime) {
            println("job: I'm sleeping ${i++} ...")
            nextPrintTime += 500L
        }
    }
}
delay(1300L) // 等待一段时间
println("main: I'm tired of waiting!")
job.cancelAndJoin() // 取消该作业并等待它结束
println("main: Now I can quit.")
```

在执行计算任务时需要通过isActive检测取消状态，这样才可以取消

## 协程和线程对比

1. 协程效率比线程高，占用资源少，线程间切换需要开销(需要系统支持)，而协程间切换是由程序自身控制的。 
2. 协程不需要多线程的锁机制。协程是在一个线程内进行切换，所以不存在同时写变量冲突，不需要给共享资源加锁，只需要判断状态。
3. 协程切换可控，线程切换随机
4. 一个线程可以有多个协程

##协程的scope与context

scope是协程的作用域，他的作用是可以统一管理协程，并可以一次性取消所有协程

协程上下文理解起来跟activity上下文概念差不多，协程上下文伴随着协程的生命周期

> +

有时我们需要在协程上下文中定义多个元素。我们可以使用 `+` 操作符来实现。 比如说，我们可以显式指定一个调度器来启动协程并且同时显式指定一个命名：

```
launch(Dispatchers.Default + CoroutineName("test")) {
    println("I'm working in thread ${Thread.currentThread().name}")
}
```

## 调度器 CoroutineDispatcher

```
launch(Dispatchers.Main) { // 在主线程中
launch(Dispatchers.IO) { // 适合IO密集型的任务 DefaultDispatcher-worker线程
launch(Dispatchers.Unconfined) { // 在主线程中
launch(Dispatchers.Default) { // 适合CPU密集型的任务
launch(newSingleThreadContext("MyOwnThread")) { // 开新的线程
```

## 其他

async和launch区别：这两个都可用来启动一个新协程

​	一个并发，一个顺序执行

​	返回值不同，一个返回deferred,一个返回job

> 挂起函数

launch,async或者其他方式创建的协程，在执行到suspend标记的函数的时候，会在当前线程暂停执行，去继续在Dispatchers标记的线程继续执行，执行完成后，协程会重新切回到原来的线程执行。不设置还是在当前线程执行



# 性能优化 ok

## 启动优化

> 计算启动耗时

1. 从Android 4.4开始，Logcat自动帮我们打印出应用的启动时间。这个时间从创建进程开始计算，到完成视图的第一次绘制为止
2. 手动计算
3. ADB命令

3秒多->2秒多

> 分析启动耗时(卡顿定位)

1. 通过traceView
   1. Debug.startMethodTracing("文件名");  Debug.stopMethodTracing();
   2. 将生成的trace用Profiler打开分析
2. 直接通过Profiler分析

x轴为调用的时间线，越宽的表示耗时越久，y轴为调用的深度，也就是调用的子方法。父类在最上面，很明显initBottomTab（）方法调用是最耗时的。

橙色：系统方法
蓝色：第三方API（包括java语言的api）
绿色：App自身方法

> 将冷启动优化分为可控阶段和不可控阶段

* 不可控阶段
  * 点击app到初始化Application之间这段时间，系统接管，从Zygote进程中fork创建新进程等等一系列操作，与优化无关
* 可控阶段
  * 整个冷启动流程中至少有两处onCreate，分别是Application和Activity，整个流程都是可控的。所以这两个地方可以进行优化

> 针对可控阶段的优化方案

1. 将两处onCreate()中的初始化操作异步初始化

2. 在Application的attachBaseContext中将SplashActivity和MainActivity预加载(对象第一次创建的时候，JVM首先检查对应的Class对象是否已经加载。如果没有加载，JVM会根据类名查找.class文件，将其Class对象载入。同一个类第二次new的时候就不需要加载类对象，而是直接实例化，创建时间就缩短了)

3. Splash设置主题背景，解决白屏问题，这一步做了之后，对整体启动时间并没有任何的减少，只是说给用户的体验要友好很多，不再显示一个突兀的白屏

   1. WindowManager会先加载app主题样式中的windowBackground作为app的预览元素，然后再真正去加载activity的layout布局

4. 在MainActivity中将返回键响应修改为响应Home键，使用户按Back键时以为他退出了，以减少下次启动的不必要动作。

   1. ```
      moveTaskToBack(boolean）
      nonRoot=false→ 仅当activity为task根（即首个activity例如启动activity之类的）时才生效
      nonRoot=true→ 忽略上面的限制
      这个方法不会改变task中的activity中的顺序，效果基本等同于home键
      ```

> 自定义启动器

对application的oncreate里面初始化的第三方依赖分成子任务异步初始化，需要解决两个问题：

1. 如果两个子任务之间存在顺序
2. 如果子任务和主线程之间存在顺序

启动器原理

* task 

    首先是将我们的耗时操作均封装成一个task，它有4个方法1个属性
    
    属性1 ：CountDownLatch，该task有几把锁尼，取决于它的依赖的task集合数。
    方法1 ：dependsOn（）返回它所依赖的task集合
    方法2 ：startLock（）开启锁
    方法3 ：unlock（）执行完一个依赖，减少一把锁
    方法4 ：needWait() 是否需要主线程等你执行完再执行

* 启动器（TaskDispatcher）

```
启动器主要是用来分发task的
mCountDownLatch 锁，不同于task里的锁，这个锁是锁主线程的，当主线程调用它时，它会锁定，锁的数量取决于等待集合的数量 

addTask: 将task添加至集合中，并以需要依赖的对象为key，集合为value创建一个Map，这个Map主要是当一个task运行完毕，就可以循环这个Map找到这个运行完毕的task，获取到需要依赖它的对象集合，然后让每一个对象，均减少一把锁。然后调用这个task的needWait()方法，看看是否需要主线程等待它，如果需要，加入等待集合（mNeedWaitTasks）中

startTask：分发task，首先是根据有向无环图的拓扑排序，将task集合重新排序，比如，我们传入的任务是A，B，C，如果A依赖于B，那么就需要先初始化B，同时处理C，然后再处理A。返回就是B、C、A。设置主线程的锁，锁的数量就是等待集合（mNeedWaitTasks）的数量，保证一些要切换页面之前必须要执行完的task均执行完。然后根据所要求的线程进行分发处理。
```

* 执行器（DispatchRunnable）

```
执行器主要就是为了执行task的，它继承了Runnablerun(): 
先等待上层任务执行完，然后再执行自身。当完成一个任务之后，通知所有下层任务，并解锁他们
```

* 线程池

```
这里启动了两个线程池，CPU密集型和IO密集型，CPU密集使用自定义ThreadPoolExecutor，核心线程数=总线程数=Math.max(2, Math.min(CPU_COUNT - 1, 5))，超时5秒，任务队列LinkedBlockingQueue因为占据CPU的时间片过多的话会影响性能，所以这里控制了最大并发，防止主线程的时间片减少；IO密集型使用newCachedThreadPool，有好多任务其实占用的CPU time非常少，所以使用缓存线程池,基本上来着不拒
```

* CountDownLatch 

```
在构造CountDownLatch的时候传入一个整数n，在这个整数“倒数”到0之前，主线程需要等待在门口，而这个“倒数”过程则是由各个执行线程驱动的，每个线程执行完一个任务“倒数”一次。总结来说，CountDownLatch的作用就是等待其他的线程都执行完任务，然后主线程才继续往下执行。
CountDownLatch主要有两个方法：countDown()和await()。

countDown()方法用于使计数器减一，其一般是执行任务的线程调用，await()方法则使调用该方法的线程处于等待状态，其一般是主线程调用。这里需要注意的是，countDown()方法并没有规定一个线程只能调用一次，当同一个线程调用多次countDown()方法时，每次都会使计数器减一；另外，await()方法也并没有规定只能有一个线程执行该方法，如果多个线程同时执行await()方法，那么这几个线程都将处于等待状态，并且以共享模式享有同一个锁

CountDownLatch内部通过AQS实现。在创建CountDownLatch实例时，需要传递一个int型的参数：count，该参数为计数器的初始值，也可以理解为该共享锁可以获取的总次数。

当线程调用await()方法，首先判断count的值是否为0，如果不会0的话则会阻塞当前线程，并让当前线程进入AQS的同步队列中排队一直等待直到为0为止。

当线程调用countDown()方法时，通过自旋+CAS使count值 – 1。然后判断state是否等于0。等于0的时候返回true，就会去唤醒正在同步队列中排队等待的线程，先唤醒排在最前面的那个线程。由于是共享模式，那个线程被唤醒后，检查state=0了，就结束阻塞，并且会通知下一个排队线程，下一个线程醒来后，一样判断state是否等于0了，然后结束阻塞，通知下一个，一直循环下去，直到所有阻塞中的线程全部被唤醒。

当在创建CountDownLatch时初始化的count参数，必须要有count线程调用countDown方法才会使计数器count等于0，锁才会释放，前面等待的线程才会继续运行。注意CountDownLatch不能回滚重置。
```

![启动优化_启动器.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96_%E5%90%AF%E5%8A%A8%E5%99%A8.png?raw=true)

## 包大小优化

APK组成：lib \ res \assets \ META-INF(签名摘要等信息) \ dex \ resources.arsc(编译后的二进制资源文件) \ AndroiManifest.xml

lib,dex,res占用了超90%的空间，这三个是优化的重点

1. 资源优化
   1. 将多套分辨率图片删除，只留一套-xxhdpi，然后对剩余的图片转成webp，这个操作会优化很大空间
   2. 打包前使用Android Lint命令-unuse resource 筛选出无用资源进行删除和扫描图片的MD5值，删除重复资源
   3. 资源混淆优化使用AndResGuard，对资源路径做名字混淆达到减少包体积的效果
   4. 禁用AAPT自动优化png图片，因为这个有可能会使已经优化过的图片变大
   5. 视频资源没有找到好的压缩方法，最后使用微信压缩，10M左右转成几百k
2. dex优化
   1. 使用ProGuard来对代码进行混淆、优化、压缩等工作
   2. 去除重复或者不用的代码，慎用第三方库，选用体积小的第三方SDK
3. lib:只留armv7和armeabi，剩下的删除(v7兼armeabi)
4. 将帧动画转为lottie动画，因为帧动画贼占资源（Lottie 是 Airbnb 开源的一套跨平台的动画效果解决方案,通过AE导出的JSON文件+Lottie库可快速实现复杂的动画）
5. 通过分离应用中比较独立的模块，然后以插件的形式进行加载
6. 随着资源的增加R.class也会变大，代码中访问资源是通过R.xx.xx，而R.xx.xx对应的是.arsc中一个常量值。因此可以通过使用ID替换R.xx.xx，这样R.class文件就没有作用了，然后可以删除。工具（https://github.com/meili/ThinRPlugin）



* 使用AAPT把资源打到APK包里
* resources.arsc文件最好不要压缩存储，如果压缩会影响一定的性能
* usage.txt  列出从APK移除的代码 seeds.txt  列出未进行混淆的类和成员
* `minSdkVersion`高于14（`Android 4.0+`）的话，可以选用WebP格式

```
 // 1、是否进行混淆
 minifyEnabled true
 // 2、开启zipAlign可以让安装包中的资源按4字节对齐，这样可以减少应用在运行时的内存消耗
 zipAlignEnabled true
 // 3、移除无用的resource文件：当ProGuard 把部分无用代码移除的时候，
 // 这些代码所引用的资源也会被标记为无用资源，然后系统通过资源压缩功能将它们移除。
 // 需要注意的是目前资源压缩器目前不会移除values/文件夹中定义的资源（例如字符串、尺寸、样式和颜色）
 shrinkResources true
```

## 内存优化

主要是针对这3个问题优化

1. 内存抖动
   1.  内存波动图形呈 锯齿、GC导致卡顿
2. 内存泄漏：对象被持有导致无法释放或不能按照对象正常的生命周期进行释放
3. 内存溢出

> 内存抖动

当内存频繁分配和回收，导致内存不稳定，就会出现内存抖动，它通常表现为频繁GC、内存曲线呈锯齿状。通常会导致 页面卡顿，甚至造成 OOM

那么，为什么内存抖动会导致 OOM？主要原因有如下两点：频繁创建对象，导致内存不足及碎片（不连续）。不连续的内存片无法被分配，导致OOM。
内存抖动常见案例：着重查看循环或频繁被调用的地方

1. 字符串使用加号拼接
   1. 使用StringBuilder替代。

2. 资源复用
   1. 使用缓存池，重用频繁申请和释放的对象
   2. 注意 结束 使用后，需要 手动释放对象池中的对象。

3. 减少不合理的对象创建
   1. 避免在循环中不断创建局部变量
   2. ondraw、getView 中创建的对象尽量进行复用

4. 使用合理的数据结构
   1. 使用 SparseArray类族、ArrayMap 来替代 HashMap。

> 内存泄露

什么时候会发生内存泄漏

- 单例/静态变量造成的内存泄漏
  - 单例引用activity的context
  - 解决：使用application
- 匿名内部类/非静态内部类
- 资源未关闭造成的内存泄漏
- Handler造成的内存泄漏
- 耗时线程造成的内存泄漏

如何分析解决

https://juejin.cn/post/6844903876043210759#heading-8

使用LeakCanary 文件名称：hprof

1.5.4 不监测 Fragment 的泄露的。而 2.0版本提供了对Android O以及androidx版本中的 Fragment 的内存泄露检测，并且2.0用了kotlin重写，新版本不用手动初始化。

原理： 被GC回收的对象引用，如果设置了引用队列的时候会保存在队列 `queue` 中 

在Application中注册ActivityLifecycleCallbacks监听activity的生命周期，在一个Activity执行完onDestroy()时候，将它放入WeakReference中，然后将这个WeakReference类型的Activity对象与ReferenceQueque关联。这时再从ReferenceQueque中查看是否有该对象，如果没有，执行gc，再次查看，还是没有的话则判断发生内存泄露了。最后用HAHA这个开源库去分析dump之后的heap内存。

为啥还要进行一次gc:

可能存在被观察的引用将要变得弱可达，但是还未入队引用队列的情况。这时候应该主动调用一次 GC，可能可以避免一次额外的 heap dump

> ContentProvider启动时机

Application->attachBaseContext -- ContentProvider->onCreate -- Application->onCreate -- Activity->onCreate

##卡顿优化

> UI线程卡顿检测原理：

UI卡顿的根本原因是UI线程无法在16ms内完成UI绘制

常见造成掉帧的原因又有：

1. 主线程有耗时操作（*合理使用线程来执行耗时任务*）
2. View本身太复杂、嵌套过多导致绘制超过16ms（*优化View的层级、合理使用include、ViewStub标签*）
3. 内存抖动造成频繁GC，例如循环内部创建对象，onDraw中创建对象等。（*优化内存泄漏、对一些需要频繁创建的对象采用对象池技术*）

工具原理：

在loop方法里，每个message处理前后都会调用Logging对象，主线程发生了卡顿，那一定是在dispatchMessage()方法中执行了耗时操作。那么，我们就可以通过这个mLogging对象对dispatchMessage()进行监控。阈值 = 1000

1、首先，我们需要使用getMainLooper().setMessageLogging()去设置我们自己的Printer实现类去打印输出logging。这样，在每个message执行的之前和之后都会调用我们设置的这个Printer实现类。
2、如果我们匹配到"Dispatching to"之后，在子线程去执行一个任务获取当前主线程的堆栈信息以及当前的一些场景信息
3、如果在指定的阈值之内匹配到了"Finished to "，那么说明message就被执行完成了，则表明此时没有产生我们认为的卡顿效果，那我们就可以将这个子线程任务取消掉。

问题：卡顿检测方案获取卡顿时的堆栈信息是最后的时刻，但是实际上发生卡顿的时刻可能是在这段时间区域内另一个耗时过长的函数，那么可能在我们捕获卡顿的时刻时，真正的卡顿时机已经执行完成了，所以在T2时刻捕获到的一个卡顿信息并不能够反映卡顿的现场。解决方法：获取卡顿周期内的多个堆栈

工具：

1.使用严格模式 StrictMode

解决问题记录：

1. 实例对象重复问题
2. UI线程有耗时操作检测
4. List对象和handler对象在当前活动activity最好结束时最好销毁

2.Android Studio Profiler https://www.jianshu.com/p/a3d91986b4c7

## 网络优化

> 1数据缓存

1.1 设置okHttp 缓存

1.2 http缓存

过期时间
在服务端返回的数据中加上一个过期时间，这样我们每次请求的时候判断一下有没有过期，如果没有过期就不需要去重新请求。

增量更新
数据增量更新的具体思路，就是在数据中加上一个版本的概念，每次接收数据都进行版本对比，只接收有变化的数据。
这样传输的数据量就会减少很多，比如省市区和配置等数据比较少更新，如果每次都要请求省市区的数据，这就是在浪费流量。

> 2数据压缩

1. Gzip
对于 Post 请求，Body 是用 Gzip 压缩的，也就是请求的时候带上 Gzip 请求头，服务端返回的时候也加上 Gzip 压缩，这样数据流就是被压缩过的。
2. 压缩请求头
请求头也占用一定的体积，在请求头不变的情况下，我们可以只传递一次，以后都只需要传递上一次请求头的 MD5 值，服务端做一个缓存，在需要请求头中的某些信息时，就可以直接从之前的缓存中取。
3. 合并网络请求
每一个网络请求都会有冗余信息，比如请求头，而合并网络请求就可以减少冗余信息的传递；
4.3 图片压缩
1. 缩略图
图片压缩的第一个手段，就是在列表中优先使用缩略图，因为展示原图会加大内存消耗和流量消耗，而且在列表中直接展示原图没有意义。

> 3 DNS优化

DNS 被劫持的结果就是用户得到的数据并不是我们真实想要提供给用户的数据，如果 DNS 解析慢，那用户等待的请求时间就会变长。
通过使用 HttpDNS，绕过运营商域名解析过程，HttpDNS 不是使用传统的 DNS 协议，向 DNS 服务器的 53 端口发送请求，而是使用 Http 协议，向服务器的 80 端口发送请求。
这样做的好处有两个：

​	防劫持：降低 Local DNS 劫持，绕过运营商域名解析过程；


​	提升速度：降低平均访问时长，因为节省了一次解析过程；

##FPS 检测的原理：
利用了 Android 的屏幕绘制原理
系统每隔 16 ms 就会发送一个 VSync 信号。 如果应用注册了这个 VSync 信号，就会在 VSync  信号到来的时候，收到回调，从而开始准备绘制。如果准备顺利，也就是 CPU 准备数据、GPU 栅格化等，如果这些任务在 16 ms 之内完成，那么下一个 VSync 信号到来前就可以绘制这一帧界面了。就没有掉帧，界面很流畅。如果在 16 ms 内没准备好，可能就需要更多的时间这个画面才能显示出来，在这种情况下就发生了丢帧，如果丢帧很多就卡顿了。
检测 FPS 的原理其实挺简单的，就是通过一段时间内，比如 1s，统计绘制了多少个画面，就可以计算出 FPS 了。那如何知道应用 1s 内绘制了多少个界面呢？这个就要靠 VSync 信号监听了。 

https://www.cnblogs.com/dasusu/p/8311324.html

## 稳定性优化

应用的稳定性可以分为三个纬度，如下所示：

1、Crash纬度
2、性能纬度：启动速度、内存、绘制等等优化方向，相对于Crash来说是次要的，在做应用性能体系化建设之前，我们必须要确保应用的功能稳定可用。
3、业务高可用纬度：它是非常关键的一步，我们需要采用多种手段来保证我们App的主流程以及核心路径的稳定性，只有用户经常使用我们的App，它才有可能发现别的方面的问题

# 图片相关 ok

## Bitmap内存大小，注意事项，如何优化

```
ALPHA_8   每个像素占用1byte内存        
ARGB_4444 每个像素占用2byte内存       
ARGB_8888 每个像素占用4byte内存（默认）      
RGB_565 每个像素占用2byte内存
```

内存大小 = 宽度像素 x 高度像素 x 单个像素内存大小

> 大图加载：

使用采样压缩：通过设置BitmapFactory.Options中inSampleSize

```
BitmapFactory.Options bmOptions = new BitmapFactory.Options();
// 值设为true那么将不返回实际的bitmap，也不给其分配内存空间这样就避免内存溢出了。但是允许我们查询图片的信息这其中就包括图片大小信息
bmOptions.inJustDecodeBounds = true;
BitmapFactory.decodeFile(filePath, bmOptions);
int photoW = bmOptions.outWidth;
int photoH = bmOptions.outHeight;
// 调用上面定义的方法计算inSampleSize值
options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);
// 使用获取到的inSampleSize值再次解析图片
options.inJustDecodeBounds = false;
Bitmap b = BitmapFactory.decodeFile(fileName, options);
```

inSampleSize比率：计算出实际宽高和目标宽高的比率，选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高

>Bitmap内存复用

利用inBitmap，使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。

使用inBitmap需要注意几个限制条件：

(1).在SDK 11 -> 18之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19(4.4)开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小

(2).inMutable = true  旧Bitmap必须是mutable的

> Bitmap优化

1. 当我们需要获取图片的宽高等属性时且不对数据进行操作，那么我们不应该把图片的数据加载到内存中，这时我们可以设置inJustDecodeBounds属性为true.

2. ###### 减小Bitmap对象的内存占用

   1. inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。(尺寸压缩)
   2. decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异 (质量压缩)

3. ###### LRU管理Bitmap：使用Lru来管理Bitmap,设置最大内存，可以防止出现内存溢出

5. ###### Bitmap对象的复用：inBitmap (内存复用)

Bitmap数据和引用都放在了堆中，这样就不需要recycle了，而是整个Bitmap的回收交给GC了。并且系统也不建议调用。只需要将引用置为null

> 三级缓存原理

先去内存中找，有直接加载，没有去本地存储找，有给内存存一份并加载，没有去网络请求，请求下来的给本地和内存存一份，并加载

> xhdpi的图片放到xxhdp的手机上，内存会如何变化

内存占用会变小

MDPI：HDPI:XHDPI:XXHDPI:XXXHDPI = 1:1.5:2:3:4

当图片放在与手机屏幕 ppi对应drawable 目录下，图片就能以自己实际的宽高加载进内存。否则就要按比例进行缩放宽高加载进内存。

与手机屏幕dpi一致的文件夹称之为目标文件夹，此时会以图片的原尺寸加载进内存，当把xxdpi图片放到hdpi时，还要展示在手机上，就需要将图片缩放3/1.5(xxdpi:hdpi = 3:1.5)

当图片放置的文件夹<目标文件夹时，图片占用内存变小，当图片放置的文件夹>目标文件夹时，图片占用内存变大

> 两个getDrawable取得的对象，有什么区别

资源id相同的图片使用了同一个位图信息，所以虽然是两个Drawable对象，但是操作的是位图信息，所以没有区别

通过mutate\newDrawable来解决

> Bitmap Drawable View 三者关系

bitmap：位图，可以理解为一张图片在内存中的映射

view：展示的UI

drawable：和bitmap没有关系, 可以理解为一个绘制工具，是一个可以调用Canvas来进行绘制的上层工具。Drawable.draw(canvas)可以将Drawable设置的绘制内容绘制到Canvas中。drawable 仅仅能绘制，但是不能测量自己的大小，但是view可以。

> drawable优点：

1.使用简单，比自定义View的成本低
2.非图片类的Drawable所占用空间小，能减小apk大小

> drawable子类：

BitmapDrawable：表示一张图片。可以直接引用原始图片或者通过XML进行描述
ShapeDrawable：通过颜色构建的图形

#屏幕适配做过什么工作 OK

> 基本概念

- 像素（px）：像素就是手机屏幕的最小构成单元，px = 1像素点 一般情况下UI设计师的设计图会以px作为统一的计量单位。
- 分辨率：手机在横向、纵向上的像素点数总和 一般描述成 宽*高 ，即横向像素点个数 * 纵向像素点个数（如1080 x 1920），单位：px。
- 屏幕尺寸：手机对角线的物理尺寸。单位 英寸（inch），一英寸大约2.54cm 常见的尺寸有4.7寸、5寸、5.5寸、6寸。
- 屏幕像素密度（dpi）：每英寸的像素点数，例如每英寸内有160个像素点，则其像素密度为160dpi，单位：dpi（dots per inch）。
- 密度无关像素（dp）：与终端上的实际物理像素点无关，可以保证在不同屏幕像素密度的设备上显示相同的效果，是安卓特有的长度单位，dp与px的转换：1dp = （dpi / 160 ） * 1px。
- 独立比例像素（sp）：字体大小专用单位 Android开发时用此单位设置文字大小，推荐使用12sp、14sp、18sp、22sp作为字体大小。

> 适配方案

1. 宽高限定适配：穷举市面上所有的Android手机的宽高像素值：设定一个基准的分辨率，其他分辨率都根据这个基准分辨率来计算，根据该尺寸编写对应的dimens文件，这个时候，如果我们的UI设计使用的就是基准分辨率,当APP运行在不同分辨率的手机中时，这些系统会根据这些dimens引用去该分辨率的文件夹下面寻找对应的值。

   1. 无法做到向下兼容去使用更小的dimens，只能使用默认的dimens,容错机制差

   2. res文件增大

   3. 比如以480x320为基准分辨率

      * 宽度为320，将任何分辨率的宽度整分为320份，取值为x1-x320

      - 高度为480，将任何分辨率的高度整分为480份，取值为y1-y480

      * 那么对于800*480的分辨率的dimens文件来说，

      * x1=(480/320)*1=1.5px

      * x2=(480/320)*2=3px

2. 最小宽度限定符适配方案：系统会识别设备屏幕的最小宽度并根据识别到的结果去资源文件中寻找对应限定符的文件夹下的资源文件，解决了向下兼容问题

   1. 最小宽度是宽高限定的升级版，最小宽度只是把dimens.xml文件中的值从px换成了dp，原理和使用方式都是没变的。开发者先根据设计图最小宽度生成一系列dimens文件夹，当把项目运行到设备上时，系统会根据当前设备屏幕的最小宽度去匹配对应的dimen文件夹。

   2. 举个例子，小米5的dpi是480,横向像素是1080px，根据px=dp(dpi/160)，横向的dp值是1080/(480/160),也就是360dp,系统就会去寻找是否存在value-sw360dp的文件夹以及对应的资源文件。

   3. smallestWidth限定符适配和宽高限定符适配最大的区别在于，前者有很好的容错机制，如果没有value-sw360dp文件夹，系统会向下寻找，比如离360dp最近的只有value-sw350dp，那么Android就会选择value-sw350dp文件夹下面的资源文件。

   4. 优点：稳定，对app没有性能损耗，适配范围可控，不会影响其他三方库

      缺点：dimens维护成本较高；方案侵入性大。适配方案切换起来非常麻烦；导致app体积增大

3. 今日头条方案：修改density值，强行把所有不同尺寸分辨率的手机的宽度dp值改成一个统一的值，这样就解决了所有的适配问题。

   1. 比如，设计稿宽度是360px，那么开发这边就会把目标dp值设为360dp，在不同的设备中，动态修改density值，从而保证(手机像素宽度)px/density这个值始终是360dp,这样的话，就能保证UI在不同的设备上表现一致了。

#说说MVP和MVVM的特点 ok

MVC:

- 视图层(View) 对应于xml布局文件和java代码动态view部分
- 控制层(Controller) 业务逻辑。
- 模型层(Model) 存取管理数据，它主要负责网络请求，数据库处理，I/O的操作。

MVC 的问题点 如下：

​	MVC中Android的控制层是由Activity来承担的，Activity本来主要是作为初始化页面，展示数据的操作，但是因为XML视图功能太弱，所以Activity既要负责视图的显示又要加入控制逻辑，承担的功能过多。

​	Activity/Fragment 责任不明，同时负责View、Controller，就会导致其中代码量大，不满足单一职责

MVP:

- Model，模型层，即数据模型，用于获取和存储数据。
- View，视图层，即Activity/Fragment
- Presenter，控制层，负责业务逻辑。

MVP框架由3部分组成：View负责显示，Presenter中间层负责逻辑处理，Model提供数据。分离了M层和V层的代码，通过P层来建立他们的关联，实现M层和V层的解耦。缺点就是每增加一个功能，需要增加相应的接口回调。MVP的核心就是通过接口实现隔离，将相关的业务层交给了P层。

MVP解决了MVC的问题：1.View责任明确，逻辑不再写在Activity中，而是在Presenter中；2.Model不再持有View。

MVP的实现思路：

- UI逻辑抽象成IView接口，由具体的Activity实现类来完成。且调用Presenter进行逻辑操作。
- 业务逻辑抽象成IPresenter接口，由具体的Presenter实现类来完成。逻辑操作完成后调用IView接口方法刷新UI。

MVP 本质是面向接口编程。MVP解决了View层责任不明的问题，但并没有解决代码耦合的问题，View和Presenter之间相互持有。

所以MVP有问题点如下：

1. 会引入大量的IView、IPresenter接口，增加实现的复杂度。
2. View和Presenter相互持有，形成耦合。

MVVM:

MVVM架构通过ViewModel隔离了UI层和数据层，降低程序的耦合度。通过双向绑定的机制，实现数据和UI内容，只要想改其中一方，另一方都能够及时更新的一种设计理念，这样就省去了很多在View层中写很多case的情况，只需要改变数据就行。

Mvvm加强了对生命周期的处理，不用像mvp一样在ondestory的时候手动处理内存泄漏

MVVM解决的问题：

​	接口；内存泄露(生命周期)

## MVP怎么处理内存泄漏

在Activity或者Fragment关闭的时候将Presenter对View的引用释放

```java
public void detachView() {//解除关联
    if (mViewRef != null) {
        mViewRef.clear();
        mViewRef = null;
    }
}
```

## 架构设计的目的

通过设计使程序模块化，做到模块内部的高聚合和模块之间的低耦合。这样做的好处是使得程序在开发的过程中，开发人员只需要专注于一点，提高程序开发的效率，并且更容易进行后续的测试以及定位问题。但设计不能违背目的，对于不同量级的工程，具体架构的实现方式必然是不同的，切忌犯为了设计而设计，为了架构而架构的毛病

# JetPack组件

## 用过的组件有哪些

Data Binding\Lifecycles\LiveData\Navigation\Room\ViewModel

##ViewModel 用来管理数据

ViewModel 以注重生命周期的方式存储和管理界面相关的数据。在发生屏幕旋转等配置更改后数据继续留存

https://juejin.cn/post/6844904079265644551#comment

> ViewModel为什么在旋转屏幕后不会丢失状态

在Activity中提供了 onRetainNonConfigurationInstance 方法，用于处理配置发生改变时数据的保存。随后在重新创建的 Activity 中调用 getLastNonConfigurationInstance 获取上次保存的数据

onRetainNonConfigurationInstance 方法系统调用时机介于 onStop - onDestory 之间，getLastNonConfigurationInstance 方法可在 onCreate 与 onStart 方法中调用
在Activity 的最新代码中，官方重写了 onRetainNonConfigurationInstance 方法，在该方法中保存了 ViewModelStore (ViweModelStore 中存储了 ViewModel )，进而也保存了 ViewModel
当新的 Activity 重新创建，并调用 ViewModelProvider(this).get(MyViewModel.class) 时，又会在 getViewModelStore() 方法中获取老 Activity 保存的 ViewModelStore。那么也就拿到了 ViewModel。

onSaveInstanceState保存的是Bundle，Bundle是有类型限制和大小限制的，而且需要在主线程进行序列号。而onRetainNonConfigurationInstance方法都没有限制，所以更倾向于用它

> ViewModel 何时判断是否被移除 = viewModel怎么实现自动处理生命周期

ViewModel 最重要的特性就是不会在配置发生改变的时候被移除。监听 Activity 声明周期，在 onDestory 方法被调用时，判断配置是否改变。如果没有发送改变，则调用 Activity 中的 ViewModelStore 的 clear() 方法，清除所有的 ViewModel

> ViewModel在Activity初始化

vm与Activity绑定过程：ViewModelProvider(this).get(MyViewModel.class)：get方法：判断传入的ViewModel在ViewModelStore是否存在，不存在，通过Factory创建ViewModel，然后put到ViewModelStore中。ViewModelStore里有HashMap,保存Activity和ViewModel的关系

> viewModel是怎么实现双向数据绑定的

通过DataBinding

> VM解决了什么问题

1. 不会因为屏幕旋转而销毁，减少了维护状态的工作 
2. 由于在作用域内单一实例的特性，使得多个fragment之间可以方便通信，并且维护同一个数据状态。
3. 完善了MVVM架构，使得解耦更加纯粹

##LiveData

是一种可观察的数据存储器类。LiveData 具有生命周期感知能力，这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。LiveData 分为可变值的MutableLiveData和不可变值的LiveData

- 不会发生内存泄漏，observer会在LifecycleOwner状态变为DESTROYED后自动remove。
- 不会因 Activity 停止而导致崩溃，如果LifecycleOwner生命周期处于非活跃状态，则它不会接收任何 LiveData事件。
- 不需要手动解除观察，开发者不需要在onPause或onDestroy方法中解除对LiveData的观察，因为LiveData能感知生命周期状态变化，所以会自动管理所有这些操作。

> LiveData数据倒灌

现象：多个Fragment共享一个ViewModel中设置了一个LiveData，FragmentA observe到这个LiveData的一次通知，关闭 FragmentA 后，再进入 FragmentA，由于 该 ViewModel 是共享的，其中的 LiveData 并没有随着 FragmentA 的退出而清除，那么再次进入后，会自动走一遍 observe 回调，倒灌旧数据。

为啥会造成数据倒灌的问题？

对于LiveData，其初始的version是-1，当我们调用了其setValue或者postValue后，其version会+1；对于每一个新注册的观察者（ObserverWrapper），其mLastVersion为-1；当LiveData设置这个ObserverWrapper的时候，如果LiveData的version大于ObserverWrapper的mLastVersion，LiveData就会强制把当前value推送给Observer。

当fragment再次进入，会重新绑定观察者，会触发数据分发函数，在分发中会判断mLastVersion是否小于mVersion，若是小于则会分发，而每个新的订阅者其version都是-1，LiveData一旦设置过其version是大于-1的（每次LiveData设置值都会使其version加1），这样就会导致LiveData每注册一个新的订阅者，这个订阅者就会立刻收到一个回调，即使这个设置的动作发生在订阅之前

设计理由：为了处理生命周期从 unActive 到 active 转变时，跟进“最新” 的状态

解决：通过反射修改livedata源码observer.mLastVersion的值，使得if (observer.mLastVersion >= mVersion)成立，就不会导致没有注册观察者，还能接收到消息。

> Livedata解决了什么问题

LiveData作为一种观察者模式设计思想，常常被和Rxjava一起比较，观察者模式的最大好处就是事件发射的上游 和 接收事件的下游 互不干涉，大幅降低了互相持有的依赖关系所带来的强耦合性。其次，LiveData还能无缝衔接到MVVM架构中，主要体现在其可以感知到Activity等生命周期，这样就带来了很多好处：

- 不会发生内存泄漏：观察者会绑定到 Lifecycle对象，并在其关联的生命周期遭到销毁后进行自我清理。
- 不会因 Activity 停止而导致崩溃：如果观察者的生命周期处于非活跃状态（如返回栈中的 Activity），则它不会接收任何 LiveData 事件。
- 数据变化时自动判断生命周期并回调方法：如果观察者的生命周期处于 STARTED 或 RESUMED状态，则 LiveData 会认为该观察者处于活跃状态，就会调用onActive方法，否则，如果 LiveData 对象没有任何活跃观察者时，会调用 onInactive()方法

## Lifecycle 

用来监听Activity与Fragment的生命周期变化
LifeCycleOwner 生命周期拥有者，即Activity与Fragment
LifeCycleObserver 生命周期观察者，可以是任何类

> lifeCycle的原理是什么？如果在onStart里面订阅，会回调onCreate吗

会

http://liuwangshu.cn/application/jetpack/3-lifecycle-theory.html

创建一个不可见的ReportFragment添加到Activity，在Fragment生命周期改变时，通过反射对实现了LifecycleObserver的对应方法进行调用。

##DataBinding 

优点

* 不用再 findViewById 了(当然kotlin也可以不用喽)
* 减少了 Avtivity和Fragment的逻辑处理，使Activity 和Fragment逻辑更加清晰，容易维护
* 双向绑定，当View改变的时候会通知Model，当Model改变的时候会通知View

缺点

* 很难定位bug，当有个界面展示不对的时候，你不知道是View的问题，还是Model的问题，还是编写逻辑的问题，
* xml中 不能Debug
* 双向绑定技术，不利于View的复用，因为一个xml 里面绑定的一个Model，有可能另一个界面Model就不一样了，所以无法复用了。除非你再手动转一下这个Model

# RecyclerView ok

> ListView缓存

ListView的缓存有两级，在ListView里面有一个内部类 RecycleBin，RecycleBin有两个对象Active View和Scrap View来管理缓存，Active View是第一级，Scrap View是第二级。

* Active View：是缓存在屏幕内的ItemView，当列表数据发生变化时，屏幕内的数据可以直接拿来复用，无须进行数据绑定。
* Scrap view：缓存屏幕外的ItemView，屏幕外的所有数据在进入屏幕的时候都要走一遍getView（）方法。

**Listview缓存的是ItemView，Recyclerview缓存的是ViewHolder**

> Recyclerview缓存

https://juejin.cn/post/6844904146684870669#heading-3  https://www.jianshu.com/p/3e9aa4bdaefd

Recycleview有四级缓存，分别是`mAttachedScrap(屏幕内)，mCacheViews(屏幕外)，mViewCacheExtension(自定义缓存)，mRecyclerPool(缓存池)`

- AttachedScrap(屏幕内)：用于屏幕内ViewHolder快速重用
  - 数据结构是ArrayList，在LayoutManager#onLayoutChildren方法中，对views进行布局时，会将RecyclerView上的Views全部缓存到该集合中，以备后续使用，该缓存中的ViewHolder的特性是，如果和RV上的position或者itemId匹配上了，那么认为是干净的ViewHolder，是可以直接拿出来使用的，无需调用onBindViewHolder方法。该ArrayList的大小是没有限制的，屏幕上有多少个View，就会创建多大的集合。触发该层级缓存的场景一般是调用notifyItemXXX方法。调用notifyDataSetChanged方法，只有当Adapter hasStableIds返回true，会触发该层级的缓存使用
    - 调用notifyItemRemoved、notifyItemMoved、notifyItemInserted方法，ViewHolder放入mAttachedScrap中
    - 调用notifyItemChanged(int position, Object payload)，如果payload!=null ViewHolder放入mAttachedScrap中,否则ViewHolder放入mChangedScrap中
    - 调用notifyDataSetChanged()时，如果Adapter.hasStableIds返回true，ViewHolder放入mAttachedScrap中，否则会将ViewHolder回收到非scrap缓存中
  - mChangedScrap：mChangedScrap和mAttachedScrap是同一级的缓存。只有调用了notifyItemChanged和notifyItemRangeChanged，并且 ItemAnimator 调用 ViewHolder#canReuseUpdatedViewHolder 方法时，返回了 false，才会放入到mChangedScrap中。mChangedScrap缓存中的ViewHolder是需要调用onBindViewHolder方法重新绑定数据的。
- CacheViews(屏幕外)：刚移出屏幕的缓存数据，默认大小是2个，当其容量被充满同时又有新的数据添加的时候，会根据FIFO原则，把优先进入的缓存数据移出并放到缓存池中，然后再把新的数据添加进来。Cache里面的数据是干净的，也就是携带了原来的ViewHolder的所有数据信息，数据可以直接来拿来复用。需要注意的是，cache是根据position来寻找数据的，这个postion是根据第一个或者最后一个可见的item的position以及用户操作行为（上拉还是下拉）。
  - 举个栗子：当前屏幕内第一个可见的item的position是1，用户进行了一个下拉操作，那么当前预测的position就相当于（1-1=0），也就是position=0的那个item要被拉回到屏幕，此时RecyclerView就从Cache里面找position=0的数据，如果找到了就直接拿来复用。
  - 是ArrayList，通过setItemViewCacheSize设置缓存大小
  - 该层级缓存触发的一个常见的场景是滑动RV。该缓存和mAttachedScrap一样特别高效
- 自定义缓存：开发者自定义缓存。该接口只提供了get方法，没提供put方法
- RecyclerPool：刚才说了Cache默认的缓存数量是2个，当Cache缓存满了以后会根据FIFO（先进先出）的规则把Cache先缓存进去的ViewHolder移出并缓存到RecycledViewPool中，RecycledViewPool默认的缓存数量是5个。RecycledViewPool与Cache相比不同的是，从Cache里面移出的ViewHolder再存入RecycledViewPool之前ViewHolder的数据会被全部重置，相当于一个新的ViewHolder，而且Cache是根据position来获取ViewHolder，而RecycledViewPool是根据itemType获取的，如果没有重写getItemType（）方法，itemType就是默认的。因为RecycledViewPool缓存的ViewHolder是全新的，所以取出来的时候需要走onBindViewHolder（）方法
  - 对应的数据结构是SparseArray<ScrapData>，根据itemType将缓存分组，组的数据结构是ScrapData
  - ScrapData对应的数据结构是ArrayList<ViewHolder>，每个itemType对应的ScrapData的缓存大小默认值是5，可以修改缓存大小

四级缓存按照顺序需要依次读取。所以完整缓存流程是：

1. 保存缓存流程：
   1. 插入或是删除`itemView`时，先把屏幕内的ViewHolder保存至`AttachedScrap`中
   2. 滑动屏幕的时候，先消失的itemview会保存到`CacheView`，CacheView大小默认是2，超过数量的话按照先入先出原则，移出头部的itemview保存到`RecyclerPool缓存池`（如果有自定义缓存就会保存到自定义缓存里），RecyclerPool缓存池会按照itemview的`itemtype`进行保存，每个itemTyep缓存个数为5个，超过就会被回收。

2. 获取缓存流程：
   1. AttachedScrap中获取，通过pos匹配holder——>获取失败，从`CacheView`中获取，也是通过pos获取holder缓存——>获取失败，从`自定义缓存`中获取缓存——>获取失败，从`mRecyclerPool`中获取 ——>获取失败，重新创建`viewholder`——createViewHolder并bindview。
   2. 需要注意的是，如果从缓存池找到缓存，还需要重新bindview。

> 滑动10个，再滑回去，会有几个执行onBindView？

- 如果一开始滑动的是新数据，那么滑动10个，就会走10个bindview方法。然后滑回去，会走10-2个bindview方法。一共18次调用。
- 如果一开始滑动的是老数据，那么滑动10-2个，就会走8个bindview方法。然后滑回去，会走10-2个bindview方法。一共16次调用。

> 有了cache为啥还要有scrap，这两个不可以合成一个吗

1.刷新的实时度不一样

​	因为屏幕是每16ms绘制一次

2.缓存变大

> Recyclerview预取

在滑动的时候，RecyclerView需要显示进入屏幕的新item，这些item需要被绑定数据，然后把它们放入布局并绘制。当所有这些工作慢吞吞进行的时候，UI线程会慢慢停下来等待其完成，然后渲染才能进行，滚动才能继续。
当新item进入的时候检查调用栈可以看到大部分时间都花在了视图的创建和绑定上。

与其在准备item的时候推迟其所有其它工作，换个地方做这些工作不是更好吗？
为了提高UI渲染的效率引入了预取，原理：在RecyclerView开始一个滚动操作的时候启动一个Runnable。这个Runnable执行即将显示的item的预取操作，具体是哪些item取决于滚动的方向以及layout manager。预取不限于一个item，也可以一次预取多个item，比如GridLayoutManager中即将显示的一行item

默认的LayoutManager已经实现了这个功能

> RecyclerView性能优化

- 请求下来的数据如果需要二次处理，可异步处理后进行显示
- 尽量使用 notifyItemXxx 方法进行细粒度的通知更新，而不是 notifyDatasetChanged
  - 如果变更前后是两个数据集，无法确定具体哪一些数据项变化了，可以考虑使用 [DiffUtil](https://developer.android.google.cn/reference/androidx/recyclerview/widget/DiffUtil) 
- 对于`itemVIew`进行布局优化，
  - 通过new View()设置View，因为xml inflte是耗时IO操作
  - 复杂View或者共用部分可使用自定义View优化
- 加大`RecyclerView缓存`，比如cacheview大小默认为2，可以设置大点，用空间来换取时间，提高流畅度
- 如果不需要动画，可设置关闭动画
- 如果Item高度固定，可以设置`setHasFixedSize(true)`来避免requestLayout浪费资源，否则每次更新数据都会重新测量高度。
- 设置`RecyclerView.addOnScrollListener();`来在滑动过程中停止加载的操作。
- 如果多个` RecycledView` 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 `RecyclerView.setRecycledViewPool(pool); `来共用一个 `RecycledViewPool`。这样就减少了创建VIewholder的开销。
  - 如果 RecyclerView 中的每个 item 都是一个 RecyclerView， 并且子 RecyclerView 的 item type 相同可以通过 RecyclerView#setRecycledViewPool(); 方法，实现缓存池的复用

>Stable Id 的作用是什么

调用 notifyDataSetChanged，如果没有设置 hasStableId，会把要缓存的放到 RecyclerViewPool，如果设置了Stable Id,要缓存的ViewHolder 会进入 scrap，然后会通过 Id到 scrap 中查找 ViewHolder

## ListView、RecyclerView区别

一、使用方面：

- 两个继承的adapter不同，一个是BaseAdapter一个是RecyclerView.Adapter
- ListView的 ViewHolder需要自己实现， RecyclerView已经弄好了，只需要继承ViewHolder
- RecyclerView 复用 Item 的工作 Google 全帮你搞定，不再需要像 ListView 那样自己调用 setTag
- RecyclerView 需要多出一步 LayoutManager 的设置工作

二、布局方面：

* RecyclerView 支持 线性布局、网格布局、瀑布流布局 三种，而且同时还能够控制横向还是纵向滚动。

三、API提供方面：

* ListView 提供了 setEmptyView ，addFooterView 、 addHeaderView.

* RecyclerView 供了 notifyItemChanged 用于更新单个 Item View 的刷新，我们可以省去自己写局部更新的工作。

四、监听 Item 的事件：

​	ListView 提供了单击、长按、选中某个 Item 的监听设置。

#补间动画与属性动画的区别，哪个效率更高

> 区别

视图动画

- 只能对View的特定效果动画，比如缩放和旋转，但是不包括改变背景颜色。
- 只改变视图被绘制的位置点击事件没有改变

属性动画

- 可以对任何对象（包括View对象和非View对象）的任何属性应用动画，并且改变的确实是对象本身

视图动画设置起来更为简单而且编码量比较少，如果视图动画系统就能满足需求的话，或者原有代码已经实现了预期效果，那么就每没必要改用属性动画系统。当然也可能在某些情形下需要把两种动画系统结合起来使用。

> 效率：

​	属性动画操作的是对象的实例属性，例如translationX,然后反射调用set,get方法，多个属性动画同时执行，会频繁反射调用类方法，降低性能。
​	补间动画只是通过不停onDraw来重新绘制，其真实的坐标并没有发生改变，是效果一直在发生变化，没有频繁反射调用方法的耗费性能操作。

#高

## Bundle是什么数据结构?利用什么传递数据

Bundle内部是由ArrayMap实现的

##APP打包经过了哪几个流程

- 打包资源文件，通过AAPT(Android Asset Packaging Tool)打包成R.java类(资源索引表)以及.arsc资源文件。
- 处理AIDL文件，检查app中是否有aidl文件，如果有会通过aidl工具(源码位于system/tools/aidl）打包成java接口类
- 将class通过dx工具打包生成dex文件。
- 生成未签名的apk，包括apkbuilder工具将所有没有编译的资源、.arsc资源、.dex文件打包到一个完成apk文件中
- 生成签名的apk，包括jarsigner工具对未签名的apk验证签名。得到一个签名后的apk（signed.apk）
- zipAlign工具对齐上面签名的apk文件

##签名 V1/V2/V3

## APK组成

* META-INF：描述包信息
* res：存放资源文件的目录
* lib： so 库
* AndroidManifest.xml ：清单文件
* classes.dex：class文件合集
* resources.arsc：编译后的二进制资源文件
* kotlin

#RxJava 

`RxJava` 是一个 **基于事件流、实现异步操作**的库

> Rxjava是怎么实现线程切换的 https://mthli.xyz/rxjava-scheduler/

subscribeOn() 指定的就是被观察者创建的线程，只能指定一次，如果指定多次则以第一次为准

observerOn 指定的就是事件传递和观察者接收事件的线程。可指定多次，每次指定完都在下一步生效。

```
Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定
   .subscribeOn(Schedulers.io())
   .observeOn(Schedulers.newThread())
   .map(mapOperator) // 新线程，由 observeOn() 指定 
   .observeOn(Schedulers.io()) 
   .map(mapOperator2) // IO 线程，由 observeOn() 指定 
   .observeOn(AndroidSchedulers.mainThread) 
   .subscribe(subscriber); // Android 主线程，由 observeOn() 指定
```

> map关键字的作用是什么

返回结果不同: map返回的是结果集，flatmap返回的是包含结果集的Observable

转换能力：map转换时用于一对一，flatmap多用于多对多，一对多，再被转化为多个时，一般利用from/just进行一一分发，被订阅时将所有数据传递完毕汇总到一个Observable



#Eventbus源码 

https://www.jianshu.com/p/6da03454f75a

EventBus 发布/订阅事件的总线框架，基于观察者模式，将事件的接收者和发送者分开，基本包括了如下几个步骤:

​	注册事件的订阅方法:该步骤主要是找到订阅者下面有哪些方法需要被订阅

​	订阅操作:将需要被订阅的方法放到类似HashMap的数据结构中存储起来，方便后面发送事件和取消注册等资源的释放的时候使用

​	发送事件:该步骤首先遍历事件队列，然后从队列中取出事件，并且将事件从队列中移除，拿到事件后，判断事件处于的什么线程，如果是非UI线程，则需要Handler去处理，如果是的话，则直接通过反射调用被观察的方法。

​	反注册:该步骤就没什么好说的，主要是上面存储到HashMap中的被订阅的方法的移除，释放在内存中的资源。

EventBus最核心的逻辑就是利用了 subscriptionsByEventType 这个重要的列表，将订阅对象，即接收事件的方法存储在这个列表，发布事件的时候在列表中查询出相对应的方法并执行。

> 每次我们在register之后，都必须进行一次unregister，这是为什么呢？

因为register是强引用，它会让对象无法得到内存回收，导致内存泄露。所以必须在unregister方法中释放对象所占的内存。

#项目有什么难点 OK

1.在我们产品被下架的时候遇到一个问题：包上不去，上去就被封。
	最后得到一个解决方案，让谷歌感觉这是两个公司做的产品就行。
	针对这个问题我的解决方案如下：
	每个包对应一套电脑手机vpn,账号，一个服务器
	代码：对应一个三方账号，代码结构，包名，类名，全部重新写,框架能换的换，不能换的重新封装，里面的字符串全部加密，混淆换字典

3.本地定时任务  消息机制

4.数据倒灌

> 实现一个下载功能的接口

开始，下载中，暂停，取消，结束

#介绍一下你们项目的架构 ok

这个项目的架构是Mvvm，主要使用Jetpack 组件 + Repository来搭建，Repository管理本地数据和网络数据并提供数据，ViewModel 无需关心数据的来源，也不关心UI，只需要关注数据和业务逻辑即可，activity/frgament作为View，View层订阅LiveData，当ViewModel获取到数据使用LiveData通知View更新，使View和Model完全解耦，这就是我们架构

![mvvm架构图.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/mvvm%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)



# 单元测试 Ok

> Robolectric environment 测试跟Android相关使用的框架

```
@RunWith(RobolectricTestRunner.class)
@Config(application = RoboApp.class)
public class SharedPreferenceDaoTest {

    public static final String TEST_KEY = "instrumentedTest";
    public static final String TEST_STRING = "玉刚说";

    SharedPreferenceDao spDao;

    @Before
    public void setUp() {
        //这里的Context采用RuntimeEnvironment.application来替代应用的Context
        spDao = new SharedPreferenceDao(RuntimeEnvironment.application);
    }

    @Test
    public void sharedPreferenceDaoWriteRead() {
        spDao.put(TEST_KEY, TEST_STRING);
        Assert.assertEquals(TEST_STRING, spDao.get(TEST_KEY));
    }

}
```

> Mockito framework       测试跟Android不太相关使用的框架

```
@RunWith(MockitoJUnitRunner.class)
public class UnitTestSample {
	@Mock
    Context mMockContext;

    @Test
    public void readStringFromContext_LocalizedString() {
        //模拟方法调用的返回值，隔离对Android系统的依赖
        when(mMockContext.getString(R.string.app_name)).thenReturn(FAKE_STRING);
        assertThat(mMockContext.getString(R.string.app_name), is(FAKE_STRING));
        
        when(mMockContext.getPackageName()).thenReturn("com.jdqm.androidunittest");
        System.out.println(mMockContext.getPackageName());
    }
｝
```

# 网络 Ok

##Http概念

Http：超文本传输协议.采用c/s架构，传输层使用的是TCP，是一个无状态协议（服务器不记录客户端的历史行为）

##Https概念

Http的安全版。Http+SSL。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。

> Http与Https的区别

1、https协议需要到CA申请证书

2、http信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443

4、HTTP是没有身份认证的，客户端无法知道对方的真实身份。HTTPS加入了CA证书，更加安全。

> Https连接步骤

1.客户端发起请求，连接到服务器的443端口
2.服务端收到请求后，把证书信息(包含公钥)返回给客户端
3.客户端收到服务器的响应后会先验证证书的合法性
4.如果验证通过，客户端生成会话秘钥并用公钥加密，发送给服务端

5.服务器利用自己的私钥解密出会话密钥。

6.服务器利用会话密钥加密与客户端之间的通信

>HTTP1.0 vs HTTP1.1 vs HTTP1.2

HTTP1.1 vs HTTP1.0
1 缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
2.长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点
3.性能优化

HTTP1.1 vs HTTP1.2
HTTP2.0的多路复用和HTTP1.1中的长连接复用有什么区别？
HTTP1.1的长连接复用是，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
HTTP2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；

> Http GET，POST和PUT的区别

url描述了一个网络上资源，而post、get、put、delete就是对这个资源进行增、删、改、查的操作

PUT和POSt


PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）


Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）

get和post (get用来查资源)
1.GET参数通过URL传递，POST放在Request body中。

2.get传送的数据量较小，post传送的数据量较大
3.get参数可见不安全

> 请求 响应报文

请求行、请求头、请求体

* 请求行：方法字段、URL字段、HTTP协议版本字段：GET /index.html HTTP/1.1。
* 请求头：向服务器发送请求的时候必须指明请求类型；User-Agent：浏览器类型；Host：主机名
* 请求体：POST发送的数据


响应行、响应头、响应体

* 响应行：协议版本、状态码及其描述组成 比如 HTTP/1.1 200 OK
* 响应头：响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。Last-Modified，ETag，Content-Length
* 响应体：响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码

##TCP和UDP的比较

1. TCP面向连接；udp无连接
2. TCP可靠传输，使用流量控制和拥塞控制；不可靠传输
3. TCP面向字节流；UDP面向报文
4. TCP适用于要求可靠传输的应用，例如文件传输；适用于实时应用（IP电话、视频会议、直播等）

## token放在本地如何保存？如何加密比较好

token意为令牌，通常是由客户端携带IMEI/Mac到服务器，服务器根据客户端的IMEI/Mac生成一段字符串并返回给客户端，并为其设置有效期。以此作为客户端和服务端交互的令牌。客户端每次请求都会携带token到服务器来代替用户名和密码。服务端验证token有效后则返回数据给客户端，否则返回特定的错误码给客户端。客户端根据错误码去做相应的处理。

好处：

​	保证安全性。每次请求数据不用携带用户名和密码

​	减小服务器压力。减少服务器认证用户名和密码的操作(用户多，查询慢)

主要步骤如下： 

* 通过用户名和密码登录成功获取token和refreshToken并保存到本地。 

* token的有效期为2小时，refreshToken的有效期为15天。 

* 每次网络请求都需要带上token，而不必带上refreshToken。 

* 如果服务器端判断token过期，则返回对应的错误码，客户端判断错误码后调用刷新token接口,重新获取token和refreshToken并存储。 

* 如果连续15天未使用app或者用户修改了密码，则refreshToken过期，需要重新登录获取token和refreshToken。

保存SP，对称加密

> 加密

DES/AES是一种对称加密算法，所谓对称加密算法即：加密和解密使用相同密钥的算法
RSA非对称加密，公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密

## 域名容灾

解决方案：

1. 当使用域名访问出现找不到主机，请求超时等异常时，直接切换至IP地址重试请求；且App在下次启动之前，一直使用该IP进行网络请求

2. 腾讯云HttpDNS，阿里云HttpDNS，DNSPod等厂家提供HttpDNS方案，客户端接入方便，开发量较小，相对稳定。

   1. 通过使用 HttpDNS，绕过运营商域名解析过程，提供私有的DNS解析服务,HttpDNS 不是使用传统的 DNS 协议，向 DNS 服务器的 53 端口发送请求，而是使用 Http 协议，向服务器的 80 端口发送请求。
      这样做的好处有两个：

      	防劫持：降低 Local DNS 劫持，绕过运营商域名解析过程；
      	
      	提升速度：降低平均访问时长，因为节省了一次解析过程；

##网页中输入url，到渲染整个界面的整个过程，以及中间用了什么协议

过程分析：主要分为三步

- `DNS解析`。用户输入url后，需要通过DNS解析找到域名对应的ip地址，有了ip地址才能找到服务器端。首先会查找浏览器缓存，是否有对应的dns记录。再继续按照操作系统缓存—路由缓存—isp的dns服务器—根服务器的顺序进行DNS解析，直到找到对应的ip地址。
- `客户端（浏览器）和服务器交互`。浏览器根据解析到的ip地址和端口号发起HTTP请求，请求到达传输层，这里也就是TCP层，开始三次握手建立连接。服务器收到请求后，发送相应报文给客户端（浏览器），客户端收到相应报文并进行解析，得到html页面数据，包括html，js，css等。
- `客户端（浏览器）解析html数据`，构建DOM树，再构造呈现树（render树），最终绘制到浏览器页面上。

2）其中涉及到TCP/IP协议簇，包括DNS，TCP，IP，HTTP协议等等。

##Retrofit

Retrofit主要是在create方法中采用动态代理模式实现接口，这个过程构建了一个ServiceMethod对象，
根据方法注解获取请求方式，参数类型和参数注解拼接请求的链接，当一切都准备好之后会把数据添加到Retrofit的RequestBuilder中。
然后当我们主动发起网络请求的时候会调用okhttp发起网络请求，
okhttp的配置包括请求方式，URL等在Retrofit的RequestBuilder的build()方法中实现，并发起真正的网络请求。

> OKHttp有哪些拦截器，分别起什么作用

okhttp的拦截器就是将整个请求网络的过程的每一步都封装成不同的Interceptor，放到list里，依次执行。责任链模式

- RetryAndFollowUpInterceptor 负责失败重试
- BridgeInterceptor 负责把用户构建的请求转换为发送到服务器的请求，并把服务器的响应转化为用户需要的响应
- CacheInterceptor 负责缓存配置
- ConnectInterceptor 
- CallServerInterceptor 这两个的作用是负责和服务器建立socket连接，并向服务器发送数据，读取数据

> OKhttp设计模式

Builder
责任链模式
Strategy 策略模式 OKhttp缓存

> OkHttp怎么实现连接池

https://mrfzh.github.io/2019/07/19/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%A4%8D%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0/

连接池的意义：是为了缓存连接，空闲时间超过 5 分钟的连接就会被清除。所以连接池中连接的复用是为了避免出现在一段时间内频繁地创建和销毁连接而导致性能下降。

连接池最大连接数5，默认keep-alive的时间是5分钟

连接池在RetorfitClient初始化的时候会创建，put时先清理操作再put新连接到队列，清除操作是个无限循环，在没有需要清理的连接时会退出

连接池通过双端队列(前后都支持插入和删除操作的队列)去存取连接，并使用一个定时任务定期清理无用连接

1. 去连接池中看是否有相同host的连接
2. 如果在连接池中找不到连接的话，会创建连接，创建完后会存储到连接池中。
3. 在把连接放入连接池中时，会通过线程池执行清除任务，清除任务中会遍历连接，找出空闲时间最长的连接，
   1. 如果最长空闲时间超过了5分钟，或者空闲连接数超过了5，就移除空闲时间最长的连接
   2. 如果存在空闲连接，但最长空闲时间没有超5分钟且空闲连接数不超过5，不移除连接，返回最长空闲连接的剩余时间。线程会休眠对应时间，醒来继续清理
   3. 如果不存在空闲连接，只有正在使用的连接，不移除连接，5分钟后再清理
   4. 如果没有任何连接，说明清除任务完成，线程执行完毕

唤醒：

1.超时时间到

HTTP复用连接： 

向服务器发起请求时，header 部分如果有 Connection: keep-alive，表示客户端和服务器之间保存长连接，这个连接是可以复用的。长连接在 HTTP/1.1 中默认开启。

连接的复用可以提高性能。没有连接复用的话，发起 http 请求时要先建立 TCP 连接，然后传递数据，最后再释放连接。如果同一个客户端在某段时间进行频繁的请求操作，这时频繁的创建和释放连接会导致性能低下。而如果可以连接复用，那么在 timeout 空闲时间内，连接不会关闭，这样就可以减少连接的创建和释放，大幅提高性能。

![okhttp连接池.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/okhttp%E8%BF%9E%E6%8E%A5%E6%B1%A0.png?raw=true)

>CacheInterceptor源码解读（继续背6）

https://blog.csdn.net/zly921112/article/details/103645019

按照http协议实现响应的缓存: 资源在服务器的唯一标识 : 资源最后修改时间

HTTP缓存

浏览器请求：

* 看浏览器有没有缓存
  * 没有，则进行网络请求并根据response缓存控制字段看是否缓存本次响应
  * 有 
    * 判断是否过期 
      * 未过期直接使用 
      * 过期 
        * 缓存有Etag么，有的话将etag值通过If-None-Matcher传递给服务端看缓存是否有修改，没有则返回304继续使用缓存并更新缓存过期时间，否则返回200和新的资源数据并根据response缓存控制字段看是否缓存本次响应 
        * 缓存有Last-Modified么，有则通过If-Modified-Since把缓存的修改时间告知服务器，如果在这个时间后资源没有更新，则返回304继续使用缓存并更新缓存过期时间，否则返回200和新的资源数据并根据response缓存控制字段看是否缓存本次响应 
        * 既没有Etag也没有Last-Modified则直接进行请求并根据response缓存控制字段看是否缓存本次响应

先获取本地缓存，然后通过缓存策略确定是进行网络请求还是使用缓存，如果既不使用缓存也不进行网络请求返回一个code为504的response，如果网络请求不可用而缓存可用则直接使用缓存，如果网络请求可用进行请求，请求后在判断有缓存并且响应码为304的话则更新缓存，否则在判断reponse能否缓存，可以的话则存储缓存，不可以的话则删除缓存

![Http缓存流程.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/Http%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B.png?raw=true)

![Cache-Control取值.png](https://github.com/creativityingenuity/DayDayStudy/blob/master/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/Cache-Control%E5%8F%96%E5%80%BC.png?raw=true)

> 响应码

1**	信息，服务器收到请求，需要请求者继续执行操作

2**	成功，操作被成功接收并处理

3**	重定向，需要进一步的操作以完成请求

4**	客户端错误，请求包含语法错误或无法完成请求

5**	服务器错误，服务器在处理请求的过程中发生了错误

常用状态码：

200 请求成功 404 找不到资源 302 重定向  500 服务器内部错误 502 请求超时

> 网络封装怎么实现？如果让你写一个网络框架，你怎么写

1. 网络请求队列，使用线程池进行请求
2. 结果解析：提供各种不同类型的返回值的解析如String，Json，图片等等
3. 网络请求结果基于观察者模式进行传递，回调操作与 UI 层的生命周期相绑定，避免了内存泄漏
4. 缓存队列,以url为key缓存，内容可以参考Bitmap的处理方式，这里单独开启一个线程

> 三次握手，四次挥手

客户端简称A，服务器端简称B 

1）TCP建立连接需要三次握手

- A向B表示想跟B进行连接（A发送`syn`包，A进入`SYN_SENT`状态）
- B收到消息，表示我也准备好和你连接了（B收到`syn`包，需要确认`syn`包，并且自己也发送一个`syn`包，即发送了`syn+ack`包，B进入`SYN_RECV`状态）
- A收到消息，并告诉B表示我收到你也准备连接的信号了（A收到`syn+ack`包，向服务器发送确认包`ack`，AB进入`established`状态）开始连接。

2）TCP断开连接需要四次挥手

- A向B表示想跟B断开连接（A发送`fin`，进入`FIN_WAIT_1`状态）
- B收到消息，但是B消息没发送完，只能告诉A我收到你的断开连接消息（B收到fin，发送ack，进入`CLOSE_WAIT`状态，A进入`FIN-WAIT-2`状态）
- 过一会，B数据发送完毕，告诉A，我可以跟你断开了（B发送fin，进入`LAST_ACK`状态，A进入`TIME-WAIT`状态）
- A收到消息，告诉B，可以他断开（A收到fin，发送ack，B进入`closed`状态）

TCP 协议为了实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要重发。

问题：

1. 为什么建立TCP连接需要三次握手，而关闭连接则需要四次握手
   这是由于TCP连接是全双工的，我关了你的连接，并不等于你关了我的连接（一端关闭是单方向关闭），因此双方都必须单独进行关闭。当一方完成它的数据发送任务后可以发送FIN包来终止这个方向的连接，表明自己不再有数据需要发送；收到FIN包的那一方虽然不能再读取数据，但仍能发送数据

2. 为什么连接需要三次，而不是两次。

   TCP是双向通信协议，如果两次握手，不能保证B发给A的消息正确到达

   为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
   “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用三次握手，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用三次握手的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。

3. TCP是怎么保证可靠传输的？

   序列号和确认号。比如连接的一方发送一段80byte数据，会带上一个序列号，比如101。接收方收到数据，回复确认号181（180+1），这样下一次发送消息就会从181开始发送了。

   

   

#算法的时间、空间复杂度

https://zhuanlan.zhihu.com/p/50479555

> 生产者消费者

```
class Hole {
    private int contents;
    private boolean available = false;
    public synchronized int get() {
        while (!available) {
            try {
                wait();
            }
            catch (InterruptedException e) {
            }
        }
        available = false;
        notifyAll();
        return contents;
    }
    public synchronized void put(int value) {
        while (available) {
            try {
                wait();
            }
            catch (InterruptedException e) {
            }
        }
        contents = value;
        available = true;
        notifyAll();
    }
}

class Consumer extends Thread {
    private Hole hole;
    public Consumer(Hole c) {
        hole = c;
    }
    public void run() {
        int value = 0;
        for (int i = 0; i < 10; i++) {
            value = hole.get();
            System.out.println("消费者 #" + " got: " + value);
        }
    }
}

class Producer extends Thread {
    private Hole hole;

    public Producer(Hole c) {
        hole = c;
    }

    public void run() {
        for (int i = 0; i < 10; i++) {
            hole.put(i);
            System.out.println("生产者 #" + " put: " + i);
            try {
                sleep((int)(Math.random() * 100));
            } catch (InterruptedException e) { }
        }
    }
}
```

> pow(x,n)

```
class Solution {
    public double myPow(double x, int n) {
        double res = 1.0;
        for(int i = n; i != 0; i /= 2){
            if(i % 2 != 0){
                res *= x;
            }
            x *= x;
        }
        return  n < 0 ? 1 / res : res;
    }
}
```

> 快速排序

```
/*
快速排序使用分治法策略来把一个序列分为两个子序列，基本步骤为：

1.先从序列中取出一个数作为基准数；
2.分区过程：将把这个数大的数全部放到它的右边，小于或者等于它的数全放到它的左边；
3.递归地对左右子序列进行不走2，直到各区间只有一个数。
 */

    private static int partition(int[] arr, int left, int right) {
        int temp = arr[left];
        while (right > left) {
            // 先判断基准数和后面的数依次比较
            while (temp <= arr[right] && left < right) {
                right--;
            }
            arr[left] = arr[right];
            // 现在是 arr[right] 需要填坑了
            while (temp >= arr[left] && left < right) {
                left++;
            }
            arr[right] = arr[left];
        }
        arr[left] = temp;
        return left;
    }

    private static void quickSort(int[] arr, int left, int right) {
        if (arr == null || right < left)
            return;
        int mid = partition(arr, left, right);
        quickSort(arr, left, mid-1);
        quickSort(arr, mid + 1, right);
    }
最好	O(nlogn) 最坏O(n2)
```

> 排序

```
二分查找
public static int erfen(){
		int[] arr = {5,16,39,45,51,98,100,202,226,321,368,444,501};
		int left = 0;
		int right = arr.length-1;
		int k = 5;//要查找的值     
		while(left<=right){
			int mid = (left+right)/2;
			if(k>arr[mid]){
				left = mid+1;
			}else if(k<arr[mid]){
				right = mid-1;
			}else{
				return mid;
			}
		}
		return -1;
}

冒泡排序
/*
 * 冒泡排序基本概念是：
 * 依次比较相邻的两个数，将小数放在前面，大数放在后面。
 * 即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。
 * 然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，
 * 直至比较最后两个数，将小数放前，大数放后。至此第一趟结束，
 * 将最大的数放到了最后。在第二趟：仍从第一对数开始比较
 * （因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），
 * 将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的），
 * 第二趟结束，在倒数第二的位置上得到一个新的最大数
 * （其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。 
 */
public class BubbleSort {
	public static void main(String[] args) {
		int[] arr = {1,56,3,21,5,78,932,7,1241,6,7,8,4,2};
		//判断一遍比较后是否进行了位置交换，如果没有则说明已排好序。退出循环
		boolean flag = false;
		// 冒泡排序
		for (int i = 0; i < arr.length-1; i++) {//比较数组长度减1次
			for (int j = 0; j < arr.length - i-1; j++) {//每边比较完，最大的都会出现在最后
				if (arr[j] > arr[j + 1]) {
					swap(arr, j, j + 1);
					flag = true;
				}
			}
			if(!flag){
				break;
			}
		}
		for(int i:arr){
			System.out.print(i+"，");
		}
	}
	//交换位置
	private static void swap(int[] arr, int j, int i) {
		int t;
		t = arr[j];
		arr[j] = arr[i];
		arr[i] = t;
	}

}
O(n2)
选择排序
/*
 * 选择排序基本思路：
 * 把第一个元素依次和后面的所有元素进行比较。
 * 第一次结束后，就会有最小值出现在最前面。
 * 依次类推
 */
public class SelectionSort {
	public static void sort(int[] data) {
		for (int x = 0; x < data.length - 1; x++) {
			for (int y = x + 1; y < data.length; y++) {
				if (data[y] < data[x]) {
					SortTest.swap(data, x, y);
				}
			}
		}
	}
}
O(n2)

插入排序
public class InsertSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
        for (int i = 1; i < arr.length; i++) {

            // 记录要插入的数据
            int tmp = arr[i];

            // 从已经排序的序列最右边的开始比较，找到比其小的数
            int j = i;
            while (j > 0 && tmp < arr[j - 1]) {
                arr[j] = arr[j - 1];
                j--;
            }

            // 存在比其小的数，插入
            if (j != i) {
                arr[j] = tmp;
            }

        }
        return arr;
    }
}
```

满二叉树：二叉树除了叶结点外所有节点都有两个子节点
完全二叉树：从根往下数，除了最下层外都是全满

# 数据库

> 聊天信息表设计

表结构：

1.聊天主表

```
id(主键id)                             
user_id(用户id)                   
another_id(对方用户id)     
```

2.聊天列表表

    id(自增id)                            
    chat_id (聊天主表id)        
    user_id (用户id)                  
    another_id (对方用户id)     
    is_online (是否在线)      
    unread (未读数)         
    status (是否删除)        

3.聊天详情表

    id (自增id)                          
    chat_id (主表聊天id)        
    user_id (消息所有者id)               
    content (聊天内容)       
    time (发送时间)          
    type (消息类型)         
    is_latest (是不是最后一条消息（默认1）)         
聊天逻辑：

1. 点击聊天

判断是不是第一次聊天，如果是会在主表生成一条记录返回聊天主表id，并在聊天列表表分别插入两条记录，如果不是第一次聊天进入下一步

2. 进入聊天对话框

获取上一次聊天聊天记录，将用户在此对话的在线状态改为在线

3. 发送聊天信息
   1. 先判断对方是否在线，不在线的话对方未读数+1
   2. 将上一条最后一条消息状态改为否
   3. 往聊天详情表插入聊天信息数据

4. 删除聊天列表

将该用户的聊天列表删除状态改为删除 

##反编译：
	ApkTool：可以反编译和回编译。得到的res和AndroidManifest
		apktool d xxx.apk
	dex2jar：将dex文件转换为jar包
		解压Apk,cmd-> d2j-dex2jar classes.dex
	jd-gui：用来查看jar包里的代码
		打开上一步得到的文件